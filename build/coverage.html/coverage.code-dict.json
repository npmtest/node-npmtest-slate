{"/home/travis/build/npmtest/node-npmtest-slate/test.js":"/* istanbul instrument in package npmtest_slate */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-slate/lib.npmtest_slate.js":"/* istanbul instrument in package npmtest_slate */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_slate = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_slate = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-slate/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-slate && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_slate */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_slate\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_slate.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_slate.rollup.js'] =\n            local.assetsDict['/assets.npmtest_slate.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_slate.__dirname + '/lib.npmtest_slate.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/index.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setKeyGenerator = exports.resetKeyGenerator = exports.findDOMNode = exports.Transforms = exports.Text = exports.State = exports.Stack = exports.Selection = exports.Schema = exports.Raw = exports.Range = exports.Plain = exports.Placeholder = exports.Mark = exports.Inline = exports.Html = exports.Editor = exports.Document = exports.Data = exports.Character = exports.Block = undefined;\n\nvar _editor = require('./components/editor');\n\nvar _editor2 = _interopRequireDefault(_editor);\n\nvar _placeholder = require('./components/placeholder');\n\nvar _placeholder2 = _interopRequireDefault(_placeholder);\n\nvar _block = require('./models/block');\n\nvar _block2 = _interopRequireDefault(_block);\n\nvar _character = require('./models/character');\n\nvar _character2 = _interopRequireDefault(_character);\n\nvar _data = require('./models/data');\n\nvar _data2 = _interopRequireDefault(_data);\n\nvar _document = require('./models/document');\n\nvar _document2 = _interopRequireDefault(_document);\n\nvar _inline = require('./models/inline');\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nvar _mark = require('./models/mark');\n\nvar _mark2 = _interopRequireDefault(_mark);\n\nvar _schema = require('./models/schema');\n\nvar _schema2 = _interopRequireDefault(_schema);\n\nvar _selection = require('./models/selection');\n\nvar _selection2 = _interopRequireDefault(_selection);\n\nvar _stack = require('./models/stack');\n\nvar _stack2 = _interopRequireDefault(_stack);\n\nvar _state = require('./models/state');\n\nvar _state2 = _interopRequireDefault(_state);\n\nvar _text = require('./models/text');\n\nvar _text2 = _interopRequireDefault(_text);\n\nvar _range = require('./models/range');\n\nvar _range2 = _interopRequireDefault(_range);\n\nvar _html = require('./serializers/html');\n\nvar _html2 = _interopRequireDefault(_html);\n\nvar _plain = require('./serializers/plain');\n\nvar _plain2 = _interopRequireDefault(_plain);\n\nvar _raw = require('./serializers/raw');\n\nvar _raw2 = _interopRequireDefault(_raw);\n\nvar _transforms = require('./transforms');\n\nvar _transforms2 = _interopRequireDefault(_transforms);\n\nvar _findDomNode = require('./utils/find-dom-node');\n\nvar _findDomNode2 = _interopRequireDefault(_findDomNode);\n\nvar _generateKey = require('./utils/generate-key');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\n/**\n * Utils.\n */\n\n/**\n * Serializers.\n */\n\n/**\n * Models.\n */\n\n/**\n * Components.\n */\n\nexports.Block = _block2.default;\nexports.Character = _character2.default;\nexports.Data = _data2.default;\nexports.Document = _document2.default;\nexports.Editor = _editor2.default;\nexports.Html = _html2.default;\nexports.Inline = _inline2.default;\nexports.Mark = _mark2.default;\nexports.Placeholder = _placeholder2.default;\nexports.Plain = _plain2.default;\nexports.Range = _range2.default;\nexports.Raw = _raw2.default;\nexports.Schema = _schema2.default;\nexports.Selection = _selection2.default;\nexports.Stack = _stack2.default;\nexports.State = _state2.default;\nexports.Text = _text2.default;\nexports.Transforms = _transforms2.default;\nexports.findDOMNode = _findDomNode2.default;\nexports.resetKeyGenerator = _generateKey.resetKeyGenerator;\nexports.setKeyGenerator = _generateKey.setKeyGenerator;\n\n/**\n * Transforms.\n */\n\nexports.default = {\n  Block: _block2.default,\n  Character: _character2.default,\n  Data: _data2.default,\n  Document: _document2.default,\n  Editor: _editor2.default,\n  Html: _html2.default,\n  Inline: _inline2.default,\n  Mark: _mark2.default,\n  Placeholder: _placeholder2.default,\n  Plain: _plain2.default,\n  Range: _range2.default,\n  Raw: _raw2.default,\n  Schema: _schema2.default,\n  Selection: _selection2.default,\n  Stack: _stack2.default,\n  State: _state2.default,\n  Text: _text2.default,\n  Transforms: _transforms2.default,\n  findDOMNode: _findDomNode2.default,\n  resetKeyGenerator: _generateKey.resetKeyGenerator,\n  setKeyGenerator: _generateKey.setKeyGenerator\n};","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/components/editor.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _reactPortal = require('react-portal');\n\nvar _reactPortal2 = _interopRequireDefault(_reactPortal);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _stack = require('../models/stack');\n\nvar _stack2 = _interopRequireDefault(_stack);\n\nvar _state = require('../models/state');\n\nvar _state2 = _interopRequireDefault(_state);\n\nvar _noop = require('../utils/noop');\n\nvar _noop2 = _interopRequireDefault(_noop);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = (0, _debug2.default)('slate:editor');\n\n/**\n * Event handlers to mix in to the editor.\n *\n * @type {Array}\n */\n\nvar EVENT_HANDLERS = ['onBeforeInput', 'onBlur', 'onFocus', 'onCopy', 'onCut', 'onDrop', 'onKeyDown', 'onPaste', 'onSelect'];\n\n/**\n * Plugin-related properties of the editor.\n *\n * @type {Array}\n */\n\nvar PLUGINS_PROPS = [].concat(EVENT_HANDLERS, ['placeholder', 'placeholderClassName', 'placeholderStyle', 'plugins', 'schema']);\n\n/**\n * Editor.\n *\n * @type {Component}\n */\n\nvar Editor = function (_React$Component) {\n  _inherits(Editor, _React$Component);\n\n  /**\n   * When constructed, create a new `Stack` and run `onBeforeChange`.\n   *\n   * @param {Object} props\n   */\n\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  function Editor(props) {\n    _classCallCheck(this, Editor);\n\n    var _this = _possibleConstructorReturn(this, (Editor.__proto__ || Object.getPrototypeOf(Editor)).call(this, props));\n\n    _initialiseProps.call(_this);\n\n    _this.tmp = {};\n    _this.state = {};\n\n    // Create a new `Stack`, omitting the `onChange` property since that has\n    // special significance on the editor itself.\n\n    var onChange = props.onChange,\n        rest = _objectWithoutProperties(props, ['onChange']); // eslint-disable-line no-unused-vars\n\n\n    var stack = _stack2.default.create(rest);\n    _this.state.stack = stack;\n\n    // Resolve the state, running `onBeforeChange` first.\n    var state = stack.onBeforeChange(props.state, _this);\n    _this.cacheState(state);\n    _this.state.state = state;\n\n    // Create a bound event handler for each event.\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      var _loop = function _loop() {\n        var method = _step.value;\n\n        _this[method] = function () {\n          var _this$state$stack;\n\n          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          var next = (_this$state$stack = _this.state.stack)[method].apply(_this$state$stack, [_this.state.state, _this].concat(args));\n          _this.onChange(next);\n        };\n      };\n\n      for (var _iterator = EVENT_HANDLERS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        _loop();\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return _this;\n  }\n\n  /**\n   * When the `props` are updated, create a new `Stack` if necessary, and\n   * run `onBeforeChange`.\n   *\n   * @param {Object} props\n   */\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Cache a `state` in memory to be able to compare against it later, for\n   * things like `onDocumentChange`.\n   *\n   * @param {State} state\n   */\n\n  /**\n   * Programmatically blur the editor.\n   */\n\n  /**\n   * Programmatically focus the editor.\n   */\n\n  /**\n   * Get the editor's current schema.\n   *\n   * @return {Schema}\n   */\n\n  /**\n   * Get the editor's current state.\n   *\n   * @return {State}\n   */\n\n  /**\n   * When the `state` changes, pass through plugins, then bubble up.\n   *\n   * @param {State} state\n   */\n\n  /**\n   * Render the editor.\n   *\n   * @return {Element}\n   */\n\n  return Editor;\n}(_react2.default.Component);\n\n/**\n * Mix in the property types for the event handlers.\n */\n\nEditor.propTypes = {\n  autoCorrect: _react2.default.PropTypes.bool,\n  autoFocus: _react2.default.PropTypes.bool,\n  className: _react2.default.PropTypes.string,\n  onBeforeChange: _react2.default.PropTypes.func,\n  onChange: _react2.default.PropTypes.func,\n  onDocumentChange: _react2.default.PropTypes.func,\n  onSelectionChange: _react2.default.PropTypes.func,\n  placeholder: _react2.default.PropTypes.any,\n  placeholderClassName: _react2.default.PropTypes.string,\n  placeholderStyle: _react2.default.PropTypes.object,\n  plugins: _react2.default.PropTypes.array,\n  readOnly: _react2.default.PropTypes.bool,\n  role: _react2.default.PropTypes.string,\n  schema: _react2.default.PropTypes.object,\n  spellCheck: _react2.default.PropTypes.bool,\n  state: _react2.default.PropTypes.instanceOf(_state2.default).isRequired,\n  style: _react2.default.PropTypes.object,\n  tabIndex: _react2.default.PropTypes.number\n};\nEditor.defaultProps = {\n  autoFocus: false,\n  autoCorrect: true,\n  onChange: _noop2.default,\n  onDocumentChange: _noop2.default,\n  onSelectionChange: _noop2.default,\n  plugins: [],\n  readOnly: false,\n  schema: {},\n  spellCheck: true\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this2 = this;\n\n  this.componentWillReceiveProps = function (props) {\n    var stack = _this2.state.stack;\n\n    // If any plugin-related properties will change, create a new `Stack`.\n\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = PLUGINS_PROPS[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var prop = _step3.value;\n\n        if (props[prop] == _this2.props[prop]) continue;\n\n        var onChange = props.onChange,\n            rest = _objectWithoutProperties(props, ['onChange']); // eslint-disable-line no-unused-vars\n\n\n        stack = _stack2.default.create(rest);\n        _this2.setState({ stack: stack });\n      }\n\n      // Resolve the state, running the before change handler of the stack.\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    var state = stack.onBeforeChange(props.state, _this2);\n    _this2.cacheState(state);\n    _this2.setState({ state: state });\n  };\n\n  this.cacheState = function (state) {\n    _this2.tmp.document = state.document;\n    _this2.tmp.selection = state.selection;\n  };\n\n  this.blur = function () {\n    var state = _this2.state.state.transform().blur().apply();\n\n    _this2.onChange(state);\n  };\n\n  this.focus = function () {\n    var state = _this2.state.state.transform().focus().apply();\n\n    _this2.onChange(state);\n  };\n\n  this.getSchema = function () {\n    return _this2.state.stack.schema;\n  };\n\n  this.getState = function () {\n    return _this2.state.state;\n  };\n\n  this.onChange = function (state) {\n    if (state == _this2.state.state) return;\n    var tmp = _this2.tmp,\n        props = _this2.props;\n    var stack = _this2.state.stack;\n    var onChange = props.onChange,\n        onDocumentChange = props.onDocumentChange,\n        onSelectionChange = props.onSelectionChange;\n    var document = tmp.document,\n        selection = tmp.selection;\n\n\n    state = stack.onChange(state, _this2);\n    onChange(state);\n    if (state.document != document) onDocumentChange(state.document, state);\n    if (state.selection != selection) onSelectionChange(state.selection, state);\n  };\n\n  this.render = function () {\n    var props = _this2.props,\n        state = _this2.state;\n    var stack = state.stack;\n\n    var children = stack.renderPortal(state.state, _this2).map(function (child, i) {\n      return _react2.default.createElement(\n        _reactPortal2.default,\n        { key: i, isOpened: true },\n        child\n      );\n    });\n\n    debug('render', { props: props, state: state });\n\n    var tree = stack.render(state.state, _this2, _extends({}, props, { children: children }));\n    return tree;\n  };\n};\n\nvar _iteratorNormalCompletion2 = true;\nvar _didIteratorError2 = false;\nvar _iteratorError2 = undefined;\n\ntry {\n  for (var _iterator2 = EVENT_HANDLERS[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n    var property = _step2.value;\n\n    Editor.propTypes[property] = _react2.default.PropTypes.func;\n  }\n\n  /**\n   * Export.\n   *\n   * @type {Component}\n   */\n} catch (err) {\n  _didIteratorError2 = true;\n  _iteratorError2 = err;\n} finally {\n  try {\n    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n      _iterator2.return();\n    }\n  } finally {\n    if (_didIteratorError2) {\n      throw _iteratorError2;\n    }\n  }\n}\n\nexports.default = Editor;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/models/stack.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _core = require('../plugins/core');\n\nvar _core2 = _interopRequireDefault(_core);\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _schema2 = require('./schema');\n\nvar _schema3 = _interopRequireDefault(_schema2);\n\nvar _state = require('./state');\n\nvar _state2 = _interopRequireDefault(_state);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = (0, _debug2.default)('slate:stack');\n\n/**\n * Methods that are triggered on events and can change the state.\n *\n * @type {Array}\n */\n\nvar EVENT_HANDLER_METHODS = ['onBeforeInput', 'onBlur', 'onFocus', 'onCopy', 'onCut', 'onDrop', 'onKeyDown', 'onPaste', 'onSelect'];\n\n/**\n * Methods that accumulate an updated state.\n *\n * @type {Array}\n */\n\nvar STATE_ACCUMULATOR_METHODS = ['onBeforeChange', 'onChange'];\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  plugins: [],\n  schema: new _schema3.default()\n};\n\n/**\n * Stack.\n *\n * @type {Stack}\n */\n\nvar Stack = function (_ref) {\n  _inherits(Stack, _ref);\n\n  function Stack() {\n    var _ref2;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Stack);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref2 = Stack.__proto__ || Object.getPrototypeOf(Stack)).call.apply(_ref2, [this].concat(args))), _this), _this.render = function (state, editor, props) {\n      debug('render');\n      var plugins = _this.plugins.slice().reverse();\n      var children = void 0;\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var plugin = _step.value;\n\n          if (!plugin.render) continue;\n          children = plugin.render(props, state, editor);\n          props.children = children;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return children;\n    }, _this.renderPortal = function (state, editor) {\n      debug('renderPortal');\n      var portals = [];\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = _this.plugins[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var plugin = _step2.value;\n\n          if (!plugin.renderPortal) continue;\n          var portal = plugin.renderPortal(state, editor);\n          if (portal == null) continue;\n          portals.push(portal);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return portals;\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(Stack, [{\n    key: 'kind',\n\n\n    /**\n     * Get the kind.\n     *\n     * @return {String}\n     */\n\n    get: function get() {\n      return 'stack';\n    }\n\n    /**\n     * Invoke `render` on all of the plugins in reverse, building up a tree of\n     * higher-order components.\n     *\n     * @param {State} state\n     * @param {Editor} editor\n     * @param {Object} children\n     * @param {Object} props\n     * @return {Component}\n     */\n\n    /**\n     * Invoke `renderPortal` on all of the plugins, building a list of portals.\n     *\n     * @param {State} state\n     * @param {Editor} editor\n     * @return {Array}\n     */\n\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Constructor.\n     *\n     * @param {Object} properties\n     *   @property {Array} plugins\n     *   @property {Schema|Object} schema\n     *   @property {Function} ...handlers\n     */\n\n    value: function create(properties) {\n      var plugins = resolvePlugins(properties);\n      var schema = resolveSchema(plugins);\n      return new Stack({ plugins: plugins, schema: schema });\n    }\n  }]);\n\n  return Stack;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Mix in the event handler methods.\n *\n * @param {State} state\n * @param {Editor} editor\n * @param {Mixed} ...args\n * @return {State|Null}\n */\n\nvar _iteratorNormalCompletion3 = true;\nvar _didIteratorError3 = false;\nvar _iteratorError3 = undefined;\n\ntry {\n  var _loop = function _loop() {\n    var method = _step3.value;\n\n    Stack.prototype[method] = function (state, editor) {\n      debug(method);\n\n      if (method == 'onChange') {\n        state = this.onBeforeChange(state, editor);\n      }\n\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = this.plugins[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var plugin = _step6.value;\n\n          if (!plugin[method]) continue;\n          var next = plugin[method].apply(plugin, args.concat([state, editor]));\n          if (next == null) continue;\n          assertState(next);\n          return next;\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      return state;\n    };\n  };\n\n  for (var _iterator3 = EVENT_HANDLER_METHODS[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n    _loop();\n  }\n\n  /**\n   * Mix in the state accumulator methods.\n   *\n   * @param {State} state\n   * @param {Editor} editor\n   * @param {Mixed} ...args\n   * @return {State|Null}\n   */\n} catch (err) {\n  _didIteratorError3 = true;\n  _iteratorError3 = err;\n} finally {\n  try {\n    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n      _iterator3.return();\n    }\n  } finally {\n    if (_didIteratorError3) {\n      throw _iteratorError3;\n    }\n  }\n}\n\nvar _iteratorNormalCompletion4 = true;\nvar _didIteratorError4 = false;\nvar _iteratorError4 = undefined;\n\ntry {\n  var _loop2 = function _loop2() {\n    var method = _step4.value;\n\n    Stack.prototype[method] = function (state, editor) {\n      debug(method);\n\n      for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        args[_key3 - 2] = arguments[_key3];\n      }\n\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = this.plugins[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var plugin = _step7.value;\n\n          if (!plugin[method]) continue;\n          var next = plugin[method].apply(plugin, args.concat([state, editor]));\n          if (next == null) continue;\n          assertState(next);\n          state = next;\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      return state;\n    };\n  };\n\n  for (var _iterator4 = STATE_ACCUMULATOR_METHODS[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n    _loop2();\n  }\n\n  /**\n   * Assert that a `value` is a state object.\n   *\n   * @param {Mixed} value\n   */\n} catch (err) {\n  _didIteratorError4 = true;\n  _iteratorError4 = err;\n} finally {\n  try {\n    if (!_iteratorNormalCompletion4 && _iterator4.return) {\n      _iterator4.return();\n    }\n  } finally {\n    if (_didIteratorError4) {\n      throw _iteratorError4;\n    }\n  }\n}\n\nfunction assertState(value) {\n  if (value instanceof _state2.default) return;\n  throw new Error('A plugin returned an unexpected state value: ' + value);\n}\n\n/**\n * Resolve a schema from a set of `plugins`.\n *\n * @param {Array} plugins\n * @return {Schema}\n */\n\nfunction resolveSchema(plugins) {\n  var rules = [];\n\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = plugins[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var plugin = _step5.value;\n\n      if (plugin.schema == null) continue;\n      var _schema = _schema3.default.create(plugin.schema);\n      rules = rules.concat(_schema.rules);\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n\n  var schema = _schema3.default.create({ rules: rules });\n  return schema;\n}\n\n/**\n * Resolve an array of plugins from `properties`.\n *\n * In addition to the plugins provided in `properties.plugins`, this will\n * create two other plugins:\n *\n * - A plugin made from the top-level `properties` themselves, which are\n * placed at the beginning of the stack. That way, you can add a `onKeyDown`\n * handler, and it will override all of the existing plugins.\n *\n * - A \"core\" functionality plugin that handles the most basic events in Slate,\n * like deleting characters, splitting blocks, etc.\n *\n * @param {Object} props\n * @return {Array}\n */\n\nfunction resolvePlugins(props) {\n  var _props$plugins = props.plugins,\n      plugins = _props$plugins === undefined ? [] : _props$plugins,\n      overridePlugin = _objectWithoutProperties(props, ['plugins']);\n\n  var corePlugin = (0, _core2.default)(props);\n  return [overridePlugin].concat(_toConsumableArray(plugins), [corePlugin]);\n}\n\n/**\n * Export.\n *\n * @type {Stack}\n */\n\nexports.default = Stack;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/plugins/core.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _base = require('../serializers/base-64');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _content = require('../components/content');\n\nvar _content2 = _interopRequireDefault(_content);\n\nvar _character = require('../models/character');\n\nvar _character2 = _interopRequireDefault(_character);\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _getPoint = require('../utils/get-point');\n\nvar _getPoint2 = _interopRequireDefault(_getPoint);\n\nvar _placeholder = require('../components/placeholder');\n\nvar _placeholder2 = _interopRequireDefault(_placeholder);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _getWindow = require('get-window');\n\nvar _getWindow2 = _interopRequireDefault(_getWindow);\n\nvar _environment = require('../constants/environment');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = (0, _debug2.default)('slate:core');\n\n/**\n * The default plugin.\n *\n * @param {Object} options\n *   @property {Element} placeholder\n *   @property {String} placeholderClassName\n *   @property {Object} placeholderStyle\n * @return {Object}\n */\n\nfunction Plugin() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var placeholder = options.placeholder,\n      placeholderClassName = options.placeholderClassName,\n      placeholderStyle = options.placeholderStyle;\n\n  /**\n   * On before change, enforce the editor's schema.\n   *\n   * @param {State} state\n   * @param {Editor} schema\n   * @return {State}\n   */\n\n  function onBeforeChange(state, editor) {\n    // Don't normalize with plugins schema when typing text in native mode\n    if (state.isNative) return state;\n\n    var schema = editor.getSchema();\n    var prevState = editor.getState();\n\n    // Since schema can only normalize the document, we avoid creating\n    // a transform and normalize the selection if the document is the same\n    if (prevState && state.document == prevState.document) return state;\n\n    var newState = state.transform().normalize(schema).apply({ save: false });\n\n    debug('onBeforeChange');\n    return newState;\n  }\n\n  /**\n   * On before input, see if we can let the browser continue with it's native\n   * input behavior, to avoid a re-render for performance.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @param {Editor} editor\n   * @return {State}\n   */\n\n  function onBeforeInput(e, data, state, editor) {\n    var document = state.document,\n        startKey = state.startKey,\n        startBlock = state.startBlock,\n        startOffset = state.startOffset,\n        startInline = state.startInline,\n        startText = state.startText;\n\n    var pText = startBlock.getPreviousText(startKey);\n    var pInline = pText && startBlock.getClosestInline(pText.key);\n    var nText = startBlock.getNextText(startKey);\n    var nInline = nText && startBlock.getClosestInline(nText.key);\n\n    // Determine what the characters would be if natively inserted.\n    var schema = editor.getSchema();\n    var decorators = document.getDescendantDecorators(startKey, schema);\n    var initialChars = startText.getDecorations(decorators);\n    var prevChar = startOffset === 0 ? null : initialChars.get(startOffset - 1);\n    var nextChar = startOffset === initialChars.size ? null : initialChars.get(startOffset);\n    var char = _character2.default.create({\n      text: e.data,\n      // When cursor is at start of a range of marks, without preceding text,\n      // the native behavior is to insert inside the range of marks.\n      marks: prevChar && prevChar.marks || nextChar && nextChar.marks || []\n    });\n\n    var chars = initialChars.insert(startOffset, char);\n\n    var transform = state.transform();\n\n    // COMPAT: In iOS, when choosing from the predictive text suggestions, the\n    // native selection will be changed to span the existing word, so that the word\n    // is replaced. But the `select` event for this change doesn't fire until after\n    // the `beforeInput` event, even though the native selection is updated. So we\n    // need to manually adjust the selection to be in sync. (03/18/2017)\n    var window = (0, _getWindow2.default)(e.target);\n    var native = window.getSelection();\n    var anchorNode = native.anchorNode,\n        anchorOffset = native.anchorOffset,\n        focusNode = native.focusNode,\n        focusOffset = native.focusOffset;\n\n    var anchorPoint = (0, _getPoint2.default)(anchorNode, anchorOffset, state, editor);\n    var focusPoint = (0, _getPoint2.default)(focusNode, focusOffset, state, editor);\n    if (anchorPoint && focusPoint) {\n      var selection = state.selection;\n\n      if (selection.anchorKey !== anchorPoint.key || selection.anchorOffset !== anchorPoint.offset || selection.focusKey !== focusPoint.key || selection.focusOffset !== focusPoint.offset) {\n        transform = transform.select({\n          anchorKey: anchorPoint.key,\n          anchorOffset: anchorPoint.offset,\n          focusKey: focusPoint.key,\n          focusOffset: focusPoint.offset\n        });\n      }\n    }\n\n    // Determine what the characters should be, if not natively inserted.\n    var next = transform.insertText(e.data).apply();\n\n    var nextText = next.startText;\n    var nextChars = nextText.getDecorations(decorators);\n\n    // We do not have to re-render if the current selection is collapsed, the\n    // current node is not empty, there are no marks on the cursor, the cursor\n    // is not at the edge of an inline node, the cursor isn't at the starting\n    // edge of a text node after an inline node, and the natively inserted\n    // characters would be the same as the non-native.\n    var isNative =\n    // If the selection is expanded, we don't know what the edit will look\n    // like so we can't let it happen natively.\n    state.isCollapsed &&\n    // If the selection has marks, then we need to render it non-natively\n    // because we need to create the new marks as well.\n    state.selection.marks == null &&\n    // If the text node in question has no content, browsers might do weird\n    // things so we need to insert it normally instead.\n    state.startText.text != '' && (\n    // COMPAT: Browsers do weird things when typing at the edges of inline\n    // nodes, so we can't let them render natively. (?)\n    !startInline || !state.selection.isAtStartOf(startInline)) && (!startInline || !state.selection.isAtEndOf(startInline)) &&\n    // COMPAT: In Chrome & Safari, it isn't possible to have a selection at\n    // the starting edge of a text node after another inline node. It will\n    // have been automatically changed. So we can't render natively because\n    // the cursor isn't technique in the right spot. (2016/12/01)\n    !(pInline && !pInline.isVoid && startOffset == 0) && !(nInline && !nInline.isVoid && startOffset == startText.length) &&\n    // If the\n    chars.equals(nextChars);\n\n    // Add the `isNative` flag directly, so we don't have to re-transform.\n    if (isNative) {\n      next = next.set('isNative', isNative);\n    }\n\n    // If not native, prevent default so that the DOM remains untouched.\n    if (!isNative) e.preventDefault();\n\n    debug('onBeforeInput', { data: data, isNative: isNative });\n    return next;\n  }\n\n  /**\n   * On blur.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onBlur(e, data, state) {\n    debug('onBlur', { data: data });\n    return state.transform().blur().apply();\n  }\n\n  /**\n   * On copy.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onCopy(e, data, state) {\n    debug('onCopy', data);\n    onCutOrCopy(e, data, state);\n  }\n\n  /**\n   * On cut.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @param {Editor} editor\n   * @return {State}\n   */\n\n  function onCut(e, data, state, editor) {\n    debug('onCut', data);\n    onCutOrCopy(e, data, state);\n    var window = (0, _getWindow2.default)(e.target);\n\n    // Once the fake cut content has successfully been added to the clipboard,\n    // delete the content in the current selection.\n    window.requestAnimationFrame(function () {\n      var next = editor.getState().transform().delete().apply();\n\n      editor.onChange(next);\n    });\n  }\n\n  /**\n   * On cut or copy, create a fake selection so that we can add a Base 64\n   * encoded copy of the fragment to the HTML, to decode on future pastes.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onCutOrCopy(e, data, state) {\n    var window = (0, _getWindow2.default)(e.target);\n    var native = window.getSelection();\n    if (native.isCollapsed) return;\n\n    var fragment = data.fragment;\n\n    var encoded = _base2.default.serializeNode(fragment);\n    var range = native.getRangeAt(0);\n    var contents = range.cloneContents();\n\n    // Remove any zero-width space spans from the cloned DOM so that they don't\n    // show up elsewhere when copied.\n    var zws = [].slice.call(contents.querySelectorAll('[data-slate-zero-width]'));\n    zws.forEach(function (zw) {\n      return zw.parentNode.removeChild(zw);\n    });\n\n    // Wrap the first character of the selection in a span that has the encoded\n    // fragment attached as an attribute, so it will show up in the copied HTML.\n    var wrapper = window.document.createElement('span');\n    var text = contents.childNodes[0];\n    var char = text.textContent.slice(0, 1);\n    var first = window.document.createTextNode(char);\n    var rest = text.textContent.slice(1);\n    text.textContent = rest;\n    wrapper.appendChild(first);\n    wrapper.setAttribute('data-slate-fragment', encoded);\n    contents.insertBefore(wrapper, text);\n\n    // Add the phony content to the DOM, and select it, so it will be copied.\n    var body = window.document.querySelector('body');\n    var div = window.document.createElement('div');\n    div.setAttribute('contenteditable', true);\n    div.style.position = 'absolute';\n    div.style.left = '-9999px';\n    div.appendChild(contents);\n    body.appendChild(div);\n\n    // COMPAT: In Firefox, trying to use the terser `native.selectAllChildren`\n    // throws an error, so we use the older `range` equivalent. (2016/06/21)\n    var r = window.document.createRange();\n    r.selectNodeContents(div);\n    native.removeAllRanges();\n    native.addRange(r);\n\n    // Revert to the previous selection right after copying.\n    window.requestAnimationFrame(function () {\n      body.removeChild(div);\n      native.removeAllRanges();\n      native.addRange(range);\n    });\n  }\n\n  /**\n   * On drop.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onDrop(e, data, state) {\n    debug('onDrop', { data: data });\n\n    switch (data.type) {\n      case 'text':\n      case 'html':\n        return onDropText(e, data, state);\n      case 'fragment':\n        return onDropFragment(e, data, state);\n    }\n  }\n\n  /**\n   * On drop fragment.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onDropFragment(e, data, state) {\n    debug('onDropFragment', { data: data });\n\n    var selection = state.selection;\n    var fragment = data.fragment,\n        target = data.target,\n        isInternal = data.isInternal;\n\n    // If the drag is internal and the target is after the selection, it\n    // needs to account for the selection's content being deleted.\n\n    if (isInternal && selection.endKey == target.endKey && selection.endOffset < target.endOffset) {\n      target = target.move(selection.startKey == selection.endKey ? 0 - selection.endOffset - selection.startOffset : 0 - selection.endOffset);\n    }\n\n    var transform = state.transform();\n\n    if (isInternal) transform.delete();\n\n    return transform.select(target).insertFragment(fragment).apply();\n  }\n\n  /**\n   * On drop text, split the blocks at new lines.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onDropText(e, data, state) {\n    debug('onDropText', { data: data });\n\n    var text = data.text,\n        target = data.target;\n\n    var transform = state.transform().select(target);\n\n    text.split('\\n').forEach(function (line, i) {\n      if (i > 0) transform.splitBlock();\n      transform.insertText(line);\n    });\n\n    return transform.apply();\n  }\n\n  /**\n   * On key down.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDown(e, data, state) {\n    debug('onKeyDown', { data: data });\n\n    switch (data.key) {\n      case 'enter':\n        return onKeyDownEnter(e, data, state);\n      case 'backspace':\n        return onKeyDownBackspace(e, data, state);\n      case 'delete':\n        return onKeyDownDelete(e, data, state);\n      case 'left':\n        return onKeyDownLeft(e, data, state);\n      case 'right':\n        return onKeyDownRight(e, data, state);\n      case 'up':\n        return onKeyDownUp(e, data, state);\n      case 'down':\n        return onKeyDownDown(e, data, state);\n      case 'd':\n        return onKeyDownD(e, data, state);\n      case 'h':\n        return onKeyDownH(e, data, state);\n      case 'k':\n        return onKeyDownK(e, data, state);\n      case 'y':\n        return onKeyDownY(e, data, state);\n      case 'z':\n        return onKeyDownZ(e, data, state);\n    }\n  }\n\n  /**\n   * On `enter` key down, split the current block in half.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownEnter(e, data, state) {\n    var document = state.document,\n        startKey = state.startKey;\n\n    var hasVoidParent = document.hasVoidParent(startKey);\n\n    // For void nodes, we don't want to split. Instead we just move to the start\n    // of the next text node if one exists.\n    if (hasVoidParent) {\n      var text = document.getNextText(startKey);\n      if (!text) return;\n      return state.transform().collapseToStartOf(text).apply();\n    }\n\n    return state.transform().splitBlock().apply();\n  }\n\n  /**\n   * On `backspace` key down, delete backwards.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownBackspace(e, data, state) {\n    var boundary = 'Char';\n    if (data.isWord) boundary = 'Word';\n    if (data.isLine) boundary = 'Line';\n\n    return state.transform()['delete' + boundary + 'Backward']().apply();\n  }\n\n  /**\n   * On `delete` key down, delete forwards.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownDelete(e, data, state) {\n    var boundary = 'Char';\n    if (data.isWord) boundary = 'Word';\n    if (data.isLine) boundary = 'Line';\n\n    return state.transform()['delete' + boundary + 'Forward']().apply();\n  }\n\n  /**\n   * On `left` key down, move backward.\n   *\n   * COMPAT: This is required to make navigating with the left arrow work when\n   * a void node is selected.\n   *\n   * COMPAT: This is also required to solve for the case where an inline node is\n   * surrounded by empty text nodes with zero-width spaces in them. Without this\n   * the zero-width spaces will cause two arrow keys to jump to the next text.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownLeft(e, data, state) {\n    if (data.isCtrl) return;\n    if (data.isAlt) return;\n    if (state.isExpanded) return;\n\n    var document = state.document,\n        startKey = state.startKey,\n        startText = state.startText;\n\n    var hasVoidParent = document.hasVoidParent(startKey);\n\n    // If the current text node is empty, or we're inside a void parent, we're\n    // going to need to handle the selection behavior.\n    if (startText.text == '' || hasVoidParent) {\n      e.preventDefault();\n      var previous = document.getPreviousText(startKey);\n\n      // If there's no previous text node in the document, abort.\n      if (!previous) return;\n\n      // If the previous text is in the current block, and inside a non-void\n      // inline node, move one character into the inline node.\n      var startBlock = state.startBlock;\n\n      var previousBlock = document.getClosestBlock(previous.key);\n      var previousInline = document.getClosestInline(previous.key);\n\n      if (previousBlock === startBlock && previousInline && !previousInline.isVoid) {\n        var extendOrMove = data.isShift ? 'extend' : 'move';\n        return state.transform().collapseToEndOf(previous)[extendOrMove](-1).apply();\n      }\n\n      // Otherwise, move to the end of the previous node.\n      return state.transform().collapseToEndOf(previous).apply();\n    }\n  }\n\n  /**\n   * On `right` key down, move forward.\n   *\n   * COMPAT: This is required to make navigating with the right arrow work when\n   * a void node is selected.\n   *\n   * COMPAT: This is also required to solve for the case where an inline node is\n   * surrounded by empty text nodes with zero-width spaces in them. Without this\n   * the zero-width spaces will cause two arrow keys to jump to the next text.\n   *\n   * COMPAT: In Chrome & Safari, selections that are at the zero offset of\n   * an inline node will be automatically replaced to be at the last offset\n   * of a previous inline node, which screws us up, so we never want to set the\n   * selection to the very start of an inline node here. (2016/11/29)\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownRight(e, data, state) {\n    if (data.isCtrl) return;\n    if (data.isAlt) return;\n    if (state.isExpanded) return;\n\n    var document = state.document,\n        startKey = state.startKey,\n        startText = state.startText;\n\n    var hasVoidParent = document.hasVoidParent(startKey);\n\n    // If the current text node is empty, or we're inside a void parent, we're\n    // going to need to handle the selection behavior.\n    if (startText.text == '' || hasVoidParent) {\n      e.preventDefault();\n      var next = document.getNextText(startKey);\n\n      // If there's no next text node in the document, abort.\n      if (!next) return state;\n\n      // If the next text is inside a void node, move to the end of it.\n      var isInVoid = document.hasVoidParent(next.key);\n\n      if (isInVoid) {\n        return state.transform().collapseToEndOf(next).apply();\n      }\n\n      // If the next text is in the current block, and inside an inline node,\n      // move one character into the inline node.\n      var startBlock = state.startBlock;\n\n      var nextBlock = document.getClosestBlock(next.key);\n      var nextInline = document.getClosestInline(next.key);\n\n      if (nextBlock == startBlock && nextInline) {\n        var extendOrMove = data.isShift ? 'extend' : 'move';\n        return state.transform().collapseToStartOf(next)[extendOrMove](1).apply();\n      }\n\n      // Otherwise, move to the start of the next text node.\n      return state.transform().collapseToStartOf(next).apply();\n    }\n  }\n\n  /**\n   * On `up` key down, for Macs, move the selection to start of the block.\n   *\n   * COMPAT: Certain browsers don't handle the selection updates properly. In\n   * Chrome, option-shift-up doesn't properly extend the selection. And in\n   * Firefox, option-up doesn't properly move the selection.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownUp(e, data, state) {\n    if (!_environment.IS_MAC || data.isCtrl || !data.isAlt) return;\n\n    var transform = data.isShift ? 'extendToStartOf' : 'collapseToStartOf';\n    var selection = state.selection,\n        document = state.document,\n        focusKey = state.focusKey,\n        focusBlock = state.focusBlock;\n\n    var block = selection.hasFocusAtStartOf(focusBlock) ? document.getPreviousBlock(focusKey) : focusBlock;\n\n    if (!block) return;\n    var text = block.getFirstText();\n\n    e.preventDefault();\n    return state.transform()[transform](text).apply();\n  }\n\n  /**\n   * On `down` key down, for Macs, move the selection to end of the block.\n   *\n   * COMPAT: Certain browsers don't handle the selection updates properly. In\n   * Chrome, option-shift-down doesn't properly extend the selection. And in\n   * Firefox, option-down doesn't properly move the selection.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownDown(e, data, state) {\n    if (!_environment.IS_MAC || data.isCtrl || !data.isAlt) return;\n\n    var transform = data.isShift ? 'extendToEndOf' : 'collapseToEndOf';\n    var selection = state.selection,\n        document = state.document,\n        focusKey = state.focusKey,\n        focusBlock = state.focusBlock;\n\n    var block = selection.hasFocusAtEndOf(focusBlock) ? document.getNextBlock(focusKey) : focusBlock;\n\n    if (!block) return;\n    var text = block.getLastText();\n\n    e.preventDefault();\n    return state.transform()[transform](text).apply();\n  }\n\n  /**\n   * On `d` key down, for Macs, delete one character forward.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownD(e, data, state) {\n    if (!_environment.IS_MAC || !data.isCtrl) return;\n    e.preventDefault();\n    return state.transform().deleteCharForward().apply();\n  }\n\n  /**\n   * On `h` key down, for Macs, delete until the end of the line.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownH(e, data, state) {\n    if (!_environment.IS_MAC || !data.isCtrl) return;\n    e.preventDefault();\n    return state.transform().deleteCharBackward().apply();\n  }\n\n  /**\n   * On `k` key down, for Macs, delete until the end of the line.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownK(e, data, state) {\n    if (!_environment.IS_MAC || !data.isCtrl) return;\n    e.preventDefault();\n    return state.transform().deleteLineForward().apply();\n  }\n\n  /**\n   * On `y` key down, redo.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownY(e, data, state) {\n    if (!data.isMod) return;\n\n    return state.transform().redo().apply({ save: false });\n  }\n\n  /**\n   * On `z` key down, undo or redo.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onKeyDownZ(e, data, state) {\n    if (!data.isMod) return;\n\n    return state.transform()[data.isShift ? 'redo' : 'undo']().apply({ save: false });\n  }\n\n  /**\n   * On paste.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onPaste(e, data, state) {\n    debug('onPaste', { data: data });\n\n    switch (data.type) {\n      case 'fragment':\n        return onPasteFragment(e, data, state);\n      case 'text':\n      case 'html':\n        return onPasteText(e, data, state);\n    }\n  }\n\n  /**\n   * On paste fragment.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onPasteFragment(e, data, state) {\n    debug('onPasteFragment', { data: data });\n\n    return state.transform().insertFragment(data.fragment).apply();\n  }\n\n  /**\n   * On paste text, split blocks at new lines.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onPasteText(e, data, state) {\n    debug('onPasteText', { data: data });\n\n    var transform = state.transform();\n\n    data.text.split('\\n').forEach(function (line, i) {\n      if (i > 0) transform.splitBlock();\n      transform.insertText(line);\n    });\n\n    return transform.apply();\n  }\n\n  /**\n   * On select.\n   *\n   * @param {Event} e\n   * @param {Object} data\n   * @param {State} state\n   * @return {State}\n   */\n\n  function onSelect(e, data, state) {\n    debug('onSelect', { data: data });\n\n    return state.transform().select(data.selection).apply();\n  }\n\n  /**\n   * Render.\n   *\n   * @param {Object} props\n   * @param {State} state\n   * @param {Editor} editor\n   * @return {Object}\n   */\n\n  function render(props, state, editor) {\n    return _react2.default.createElement(_content2.default, {\n      autoCorrect: props.autoCorrect,\n      autoFocus: props.autoFocus,\n      className: props.className,\n      children: props.children,\n      editor: editor,\n      onBeforeInput: editor.onBeforeInput,\n      onBlur: editor.onBlur,\n      onFocus: editor.onFocus,\n      onChange: editor.onChange,\n      onCopy: editor.onCopy,\n      onCut: editor.onCut,\n      onDrop: editor.onDrop,\n      onKeyDown: editor.onKeyDown,\n      onPaste: editor.onPaste,\n      onSelect: editor.onSelect,\n      readOnly: props.readOnly,\n      role: props.role,\n      schema: editor.getSchema(),\n      spellCheck: props.spellCheck,\n      state: state,\n      style: props.style,\n      tabIndex: props.tabIndex\n    });\n  }\n\n  /**\n   * A default schema rule to render block nodes.\n   *\n   * @type {Object}\n   */\n\n  var BLOCK_RENDER_RULE = {\n    match: function match(node) {\n      return node.kind == 'block';\n    },\n    render: function render(props) {\n      return _react2.default.createElement(\n        'div',\n        _extends({}, props.attributes, { style: { position: 'relative' } }),\n        props.children,\n        placeholder ? _react2.default.createElement(\n          _placeholder2.default,\n          {\n            className: placeholderClassName,\n            node: props.node,\n            parent: props.state.document,\n            state: props.state,\n            style: placeholderStyle\n          },\n          placeholder\n        ) : null\n      );\n    }\n  };\n\n  /**\n   * A default schema rule to render inline nodes.\n   *\n   * @type {Object}\n   */\n\n  var INLINE_RENDER_RULE = {\n    match: function match(node) {\n      return node.kind == 'inline';\n    },\n    render: function render(props) {\n      return _react2.default.createElement(\n        'span',\n        _extends({}, props.attributes, { style: { position: 'relative' } }),\n        props.children\n      );\n    }\n  };\n\n  /**\n   * Add default rendering rules to the schema.\n   *\n   * @type {Object}\n   */\n\n  var schema = {\n    rules: [BLOCK_RENDER_RULE, INLINE_RENDER_RULE]\n  };\n\n  /**\n   * Return the core plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onBeforeChange: onBeforeChange,\n    onBeforeInput: onBeforeInput,\n    onBlur: onBlur,\n    onCopy: onCopy,\n    onCut: onCut,\n    onDrop: onDrop,\n    onKeyDown: onKeyDown,\n    onPaste: onPaste,\n    onSelect: onSelect,\n    render: render,\n    schema: schema\n  };\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Plugin;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/serializers/base-64.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _raw = require('./raw');\n\nvar _raw2 = _interopRequireDefault(_raw);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Encode a JSON `object` as base-64 `string`.\n *\n * @param {Object} object\n * @return {String}\n */\n\nfunction encode(object) {\n  var string = JSON.stringify(object);\n  var encoded = window.btoa(window.encodeURIComponent(string));\n  return encoded;\n}\n\n/**\n * Decode a base-64 `string` to a JSON `object`.\n *\n * @param {String} string\n * @return {Object}\n */\n\nfunction decode(string) {\n  var decoded = window.decodeURIComponent(window.atob(string));\n  var object = JSON.parse(decoded);\n  return object;\n}\n\n/**\n * Deserialize a State `string`.\n *\n * @param {String} string\n * @return {State}\n */\n\nfunction deserialize(string, options) {\n  var raw = decode(string);\n  var state = _raw2.default.deserialize(raw, options);\n  return state;\n}\n\n/**\n * Deserialize a Node `string`.\n *\n * @param {String} string\n * @return {Node}\n */\n\nfunction deserializeNode(string, options) {\n  var raw = decode(string);\n  var node = _raw2.default.deserializeNode(raw, options);\n  return node;\n}\n\n/**\n * Serialize a `state`.\n *\n * @param {State} state\n * @return {String}\n */\n\nfunction serialize(state, options) {\n  var raw = _raw2.default.serialize(state, options);\n  var encoded = encode(raw);\n  return encoded;\n}\n\n/**\n * Serialize a `node`.\n *\n * @param {Node} node\n * @return {String}\n */\n\nfunction serializeNode(node, options) {\n  var raw = _raw2.default.serializeNode(node, options);\n  var encoded = encode(raw);\n  return encoded;\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = {\n  deserialize: deserialize,\n  deserializeNode: deserializeNode,\n  serialize: serialize,\n  serializeNode: serializeNode\n};","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/serializers/raw.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _block = require('../models/block');\n\nvar _block2 = _interopRequireDefault(_block);\n\nvar _character = require('../models/character');\n\nvar _character2 = _interopRequireDefault(_character);\n\nvar _document = require('../models/document');\n\nvar _document2 = _interopRequireDefault(_document);\n\nvar _inline = require('../models/inline');\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nvar _mark = require('../models/mark');\n\nvar _mark2 = _interopRequireDefault(_mark);\n\nvar _selection = require('../models/selection');\n\nvar _selection2 = _interopRequireDefault(_selection);\n\nvar _state = require('../models/state');\n\nvar _state2 = _interopRequireDefault(_state);\n\nvar _text = require('../models/text');\n\nvar _text2 = _interopRequireDefault(_text);\n\nvar _isEmpty = require('is-empty');\n\nvar _isEmpty2 = _interopRequireDefault(_isEmpty);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Raw.\n *\n * @type {Object}\n */\n\nvar Raw = {\n\n  /**\n   * Deserialize a JSON `object`.\n   *\n   * @param {Object} object\n   * @param {Object} options (optional)\n   * @return {Block}\n   */\n\n  deserialize: function deserialize(object, options) {\n    return Raw.deserializeState(object, options);\n  },\n\n\n  /**\n   * Deserialize a JSON `object` representing a `Block`.\n   *\n   * @param {Object} object\n   * @param {Object} options (optional)\n   * @return {Block}\n   */\n\n  deserializeBlock: function deserializeBlock(object) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.terse) object = Raw.untersifyBlock(object);\n\n    return _block2.default.create({\n      key: object.key,\n      type: object.type,\n      data: object.data,\n      isVoid: object.isVoid,\n      nodes: _block2.default.createList(object.nodes.map(function (node) {\n        return Raw.deserializeNode(node, options);\n      }))\n    });\n  },\n\n\n  /**\n   * Deserialize a JSON `object` representing a `Document`.\n   *\n   * @param {Object} object\n   * @param {Object} options (optional)\n   * @return {Document}\n   */\n\n  deserializeDocument: function deserializeDocument(object, options) {\n    return _document2.default.create({\n      key: object.key,\n      data: object.data,\n      nodes: _block2.default.createList(object.nodes.map(function (node) {\n        return Raw.deserializeNode(node, options);\n      }))\n    });\n  },\n\n\n  /**\n   * Deserialize a JSON `object` representing an `Inline`.\n   *\n   * @param {Object} object\n   * @param {Object} options (optional)\n   * @return {Inline}\n   */\n\n  deserializeInline: function deserializeInline(object) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.terse) object = Raw.untersifyInline(object);\n\n    return _inline2.default.create({\n      key: object.key,\n      type: object.type,\n      data: object.data,\n      isVoid: object.isVoid,\n      nodes: _inline2.default.createList(object.nodes.map(function (node) {\n        return Raw.deserializeNode(node, options);\n      }))\n    });\n  },\n\n\n  /**\n   * Deserialize a JSON `object` representing a `Mark`.\n   *\n   * @param {Object} object\n   * @param {Object} options (optional)\n   * @return {Mark}\n   */\n\n  deserializeMark: function deserializeMark(object, options) {\n    return _mark2.default.create(object);\n  },\n\n\n  /**\n   * Deserialize a JSON object representing a `Node`.\n   *\n   * @param {Object} object\n   * @param {Object} options (optional)\n   * @return {Node}\n   */\n\n  deserializeNode: function deserializeNode(object, options) {\n    switch (object.kind) {\n      case 'block':\n        return Raw.deserializeBlock(object, options);\n      case 'document':\n        return Raw.deserializeDocument(object, options);\n      case 'inline':\n        return Raw.deserializeInline(object, options);\n      case 'text':\n        return Raw.deserializeText(object, options);\n      default:\n        {\n          throw new Error('Unrecognized node kind \"' + object.kind + '\".');\n        }\n    }\n  },\n\n\n  /**\n   * Deserialize a JSON `object` representing a `Range`.\n   *\n   * @param {Object} object\n   * @param {Object} options (optional)\n   * @return {List<Character>}\n   */\n\n  deserializeRange: function deserializeRange(object) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.terse) object = Raw.untersifyRange(object);\n\n    var marks = _mark2.default.createSet(object.marks.map(function (mark) {\n      return Raw.deserializeMark(mark, options);\n    }));\n\n    return _character2.default.createList(object.text.split('').map(function (char) {\n      return _character2.default.create({\n        text: char,\n        marks: marks\n      });\n    }));\n  },\n\n\n  /**\n   * Deserialize a JSON `object` representing a `Selection`.\n   *\n   * @param {Object} object\n   * @param {Object} options (optional)\n   * @return {State}\n   */\n\n  deserializeSelection: function deserializeSelection(object) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    return _selection2.default.create({\n      anchorKey: object.anchorKey,\n      anchorOffset: object.anchorOffset,\n      focusKey: object.focusKey,\n      focusOffset: object.focusOffset,\n      isFocused: object.isFocused\n    });\n  },\n\n\n  /**\n   * Deserialize a JSON `object` representing a `State`.\n   *\n   * @param {Object} object\n   * @param {Object} options (optional)\n   * @return {State}\n   */\n\n  deserializeState: function deserializeState(object) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.terse) object = Raw.untersifyState(object);\n\n    var document = Raw.deserializeDocument(object.document, options);\n    var selection = void 0;\n\n    if (object.selection != null) {\n      selection = Raw.deserializeSelection(object.selection, options);\n    }\n\n    return _state2.default.create({ document: document, selection: selection }, options);\n  },\n\n\n  /**\n   * Deserialize a JSON `object` representing a `Text`.\n   *\n   * @param {Object} object\n   * @param {Object} options (optional)\n   * @return {Text}\n   */\n\n  deserializeText: function deserializeText(object) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.terse) object = Raw.untersifyText(object);\n\n    return _text2.default.create({\n      key: object.key,\n      characters: object.ranges.reduce(function (characters, range) {\n        return characters.concat(Raw.deserializeRange(range, options));\n      }, _character2.default.createList())\n    });\n  },\n\n\n  /**\n   * Serialize a `model`.\n   *\n   * @param {Mixed} model\n   * @param {Object} options (optional)\n   * @return {Object}\n   */\n\n  serialize: function serialize(model, options) {\n    return Raw.serializeState(model, options);\n  },\n\n\n  /**\n   * Serialize a `block` node.\n   *\n   * @param {Block} block\n   * @param {Object} options (optional)\n   * @return {Object}\n   */\n\n  serializeBlock: function serializeBlock(block) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var object = {\n      data: block.data.toJSON(),\n      key: block.key,\n      kind: block.kind,\n      isVoid: block.isVoid,\n      type: block.type,\n      nodes: block.nodes.toArray().map(function (node) {\n        return Raw.serializeNode(node, options);\n      })\n    };\n\n    if (!options.preserveKeys) {\n      delete object.key;\n    }\n\n    return options.terse ? Raw.tersifyBlock(object) : object;\n  },\n\n\n  /**\n   * Serialize a `document`.\n   *\n   * @param {Document} document\n   * @param {Object} options (optional)\n   * @return {Object}\n   */\n\n  serializeDocument: function serializeDocument(document) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var object = {\n      data: document.data.toJSON(),\n      key: document.key,\n      kind: document.kind,\n      nodes: document.nodes.toArray().map(function (node) {\n        return Raw.serializeNode(node, options);\n      })\n    };\n\n    if (!options.preserveKeys) {\n      delete object.key;\n    }\n\n    return options.terse ? Raw.tersifyDocument(object) : object;\n  },\n\n\n  /**\n   * Serialize an `inline` node.\n   *\n   * @param {Inline} inline\n   * @param {Object} options (optional)\n   * @return {Object}\n   */\n\n  serializeInline: function serializeInline(inline) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var object = {\n      data: inline.data.toJSON(),\n      key: inline.key,\n      kind: inline.kind,\n      isVoid: inline.isVoid,\n      type: inline.type,\n      nodes: inline.nodes.toArray().map(function (node) {\n        return Raw.serializeNode(node, options);\n      })\n    };\n\n    if (!options.preserveKeys) {\n      delete object.key;\n    }\n\n    return options.terse ? Raw.tersifyInline(object) : object;\n  },\n\n\n  /**\n   * Serialize a `mark`.\n   *\n   * @param {Mark} mark\n   * @param {Object} options (optional)\n   * @return {Object}\n   */\n\n  serializeMark: function serializeMark(mark) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var object = {\n      data: mark.data.toJSON(),\n      kind: mark.kind,\n      type: mark.type\n    };\n\n    return options.terse ? Raw.tersifyMark(object) : object;\n  },\n\n\n  /**\n   * Serialize a `node`.\n   *\n   * @param {Node} node\n   * @param {Object} options (optional)\n   * @return {Object}\n   */\n\n  serializeNode: function serializeNode(node, options) {\n    switch (node.kind) {\n      case 'block':\n        return Raw.serializeBlock(node, options);\n      case 'document':\n        return Raw.serializeDocument(node, options);\n      case 'inline':\n        return Raw.serializeInline(node, options);\n      case 'text':\n        return Raw.serializeText(node, options);\n      default:\n        {\n          throw new Error('Unrecognized node kind \"' + node.kind + '\".');\n        }\n    }\n  },\n\n\n  /**\n   * Serialize a `range`.\n   *\n   * @param {Range} range\n   * @param {Object} options (optional)\n   * @return {Object}\n   */\n\n  serializeRange: function serializeRange(range) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var object = {\n      kind: range.kind,\n      text: range.text,\n      marks: range.marks.toArray().map(function (mark) {\n        return Raw.serializeMark(mark, options);\n      })\n    };\n\n    return options.terse ? Raw.tersifyRange(object) : object;\n  },\n\n\n  /**\n   * Serialize a `selection`.\n   *\n   * @param {Selection} selection\n   * @param {Object} options (optional)\n   * @return {Object}\n   */\n\n  serializeSelection: function serializeSelection(selection) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var object = {\n      kind: selection.kind,\n      anchorKey: selection.anchorKey,\n      anchorOffset: selection.anchorOffset,\n      focusKey: selection.focusKey,\n      focusOffset: selection.focusOffset,\n      isBackward: selection.isBackward,\n      isFocused: selection.isFocused\n    };\n\n    return options.terse ? Raw.tersifySelection(object) : object;\n  },\n\n\n  /**\n   * Serialize a `state`.\n   *\n   * @param {State} state\n   * @param {Object} options (optional)\n   * @return {Object}\n   */\n\n  serializeState: function serializeState(state) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var object = {\n      document: Raw.serializeDocument(state.document, options),\n      selection: Raw.serializeSelection(state.selection, options),\n      kind: state.kind\n    };\n\n    if (!options.preserveSelection) {\n      delete object.selection;\n    }\n\n    var ret = options.terse ? Raw.tersifyState(object) : object;\n\n    return ret;\n  },\n\n\n  /**\n   * Serialize a `text` node.\n   *\n   * @param {Text} text\n   * @param {Object} options (optional)\n   * @return {Object}\n   */\n\n  serializeText: function serializeText(text) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var object = {\n      key: text.key,\n      kind: text.kind,\n      ranges: text.getRanges().toArray().map(function (range) {\n        return Raw.serializeRange(range, options);\n      })\n    };\n\n    if (!options.preserveKeys) {\n      delete object.key;\n    }\n\n    return options.terse ? Raw.tersifyText(object) : object;\n  },\n\n\n  /**\n   * Create a terse representation of a block `object`.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  tersifyBlock: function tersifyBlock(object) {\n    var ret = {};\n    ret.kind = object.kind;\n    ret.type = object.type;\n    if (object.key) ret.key = object.key;\n    if (!object.isVoid) ret.nodes = object.nodes;\n    if (object.isVoid) ret.isVoid = object.isVoid;\n    if (!(0, _isEmpty2.default)(object.data)) ret.data = object.data;\n    return ret;\n  },\n\n\n  /**\n   * Create a terse representation of a document `object.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  tersifyDocument: function tersifyDocument(object) {\n    var ret = {};\n    ret.nodes = object.nodes;\n    if (object.key) ret.key = object.key;\n    if (!(0, _isEmpty2.default)(object.data)) ret.data = object.data;\n    return ret;\n  },\n\n\n  /**\n   * Create a terse representation of a inline `object`.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  tersifyInline: function tersifyInline(object) {\n    var ret = {};\n    ret.kind = object.kind;\n    ret.type = object.type;\n    if (object.key) ret.key = object.key;\n    if (!object.isVoid) ret.nodes = object.nodes;\n    if (object.isVoid) ret.isVoid = object.isVoid;\n    if (!(0, _isEmpty2.default)(object.data)) ret.data = object.data;\n    return ret;\n  },\n\n\n  /**\n   * Create a terse representation of a mark `object`.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  tersifyMark: function tersifyMark(object) {\n    var ret = {};\n    ret.type = object.type;\n    if (!(0, _isEmpty2.default)(object.data)) ret.data = object.data;\n    return ret;\n  },\n\n\n  /**\n   * Create a terse representation of a range `object`.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  tersifyRange: function tersifyRange(object) {\n    var ret = {};\n    ret.text = object.text;\n    if (!(0, _isEmpty2.default)(object.marks)) ret.marks = object.marks;\n    return ret;\n  },\n\n\n  /**\n   * Create a terse representation of a selection `object.`\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  tersifySelection: function tersifySelection(object) {\n    return {\n      anchorKey: object.anchorKey,\n      anchorOffset: object.anchorOffset,\n      focusKey: object.focusKey,\n      focusOffset: object.focusOffset,\n      isFocused: object.isFocused\n    };\n  },\n\n\n  /**\n   * Create a terse representation of a state `object`.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  tersifyState: function tersifyState(object) {\n    if (object.selection == null) {\n      return object.document;\n    }\n\n    return {\n      document: object.document,\n      selection: object.selection\n    };\n  },\n\n\n  /**\n   * Create a terse representation of a text `object`.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  tersifyText: function tersifyText(object) {\n    var ret = {};\n    ret.kind = object.kind;\n    if (object.key) ret.key = object.key;\n\n    if (object.ranges.length == 1 && object.ranges[0].marks == null) {\n      ret.text = object.ranges[0].text;\n    } else {\n      ret.ranges = object.ranges;\n    }\n\n    return ret;\n  },\n\n\n  /**\n   * Convert a terse representation of a block `object` into a non-terse one.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  untersifyBlock: function untersifyBlock(object) {\n    if (object.isVoid || !object.nodes || !object.nodes.length) {\n      return {\n        key: object.key,\n        data: object.data,\n        kind: object.kind,\n        type: object.type,\n        isVoid: object.isVoid,\n        nodes: [{\n          kind: 'text',\n          text: ''\n        }]\n      };\n    }\n\n    return object;\n  },\n\n\n  /**\n   * Convert a terse representation of a inline `object` into a non-terse one.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  untersifyInline: function untersifyInline(object) {\n    if (object.isVoid || !object.nodes || !object.nodes.length) {\n      return {\n        key: object.key,\n        data: object.data,\n        kind: object.kind,\n        type: object.type,\n        isVoid: object.isVoid,\n        nodes: [{\n          kind: 'text',\n          text: ''\n        }]\n      };\n    }\n\n    return object;\n  },\n\n\n  /**\n   * Convert a terse representation of a range `object` into a non-terse one.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  untersifyRange: function untersifyRange(object) {\n    return {\n      kind: 'range',\n      text: object.text,\n      marks: object.marks || []\n    };\n  },\n\n\n  /**\n   * Convert a terse representation of a selection `object` into a non-terse one.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  untersifySelection: function untersifySelection(object) {\n    return {\n      kind: 'selection',\n      anchorKey: object.anchorKey,\n      anchorOffset: object.anchorOffset,\n      focusKey: object.focusKey,\n      focusOffset: object.focusOffset,\n      isBackward: null,\n      isFocused: false\n    };\n  },\n\n\n  /**\n   * Convert a terse representation of a state `object` into a non-terse one.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  untersifyState: function untersifyState(object) {\n    if (object.selection || object.document) {\n      return {\n        kind: 'state',\n        document: object.document,\n        selection: object.selection\n      };\n    }\n\n    return {\n      kind: 'state',\n      document: {\n        data: object.data,\n        key: object.key,\n        kind: 'document',\n        nodes: object.nodes\n      }\n    };\n  },\n\n\n  /**\n   * Convert a terse representation of a text `object` into a non-terse one.\n   *\n   * @param {Object} object\n   * @return {Object}\n   */\n\n  untersifyText: function untersifyText(object) {\n    if (object.ranges) return object;\n\n    return {\n      key: object.key,\n      kind: object.kind,\n      ranges: [{\n        text: object.text,\n        marks: object.marks || []\n      }]\n    };\n  }\n};\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Raw;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/models/block.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nrequire('./document');\n\nvar _inline = require('./inline');\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nvar _data = require('./data');\n\nvar _data2 = _interopRequireDefault(_data);\n\nvar _node = require('./node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _text = require('./text');\n\nvar _text2 = _interopRequireDefault(_text);\n\nvar _generateKey = require('../utils/generate-key');\n\nvar _generateKey2 = _interopRequireDefault(_generateKey);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n/**\n * Prevent circular dependencies.\n */\n\n/**\n * Dependencies.\n */\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  data: new _immutable.Map(),\n  isVoid: false,\n  key: null,\n  nodes: new _immutable.List(),\n  type: null\n};\n\n/**\n * Block.\n *\n * @type {Block}\n */\n\nvar Block = function (_ref) {\n  _inherits(Block, _ref);\n\n  function Block() {\n    _classCallCheck(this, Block);\n\n    return _possibleConstructorReturn(this, (Block.__proto__ || Object.getPrototypeOf(Block)).apply(this, arguments));\n  }\n\n  _createClass(Block, [{\n    key: 'kind',\n\n\n    /**\n     * Get the node's kind.\n     *\n     * @return {String}\n     */\n\n    get: function get() {\n      return 'block';\n    }\n\n    /**\n     * Is the node empty?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get() {\n      return this.text == '';\n    }\n\n    /**\n     * Get the length of the concatenated text of the node.\n     *\n     * @return {Number}\n     */\n\n  }, {\n    key: 'length',\n    get: function get() {\n      return this.text.length;\n    }\n\n    /**\n     * Get the concatenated text `string` of all child nodes.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'text',\n    get: function get() {\n      return this.getText();\n    }\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Create a new `Block` with `properties`.\n     *\n     * @param {Object|Block} properties\n     * @return {Block}\n     */\n\n    value: function create() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (properties instanceof Block) return properties;\n      if (properties instanceof _inline2.default) return properties;\n      if (properties instanceof _text2.default) return properties;\n      if (!properties.type) throw new Error('You must pass a block `type`.');\n\n      properties.key = properties.key || (0, _generateKey2.default)();\n      properties.data = _data2.default.create(properties.data);\n      properties.isVoid = !!properties.isVoid;\n      properties.nodes = Block.createList(properties.nodes);\n\n      if (properties.nodes.size == 0) {\n        properties.nodes = properties.nodes.push(_text2.default.create());\n      }\n\n      return new Block(properties);\n    }\n\n    /**\n     * Create a list of `Blocks` from an array.\n     *\n     * @param {Array<Object|Block>} elements\n     * @return {List<Block>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (_immutable.List.isList(elements)) return elements;\n      return new _immutable.List(elements.map(Block.create));\n    }\n  }]);\n\n  return Block;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Mix in `Node` methods.\n */\n\nfor (var method in _node2.default) {\n  Block.prototype[method] = _node2.default[method];\n}\n\n/**\n * Export.\n *\n * @type {Block}\n */\n\nexports.default = Block;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/models/document.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _block = require('./block');\n\nvar _block2 = _interopRequireDefault(_block);\n\nrequire('./inline');\n\nvar _data = require('./data');\n\nvar _data2 = _interopRequireDefault(_data);\n\nvar _node = require('./node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _generateKey = require('../utils/generate-key');\n\nvar _generateKey2 = _interopRequireDefault(_generateKey);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n/**\n * Prevent circular dependencies.\n */\n\n/**\n * Dependencies.\n */\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  data: new _immutable.Map(),\n  key: null,\n  nodes: new _immutable.List()\n};\n\n/**\n * Document.\n *\n * @type {Document}\n */\n\nvar Document = function (_ref) {\n  _inherits(Document, _ref);\n\n  function Document() {\n    _classCallCheck(this, Document);\n\n    return _possibleConstructorReturn(this, (Document.__proto__ || Object.getPrototypeOf(Document)).apply(this, arguments));\n  }\n\n  _createClass(Document, [{\n    key: 'kind',\n\n\n    /**\n     * Get the node's kind.\n     *\n     * @return {String}\n     */\n\n    get: function get() {\n      return 'document';\n    }\n\n    /**\n     * Is the document empty?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get() {\n      return this.text == '';\n    }\n\n    /**\n     * Get the length of the concatenated text of the document.\n     *\n     * @return {Number}\n     */\n\n  }, {\n    key: 'length',\n    get: function get() {\n      return this.text.length;\n    }\n\n    /**\n     * Get the concatenated text `string` of all child nodes.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'text',\n    get: function get() {\n      return this.getText();\n    }\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Create a new `Document` with `properties`.\n     *\n     * @param {Object|Document} properties\n     * @return {Document}\n     */\n\n    value: function create() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (properties instanceof Document) return properties;\n\n      properties.key = properties.key || (0, _generateKey2.default)();\n      properties.data = _data2.default.create(properties.data);\n      properties.nodes = _block2.default.createList(properties.nodes);\n\n      return new Document(properties);\n    }\n  }]);\n\n  return Document;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Mix in `Node` methods.\n */\n\nfor (var method in _node2.default) {\n  Document.prototype[method] = _node2.default[method];\n}\n\n/**\n * Export.\n *\n * @type {Document}\n */\n\nexports.default = Document;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/models/inline.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _block = require('./block');\n\nvar _block2 = _interopRequireDefault(_block);\n\nrequire('./document');\n\nvar _data = require('./data');\n\nvar _data2 = _interopRequireDefault(_data);\n\nvar _node = require('./node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _text = require('./text');\n\nvar _text2 = _interopRequireDefault(_text);\n\nvar _generateKey = require('../utils/generate-key');\n\nvar _generateKey2 = _interopRequireDefault(_generateKey);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n/**\n * Prevent circular dependencies.\n */\n\n/**\n * Dependencies.\n */\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  data: new _immutable.Map(),\n  isVoid: false,\n  key: null,\n  nodes: new _immutable.List(),\n  type: null\n};\n\n/**\n * Inline.\n *\n * @type {Inline}\n */\n\nvar Inline = function (_ref) {\n  _inherits(Inline, _ref);\n\n  function Inline() {\n    _classCallCheck(this, Inline);\n\n    return _possibleConstructorReturn(this, (Inline.__proto__ || Object.getPrototypeOf(Inline)).apply(this, arguments));\n  }\n\n  _createClass(Inline, [{\n    key: 'kind',\n\n\n    /**\n     * Get the node's kind.\n     *\n     * @return {String}\n     */\n\n    get: function get() {\n      return 'inline';\n    }\n\n    /**\n     * Is the node empty?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get() {\n      return this.text == '';\n    }\n\n    /**\n     * Get the length of the concatenated text of the node.\n     *\n     * @return {Number}\n     */\n\n  }, {\n    key: 'length',\n    get: function get() {\n      return this.text.length;\n    }\n\n    /**\n     * Get the concatenated text `string` of all child nodes.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'text',\n    get: function get() {\n      return this.getText();\n    }\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Create a new `Inline` with `properties`.\n     *\n     * @param {Object|Inline} properties\n     * @return {Inline}\n     */\n\n    value: function create() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (properties instanceof _block2.default) return properties;\n      if (properties instanceof Inline) return properties;\n      if (properties instanceof _text2.default) return properties;\n      if (!properties.type) throw new Error('You must pass an inline `type`.');\n\n      properties.key = properties.key || (0, _generateKey2.default)();\n      properties.data = _data2.default.create(properties.data);\n      properties.isVoid = !!properties.isVoid;\n      properties.nodes = Inline.createList(properties.nodes);\n\n      if (properties.nodes.size == 0) {\n        properties.nodes = properties.nodes.push(_text2.default.create());\n      }\n\n      return new Inline(properties);\n    }\n\n    /**\n     * Create a list of `Inlines` from an array.\n     *\n     * @param {Array<Object|Inline>} elements\n     * @return {List<Inline>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (_immutable.List.isList(elements)) return elements;\n      return new _immutable.List(elements.map(Inline.create));\n    }\n  }]);\n\n  return Inline;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Mix in `Node` methods.\n */\n\nfor (var method in _node2.default) {\n  Inline.prototype[method] = _node2.default[method];\n}\n\n/**\n * Export.\n *\n * @type {Inline}\n */\n\nexports.default = Inline;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/models/data.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _immutable = require('immutable');\n\n/**\n * Data.\n *\n * This isn't an immutable record, it's just a thin wrapper around `Map` so that\n * we can allow for more convenient creation.\n *\n * @type {Object}\n */\n\nvar Data = {\n\n  /**\n   * Create a new `Data` with `properties`.\n   *\n   * @param {Object} properties\n   * @return {Data} data\n   */\n\n  create: function create() {\n    var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    return _immutable.Map.isMap(properties) ? properties : new _immutable.Map(properties);\n  }\n};\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Data;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/models/node.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _document = require('./document');\n\nvar _document2 = _interopRequireDefault(_document);\n\nvar _normalize = require('../utils/normalize');\n\nvar _normalize2 = _interopRequireDefault(_normalize);\n\nvar _direction = require('direction');\n\nvar _direction2 = _interopRequireDefault(_direction);\n\nvar _generateKey = require('../utils/generate-key');\n\nvar _generateKey2 = _interopRequireDefault(_generateKey);\n\nvar _isInRange = require('../utils/is-in-range');\n\nvar _isInRange2 = _interopRequireDefault(_isInRange);\n\nvar _memoize = require('../utils/memoize');\n\nvar _memoize2 = _interopRequireDefault(_memoize);\n\nvar _warn = require('../utils/warn');\n\nvar _warn2 = _interopRequireDefault(_warn);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Node.\n *\n * And interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Object}\n */\n\nvar Node = {\n\n  /**\n   * True if the node has both descendants in that order, false otherwise. The\n   * order is depth-first, post-order.\n   *\n   * @param {String} first\n   * @param {String} second\n   * @return {Boolean}\n   */\n\n  areDescendantsSorted: function areDescendantsSorted(first, second) {\n    first = _normalize2.default.key(first);\n    second = _normalize2.default.key(second);\n\n    var sorted = void 0;\n\n    this.forEachDescendant(function (n) {\n      if (n.key === first) {\n        sorted = true;\n        return false;\n      } else if (n.key === second) {\n        sorted = false;\n        return false;\n      }\n    });\n\n    return sorted;\n  },\n\n\n  /**\n   * Assert that a node has a child by `key` and return it.\n   *\n   * @param {String} key\n   * @return {Node}\n   */\n\n  assertChild: function assertChild(key) {\n    var child = this.getChild(key);\n\n    if (!child) {\n      key = _normalize2.default.key(key);\n      throw new Error('Could not find a child node with key \"' + key + '\".');\n    }\n\n    return child;\n  },\n\n\n  /**\n   * Assert that a node has a descendant by `key` and return it.\n   *\n   * @param {String} key\n   * @return {Node}\n   */\n\n  assertDescendant: function assertDescendant(key) {\n    var descendant = this.getDescendant(key);\n\n    if (!descendant) {\n      key = _normalize2.default.key(key);\n      throw new Error('Could not find a descendant node with key \"' + key + '\".');\n    }\n\n    return descendant;\n  },\n\n\n  /**\n   * Assert that a node's tree has a node by `key` and return it.\n   *\n   * @param {String} key\n   * @return {Node}\n   */\n\n  assertNode: function assertNode(key) {\n    var node = this.getNode(key);\n\n    if (!node) {\n      key = _normalize2.default.key(key);\n      throw new Error('Could not find a node with key \"' + key + '\".');\n    }\n\n    return node;\n  },\n\n\n  /**\n   * Assert that a node exists at `path` and return it.\n   *\n   * @param {Array} path\n   * @return {Node}\n   */\n\n  assertPath: function assertPath(path) {\n    var descendant = this.getDescendantAtPath(path);\n\n    if (!descendant) {\n      throw new Error('Could not find a descendant at path \"' + path + '\".');\n    }\n\n    return descendant;\n  },\n\n\n  /**\n   * Recursively filter all descendant nodes with `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {List<Node>}\n   */\n\n  filterDescendants: function filterDescendants(iterator) {\n    var matches = [];\n\n    this.forEachDescendant(function (node, i, nodes) {\n      if (iterator(node, i, nodes)) matches.push(node);\n    });\n\n    return (0, _immutable.List)(matches);\n  },\n\n\n  /**\n   * Recursively find all descendant nodes by `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  findDescendant: function findDescendant(iterator) {\n    var found = null;\n\n    this.forEachDescendant(function (node, i, nodes) {\n      if (iterator(node, i, nodes)) {\n        found = node;\n        return false;\n      }\n    });\n\n    return found;\n  },\n\n\n  /**\n   * Recursively iterate over all descendant nodes with `iterator`. If the\n   * iterator returns false it will break the loop.\n   *\n   * @param {Function} iterator\n   */\n\n  forEachDescendant: function forEachDescendant(iterator) {\n    var ret = void 0;\n\n    this.nodes.forEach(function (child, i, nodes) {\n      if (iterator(child, i, nodes) === false) {\n        ret = false;\n        return false;\n      }\n\n      if (child.kind != 'text') {\n        ret = child.forEachDescendant(iterator);\n        return ret;\n      }\n    });\n\n    return ret;\n  },\n\n\n  /**\n   * Get the path of ancestors of a descendant node by `key`.\n   *\n   * @param {String|Node} key\n   * @return {List<Node>|Null}\n   */\n\n  getAncestors: function getAncestors(key) {\n    key = _normalize2.default.key(key);\n\n    if (key == this.key) return (0, _immutable.List)();\n    if (this.hasChild(key)) return (0, _immutable.List)([this]);\n\n    var ancestors = void 0;\n    this.nodes.find(function (node) {\n      if (node.kind == 'text') return false;\n      ancestors = node.getAncestors(key);\n      return ancestors;\n    });\n\n    if (ancestors) {\n      return ancestors.unshift(this);\n    } else {\n      return null;\n    }\n  },\n\n\n  /**\n   * Get the leaf block descendants of the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getBlocks: function getBlocks() {\n    var array = this.getBlocksAsArray();\n    return new _immutable.List(array);\n  },\n\n\n  /**\n   * Get the leaf block descendants of the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getBlocksAsArray: function getBlocksAsArray() {\n    return this.nodes.reduce(function (array, child) {\n      if (child.kind != 'block') return array;\n      if (!child.isLeafBlock()) return array.concat(child.getBlocksAsArray());\n      array.push(child);\n      return array;\n    }, []);\n  },\n\n\n  /**\n   * Get the leaf block descendants in a `range`.\n   *\n   * @param {Selection} range\n   * @return {List<Node>}\n   */\n\n  getBlocksAtRange: function getBlocksAtRange(range) {\n    var _this = this;\n\n    return this.getTextsAtRange(range).map(function (text) {\n      return _this.getClosestBlock(text.key);\n    })\n    // Eliminate duplicates by converting to a `Set` first.\n    .toOrderedSet().toList();\n  },\n\n\n  /**\n   * Get all of the leaf blocks that match a `type`.\n   *\n   * @param {String} type\n   * @return {List<Node>}\n   */\n\n  getBlocksByType: function getBlocksByType(type) {\n    return this.nodes.reduce(function (blocks, node) {\n      if (node.kind != 'block') return blocks;\n      if (node.isLeafBlock() && node.type == type) return blocks.push(node);\n      return blocks.concat(node.getBlocksByType(type));\n    }, new _immutable.List());\n  },\n\n\n  /**\n   * Get all of the characters for every text node.\n   *\n   * @return {List<Character>} characters\n   */\n\n  getCharacters: function getCharacters() {\n    return this.nodes.reduce(function (chars, node) {\n      return node.kind == 'text' ? chars.concat(node.characters) : chars.concat(node.getCharacters());\n    }, new _immutable.List());\n  },\n\n\n  /**\n   * Get a list of the characters in a `range`.\n   *\n   * @param {Selection} range\n   * @return {List<Character>} characters\n   */\n\n  getCharactersAtRange: function getCharactersAtRange(range) {\n    return this.getTextsAtRange(range).reduce(function (characters, text) {\n      var chars = text.characters.filter(function (char, i) {\n        return (0, _isInRange2.default)(i, text, range);\n      });\n      return characters.concat(chars);\n    }, new _immutable.List());\n  },\n\n\n  /**\n   * Get a child node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getChild: function getChild(key) {\n    key = _normalize2.default.key(key);\n    return this.nodes.find(function (node) {\n      return node.key == key;\n    });\n  },\n\n\n  /**\n   * Get closest parent of node by `key` that matches `iterator`.\n   *\n   * @param {String} key\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  getClosest: function getClosest(key, iterator) {\n    key = _normalize2.default.key(key);\n    var ancestors = this.getAncestors(key);\n    if (!ancestors) {\n      throw new Error('Could not find a descendant node with key \"' + key + '\".');\n    }\n\n    // Exclude this node itself.\n    return ancestors.rest().findLast(iterator);\n  },\n\n\n  /**\n   * Get the closest block parent of a `node`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getClosestBlock: function getClosestBlock(key) {\n    return this.getClosest(key, function (parent) {\n      return parent.kind == 'block';\n    });\n  },\n\n\n  /**\n   * Get the closest inline parent of a `node`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getClosestInline: function getClosestInline(key) {\n    return this.getClosest(key, function (parent) {\n      return parent.kind == 'inline';\n    });\n  },\n\n\n  /**\n   * Get the closest void parent of a `node`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getClosestVoid: function getClosestVoid(key) {\n    return this.getClosest(key, function (parent) {\n      return parent.isVoid;\n    });\n  },\n\n\n  /**\n   * Get the common ancestor of nodes `one` and `two` by keys.\n   *\n   * @param {String} one\n   * @param {String} two\n   * @return {Node}\n   */\n\n  getCommonAncestor: function getCommonAncestor(one, two) {\n    one = _normalize2.default.key(one);\n    two = _normalize2.default.key(two);\n\n    if (one == this.key) return this;\n    if (two == this.key) return this;\n\n    this.assertDescendant(one);\n    this.assertDescendant(two);\n    var ancestors = new _immutable.List();\n    var oneParent = this.getParent(one);\n    var twoParent = this.getParent(two);\n\n    while (oneParent) {\n      ancestors = ancestors.push(oneParent);\n      oneParent = this.getParent(oneParent.key);\n    }\n\n    while (twoParent) {\n      if (ancestors.includes(twoParent)) return twoParent;\n      twoParent = this.getParent(twoParent.key);\n    }\n  },\n\n\n  /**\n   * Get the component for the node from a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Component|Void}\n   */\n\n  getComponent: function getComponent(schema) {\n    return schema.__getComponent(this);\n  },\n\n\n  /**\n   * Get the decorations for the node from a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Array}\n   */\n\n  getDecorators: function getDecorators(schema) {\n    return schema.__getDecorators(this);\n  },\n\n\n  /**\n   * Get the depth of a child node by `key`, with optional `startAt`.\n   *\n   * @param {String} key\n   * @param {Number} startAt (optional)\n   * @return {Number} depth\n   */\n\n  getDepth: function getDepth(key) {\n    var startAt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    this.assertDescendant(key);\n    return this.hasChild(key) ? startAt : this.getFurthestAncestor(key).getDepth(key, startAt + 1);\n  },\n\n\n  /**\n   * Get a descendant node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getDescendant: function getDescendant(key) {\n    key = _normalize2.default.key(key);\n    var descendantFound = null;\n\n    var found = this.nodes.find(function (node) {\n      if (node.key === key) {\n        return node;\n      } else if (node.kind !== 'text') {\n        descendantFound = node.getDescendant(key);\n        return descendantFound;\n      } else {\n        return false;\n      }\n    });\n\n    return descendantFound || found;\n  },\n\n\n  /**\n   * Get a descendant by `path`.\n   *\n   * @param {Array} path\n   * @return {Node|Null}\n   */\n\n  getDescendantAtPath: function getDescendantAtPath(path) {\n    var descendant = this;\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = path[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var index = _step.value;\n\n        if (!descendant) return;\n        if (!descendant.nodes) return;\n        descendant = descendant.nodes.get(index);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return descendant;\n  },\n\n\n  /**\n   * Get the decorators for a descendant by `key` given a `schema`.\n   *\n   * @param {String} key\n   * @param {Schema} schema\n   * @return {Array}\n   */\n\n  getDescendantDecorators: function getDescendantDecorators(key, schema) {\n    if (!schema.hasDecorators) {\n      return [];\n    }\n\n    var descendant = this.assertDescendant(key);\n    var child = this.getFurthestAncestor(key);\n    var decorators = [];\n\n    while (child != descendant) {\n      decorators = decorators.concat(child.getDecorators(schema));\n      child = child.getFurthestAncestor(key);\n    }\n\n    decorators = decorators.concat(descendant.getDecorators(schema));\n    return decorators;\n  },\n\n\n  /**\n   * Get the first child text node.\n   *\n   * @return {Node|Null}\n   */\n\n  getFirstText: function getFirstText() {\n    var descendantFound = null;\n\n    var found = this.nodes.find(function (node) {\n      if (node.kind == 'text') return true;\n      descendantFound = node.getFirstText();\n      return descendantFound;\n    });\n\n    return descendantFound || found;\n  },\n\n\n  /**\n   * Get a fragment of the node at a `range`.\n   *\n   * @param {Selection} range\n   * @return {List<Node>}\n   */\n\n  getFragmentAtRange: function getFragmentAtRange(range) {\n    var node = this;\n    var nodes = new _immutable.List();\n\n    // Make sure the children exist.\n    var startKey = range.startKey,\n        startOffset = range.startOffset,\n        endKey = range.endKey,\n        endOffset = range.endOffset;\n\n    node.assertDescendant(startKey);\n    node.assertDescendant(endKey);\n\n    // Split at the start and end.\n    var start = range.collapseToStart();\n    node = node.splitBlockAtRange(start, Infinity);\n\n    var next = node.getNextText(startKey);\n    var end = startKey == endKey ? range.collapseToStartOf(next).move(endOffset - startOffset) : range.collapseToEnd();\n    node = node.splitBlockAtRange(end, Infinity);\n\n    // Get the start and end nodes.\n    var startNode = node.getNextSibling(node.getFurthestAncestor(startKey).key);\n    var endNode = startKey == endKey ? node.getFurthestAncestor(next.key) : node.getFurthestAncestor(endKey);\n\n    // Get children range of nodes from start to end nodes\n    var startIndex = node.nodes.indexOf(startNode);\n    var endIndex = node.nodes.indexOf(endNode);\n    nodes = node.nodes.slice(startIndex, endIndex + 1);\n\n    // Return a new document fragment.\n    return _document2.default.create({ nodes: nodes });\n  },\n\n\n  /**\n   * Get the furthest parent of a node by `key` that matches an `iterator`.\n   *\n   * @param {String} key\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  getFurthest: function getFurthest(key, iterator) {\n    var ancestors = this.getAncestors(key);\n    if (!ancestors) {\n      key = _normalize2.default.key(key);\n      throw new Error('Could not find a descendant node with key \"' + key + '\".');\n    }\n\n    // Exclude this node itself\n    return ancestors.rest().find(iterator);\n  },\n\n\n  /**\n   * Get the furthest block parent of a node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getFurthestBlock: function getFurthestBlock(key) {\n    return this.getFurthest(key, function (node) {\n      return node.kind == 'block';\n    });\n  },\n\n\n  /**\n   * Get the furthest inline parent of a node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getFurthestInline: function getFurthestInline(key) {\n    return this.getFurthest(key, function (node) {\n      return node.kind == 'inline';\n    });\n  },\n\n\n  /**\n   * Get the furthest ancestor of a node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getFurthestAncestor: function getFurthestAncestor(key) {\n    key = _normalize2.default.key(key);\n    return this.nodes.find(function (node) {\n      if (node.key == key) return true;\n      if (node.kind == 'text') return false;\n      return node.hasDescendant(key);\n    });\n  },\n\n\n  /**\n   * Get the furthest ancestor of a node by `key` that has only one child.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getFurthestOnlyChildAncestor: function getFurthestOnlyChildAncestor(key) {\n    var ancestors = this.getAncestors(key);\n\n    if (!ancestors) {\n      key = _normalize2.default.key(key);\n      throw new Error('Could not find a descendant node with key \"' + key + '\".');\n    }\n\n    return ancestors\n    // Skip this node...\n    .skipLast()\n    // Take parents until there are more than one child...\n    .reverse().takeUntil(function (p) {\n      return p.nodes.size > 1;\n    })\n    // And pick the highest.\n    .last();\n  },\n\n\n  /**\n   * Get the closest inline nodes for each text node in the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getInlines: function getInlines() {\n    var array = this.getInlinesAsArray();\n    return new _immutable.List(array);\n  },\n\n\n  /**\n   * Get the closest inline nodes for each text node in the node, as an array.\n   *\n   * @return {List<Node>}\n   */\n\n  getInlinesAsArray: function getInlinesAsArray() {\n    var array = [];\n\n    this.nodes.forEach(function (child) {\n      if (child.kind == 'text') return;\n      if (child.isLeafInline()) {\n        array.push(child);\n      } else {\n        array = array.concat(child.getInlinesAsArray());\n      }\n    });\n\n    return array;\n  },\n\n\n  /**\n   * Get the closest inline nodes for each text node in a `range`.\n   *\n   * @param {Selection} range\n   * @return {List<Node>}\n   */\n\n  getInlinesAtRange: function getInlinesAtRange(range) {\n    var _this2 = this;\n\n    return this.getTextsAtRange(range).map(function (text) {\n      return _this2.getClosestInline(text.key);\n    }).filter(function (exists) {\n      return exists;\n    }).toOrderedSet().toList();\n  },\n\n\n  /**\n   * Get all of the leaf inline nodes that match a `type`.\n   *\n   * @param {String} type\n   * @return {List<Node>}\n   */\n\n  getInlinesByType: function getInlinesByType(type) {\n    return this.nodes.reduce(function (inlines, node) {\n      if (node.kind == 'text') return inlines;\n      if (node.isLeafInline() && node.type == type) return inlines.push(node);\n      return inlines.concat(node.getInlinesByType(type));\n    }, new _immutable.List());\n  },\n\n\n  /**\n   * Return a set of all keys in the node.\n   *\n   * @return {Set<Node>}\n   */\n\n  getKeys: function getKeys() {\n    var keys = [];\n\n    this.forEachDescendant(function (desc) {\n      keys.push(desc.key);\n    });\n\n    return (0, _immutable.Set)(keys);\n  },\n\n\n  /**\n   * Get the last child text node.\n   *\n   * @return {Node|Null}\n   */\n\n  getLastText: function getLastText() {\n    var descendantFound = null;\n\n    var found = this.nodes.findLast(function (node) {\n      if (node.kind == 'text') return true;\n      descendantFound = node.getLastText();\n      return descendantFound;\n    });\n\n    return descendantFound || found;\n  },\n\n\n  /**\n   * Get all of the marks for all of the characters of every text node.\n   *\n   * @return {OrderedSet<Mark>}\n   */\n\n  getMarks: function getMarks() {\n    return this.nodes.reduce(function (marks, node) {\n      return marks.union(node.getMarks());\n    }, new _immutable.OrderedSet());\n  },\n\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Selection} range\n   * @return {OrderedSet<Mark>}\n   */\n\n  getMarksAtRange: function getMarksAtRange(range) {\n    range = range.normalize(this);\n    var _range = range,\n        startKey = _range.startKey,\n        startOffset = _range.startOffset;\n\n    // If the range is collapsed at the start of the node, check the previous.\n\n    if (range.isCollapsed && startOffset == 0) {\n      var previous = this.getPreviousText(startKey);\n      if (!previous || !previous.length) return new _immutable.Set();\n      var char = previous.characters.get(previous.length - 1);\n      return char.marks;\n    }\n\n    // If the range is collapsed, check the character before the start.\n    if (range.isCollapsed) {\n      var text = this.getDescendant(startKey);\n      var _char = text.characters.get(range.startOffset - 1);\n      return _char.marks;\n    }\n\n    // Otherwise, get a set of the marks for each character in the range.\n    return this.getCharactersAtRange(range).reduce(function (memo, char) {\n      return memo.union(char.marks);\n    }, new _immutable.OrderedSet());\n  },\n\n\n  /**\n   * Get all of the marks that match a `type`.\n   *\n   * @param {String} type\n   * @return {OrderedSet<Mark>}\n   */\n\n  getMarksByType: function getMarksByType(type) {\n    return this.nodes.reduce(function (marks, node) {\n      return node.kind == 'text' ? marks.union(node.getMarks().filter(function (m) {\n        return m.type == type;\n      })) : marks.union(node.getMarksByType(type));\n    }, new _immutable.OrderedSet());\n  },\n\n\n  /**\n   * Get the block node before a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNextBlock: function getNextBlock(key) {\n    var child = this.assertDescendant(key);\n    var last = void 0;\n\n    if (child.kind == 'block') {\n      last = child.getLastText();\n    } else {\n      var block = this.getClosestBlock(key);\n      last = block.getLastText();\n    }\n\n    var next = this.getNextText(last.key);\n    if (!next) return null;\n\n    return this.getClosestBlock(next.key);\n  },\n\n\n  /**\n   * Get the node after a descendant by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNextSibling: function getNextSibling(key) {\n    key = _normalize2.default.key(key);\n\n    var parent = this.getParent(key);\n    var after = parent.nodes.skipUntil(function (child) {\n      return child.key == key;\n    });\n\n    if (after.size == 0) {\n      throw new Error('Could not find a child node with key \"' + key + '\".');\n    }\n    return after.get(1);\n  },\n\n\n  /**\n   * Get the text node after a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNextText: function getNextText(key) {\n    key = _normalize2.default.key(key);\n    return this.getTexts().skipUntil(function (text) {\n      return text.key == key;\n    }).get(1);\n  },\n\n\n  /**\n   * Get a node in the tree by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNode: function getNode(key) {\n    key = _normalize2.default.key(key);\n    return this.key == key ? this : this.getDescendant(key);\n  },\n\n\n  /**\n   * Get the offset for a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Number}\n   */\n\n  getOffset: function getOffset(key) {\n    this.assertDescendant(key);\n\n    // Calculate the offset of the nodes before the highest child.\n    var child = this.getFurthestAncestor(key);\n    var offset = this.nodes.takeUntil(function (n) {\n      return n == child;\n    }).reduce(function (memo, n) {\n      return memo + n.length;\n    }, 0);\n\n    // Recurse if need be.\n    return this.hasChild(key) ? offset : offset + child.getOffset(key);\n  },\n\n\n  /**\n   * Get the offset from a `range`.\n   *\n   * @param {Selection} range\n   * @return {Number}\n   */\n\n  getOffsetAtRange: function getOffsetAtRange(range) {\n    range = range.normalize(this);\n\n    if (range.isExpanded) {\n      throw new Error('The range must be collapsed to calculcate its offset.');\n    }\n\n    var _range2 = range,\n        startKey = _range2.startKey,\n        startOffset = _range2.startOffset;\n\n    return this.getOffset(startKey) + startOffset;\n  },\n\n\n  /**\n   * Get the parent of a child node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getParent: function getParent(key) {\n    if (this.hasChild(key)) return this;\n\n    var node = null;\n\n    this.nodes.find(function (child) {\n      if (child.kind == 'text') {\n        return false;\n      } else {\n        node = child.getParent(key);\n        return node;\n      }\n    });\n\n    return node;\n  },\n\n\n  /**\n   * Get the path of a descendant node by `key`.\n   *\n   * @param {String|Node} key\n   * @return {Array}\n   */\n\n  getPath: function getPath(key) {\n    var child = this.assertNode(key);\n    var ancestors = this.getAncestors(key);\n    var path = [];\n\n    ancestors.reverse().forEach(function (ancestor) {\n      var index = ancestor.nodes.indexOf(child);\n      path.unshift(index);\n      child = ancestor;\n    });\n\n    return path;\n  },\n\n\n  /**\n   * Get the block node before a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getPreviousBlock: function getPreviousBlock(key) {\n    var child = this.assertDescendant(key);\n    var first = void 0;\n\n    if (child.kind == 'block') {\n      first = child.getFirstText();\n    } else {\n      var block = this.getClosestBlock(key);\n      first = block.getFirstText();\n    }\n\n    var previous = this.getPreviousText(first.key);\n    if (!previous) return null;\n\n    return this.getClosestBlock(previous.key);\n  },\n\n\n  /**\n   * Get the node before a descendant node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getPreviousSibling: function getPreviousSibling(key) {\n    key = _normalize2.default.key(key);\n    var parent = this.getParent(key);\n    var before = parent.nodes.takeUntil(function (child) {\n      return child.key == key;\n    });\n\n    if (before.size == parent.nodes.size) {\n      throw new Error('Could not find a child node with key \"' + key + '\".');\n    }\n\n    return before.last();\n  },\n\n\n  /**\n   * Get the text node before a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getPreviousText: function getPreviousText(key) {\n    key = _normalize2.default.key(key);\n    return this.getTexts().takeUntil(function (text) {\n      return text.key == key;\n    }).last();\n  },\n\n\n  /**\n   * Get the concatenated text string of all child nodes.\n   *\n   * @return {String}\n   */\n\n  getText: function getText() {\n    return this.nodes.reduce(function (string, node) {\n      return string + node.text;\n    }, '');\n  },\n\n\n  /**\n   * Get the descendent text node at an `offset`.\n   *\n   * @param {String} offset\n   * @return {Node|Null}\n   */\n\n  getTextAtOffset: function getTextAtOffset(offset) {\n    // PERF: Add a few shortcuts for the obvious cases.\n    if (offset == 0) return this.getFirstText();\n    if (offset == this.length) return this.getLastText();\n    if (offset < 0 || offset > this.length) return null;\n\n    var length = 0;\n\n    return this.getTexts().find(function (text, i, texts) {\n      length += text.length;\n      return length > offset;\n    });\n  },\n\n\n  /**\n   * Get the direction of the node's text.\n   *\n   * @return {String}\n   */\n\n  getTextDirection: function getTextDirection() {\n    var dir = (0, _direction2.default)(this.text);\n    return dir == 'neutral' ? undefined : dir;\n  },\n\n\n  /**\n   * Recursively get all of the child text nodes in order of appearance.\n   *\n   * @return {List<Node>}\n   */\n\n  getTexts: function getTexts() {\n    var array = this.getTextsAsArray();\n    return new _immutable.List(array);\n  },\n\n\n  /**\n   * Recursively get all the leaf text nodes in order of appearance, as array.\n   *\n   * @return {List<Node>}\n   */\n\n  getTextsAsArray: function getTextsAsArray() {\n    var array = [];\n\n    this.nodes.forEach(function (node) {\n      if (node.kind == 'text') {\n        array.push(node);\n      } else {\n        array = array.concat(node.getTextsAsArray());\n      }\n    });\n\n    return array;\n  },\n\n\n  /**\n   * Get all of the text nodes in a `range`.\n   *\n   * @param {Selection} range\n   * @return {List<Node>}\n   */\n\n  getTextsAtRange: function getTextsAtRange(range) {\n    range = range.normalize(this);\n    var _range3 = range,\n        startKey = _range3.startKey,\n        endKey = _range3.endKey;\n\n    var texts = this.getTexts();\n    var startText = this.getDescendant(startKey);\n    var endText = this.getDescendant(endKey);\n    var start = texts.indexOf(startText);\n    var end = texts.indexOf(endText);\n    return texts.slice(start, end + 1);\n  },\n\n\n  /**\n   * Check if a child node exists by `key`.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasChild: function hasChild(key) {\n    return !!this.getChild(key);\n  },\n\n\n  /**\n   * Recursively check if a child node exists by `key`.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasDescendant: function hasDescendant(key) {\n    return !!this.getDescendant(key);\n  },\n\n\n  /**\n   * Recursively check if a node exists by `key`.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasNode: function hasNode(key) {\n    return !!this.getNode(key);\n  },\n\n\n  /**\n   * Check if a node has a void parent by `key`.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasVoidParent: function hasVoidParent(key) {\n    return !!this.getClosest(key, function (parent) {\n      return parent.isVoid;\n    });\n  },\n\n\n  /**\n   * Insert a `node` at `index`.\n   *\n   * @param {Number} index\n   * @param {Node} node\n   * @return {Node}\n   */\n\n  insertNode: function insertNode(index, node) {\n    var keys = this.getKeys();\n\n    if (keys.contains(node.key)) {\n      node = node.regenerateKey();\n    }\n\n    if (node.kind != 'text') {\n      node = node.mapDescendants(function (desc) {\n        return keys.contains(desc.key) ? desc.regenerateKey() : desc;\n      });\n    }\n\n    var nodes = this.nodes.insert(index, node);\n    return this.set('nodes', nodes);\n  },\n\n\n  /**\n   * Check whether the node is a leaf block.\n   *\n   * @return {Boolean}\n   */\n\n  isLeafBlock: function isLeafBlock() {\n    return this.kind == 'block' && this.nodes.every(function (n) {\n      return n.kind != 'block';\n    });\n  },\n\n\n  /**\n   * Check whether the node is a leaf inline.\n   *\n   * @return {Boolean}\n   */\n\n  isLeafInline: function isLeafInline() {\n    return this.kind == 'inline' && this.nodes.every(function (n) {\n      return n.kind != 'inline';\n    });\n  },\n\n\n  /**\n   * Join a children node `first` with another children node `second`.\n   * `first` and `second` will be concatenated in that order.\n   * `first` and `second` must be two Nodes or two Text.\n   *\n   * @param {Node} first\n   * @param {Node} second\n   * @param {Boolean} options.deep (optional) Join recursively the\n   * respective last node and first node of the nodes' children. Like a zipper :)\n   * @return {Node}\n   */\n\n  joinNode: function joinNode(first, second, options) {\n    var _options$deep = options.deep,\n        deep = _options$deep === undefined ? false : _options$deep;\n\n    var node = this;\n    var parent = node.getParent(second.key);\n    var isParent = node == parent;\n    var index = parent.nodes.indexOf(second);\n\n    if (second.kind == 'text') {\n      var _first = first,\n          characters = _first.characters;\n\n      characters = characters.concat(second.characters);\n      first = first.set('characters', characters);\n    } else {\n      var size = first.nodes.size;\n\n      second.nodes.forEach(function (child, i) {\n        first = first.insertNode(size + i, child);\n      });\n\n      if (deep) {\n        // Join recursively\n        first = first.joinNode(first.nodes.get(size - 1), first.nodes.get(size), { deep: deep });\n      }\n    }\n\n    parent = parent.removeNode(index);\n    node = isParent ? parent : node.updateDescendant(parent);\n    node = node.updateDescendant(first);\n    return node;\n  },\n\n\n  /**\n   * Map all child nodes, updating them in their parents. This method is\n   * optimized to not return a new node if no changes are made.\n   *\n   * @param {Function} iterator\n   * @return {Node}\n   */\n\n  mapChildren: function mapChildren(iterator) {\n    var _this3 = this;\n\n    var nodes = this.nodes;\n\n\n    nodes.forEach(function (node, i) {\n      var ret = iterator(node, i, _this3.nodes);\n      if (ret != node) nodes = nodes.set(ret.key, ret);\n    });\n\n    return this.set('nodes', nodes);\n  },\n\n\n  /**\n   * Map all descendant nodes, updating them in their parents. This method is\n   * optimized to not return a new node if no changes are made.\n   *\n   * @param {Function} iterator\n   * @return {Node}\n   */\n\n  mapDescendants: function mapDescendants(iterator) {\n    var _this4 = this;\n\n    var nodes = this.nodes;\n\n\n    nodes.forEach(function (node, i) {\n      var ret = node;\n      if (ret.kind != 'text') ret = ret.mapDescendants(iterator);\n      ret = iterator(ret, i, _this4.nodes);\n      if (ret == node) return;\n\n      var index = nodes.indexOf(node);\n      nodes = nodes.set(index, ret);\n    });\n\n    return this.set('nodes', nodes);\n  },\n\n\n  /**\n   * Regenerate the node's key.\n   *\n   * @return {Node}\n   */\n\n  regenerateKey: function regenerateKey() {\n    var key = (0, _generateKey2.default)();\n    return this.set('key', key);\n  },\n\n\n  /**\n   * Remove a `node` from the children node map.\n   *\n   * @param {String} key\n   * @return {Node}\n   */\n\n  removeDescendant: function removeDescendant(key) {\n    key = _normalize2.default.key(key);\n\n    var node = this;\n    var parent = node.getParent(key);\n    if (!parent) throw new Error('Could not find a descendant node with key \"' + key + '\".');\n\n    var index = parent.nodes.findIndex(function (n) {\n      return n.key === key;\n    });\n    var isParent = node == parent;\n    var nodes = parent.nodes.splice(index, 1);\n\n    parent = parent.set('nodes', nodes);\n    node = isParent ? parent : node.updateDescendant(parent);\n    return node;\n  },\n\n\n  /**\n   * Remove a node at `index`.\n   *\n   * @param {Number} index\n   * @return {Node}\n   */\n\n  removeNode: function removeNode(index) {\n    var nodes = this.nodes.splice(index, 1);\n    return this.set('nodes', nodes);\n  },\n\n\n  /**\n   * Split the block nodes at a `range`, to optional `height`.\n   *\n   * @param {Selection} range\n   * @param {Number} height (optional)\n   * @return {Node}\n   */\n\n  splitBlockAtRange: function splitBlockAtRange(range) {\n    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var startKey = range.startKey,\n        startOffset = range.startOffset;\n\n    var base = this;\n    var node = base.assertDescendant(startKey);\n    var parent = base.getClosestBlock(node.key);\n    var offset = startOffset;\n    var h = 0;\n\n    while (parent && parent.kind == 'block' && h < height) {\n      offset += parent.getOffset(node.key);\n      node = parent;\n      parent = base.getClosestBlock(parent.key);\n      h++;\n    }\n\n    var path = base.getPath(node.key);\n    return this.splitNode(path, offset);\n  },\n\n\n  /**\n   * Split a node by `path` at `offset`.\n   *\n   * @param {Array} path\n   * @param {Number} offset\n   * @return {Node}\n   */\n\n  splitNode: function splitNode(path, offset) {\n    var base = this;\n    var node = base.assertPath(path);\n    var parent = base.getParent(node.key);\n    var isParent = base == parent;\n    var index = parent.nodes.indexOf(node);\n\n    var child = node;\n    var one = void 0;\n    var two = void 0;\n\n    if (node.kind != 'text') {\n      child = node.getTextAtOffset(offset);\n    }\n\n    while (child && child != parent) {\n      if (child.kind == 'text') {\n        var i = node.kind == 'text' ? offset : offset - node.getOffset(child.key);\n        var _child = child,\n            characters = _child.characters;\n\n        var oneChars = characters.take(i);\n        var twoChars = characters.skip(i);\n        one = child.set('characters', oneChars);\n        two = child.set('characters', twoChars).regenerateKey();\n      } else {\n        var _child2 = child,\n            nodes = _child2.nodes;\n\n        // Try to preserve the nodes list to preserve reference of one == node to avoid re-render\n        // When spliting at the end of a text node, the first node is preserved\n\n        var oneNodes = nodes.takeUntil(function (n) {\n          return n.key == one.key;\n        });\n        oneNodes = oneNodes.size == nodes.size - 1 && one == nodes.last() ? nodes : oneNodes.push(one);\n\n        var twoNodes = nodes.skipUntil(function (n) {\n          return n.key == one.key;\n        }).rest().unshift(two);\n        one = child.set('nodes', oneNodes);\n        two = child.set('nodes', twoNodes).regenerateKey();\n      }\n\n      child = base.getParent(child.key);\n    }\n\n    parent = parent.removeNode(index);\n    parent = parent.insertNode(index, two);\n    parent = parent.insertNode(index, one);\n    base = isParent ? parent : base.updateDescendant(parent);\n    return base;\n  },\n\n\n  /**\n   * Split a node by `path` after 'count' children.\n   * Does not work on Text nodes. Use `Node.splitNode` to split text nodes as well.\n   *\n   * @param {Array} path\n   * @param {Number} count\n   * @return {Node}\n   */\n\n  splitNodeAfter: function splitNodeAfter(path, count) {\n    var base = this;\n    var node = base.assertPath(path);\n    if (node.kind === 'text') throw new Error('Cannot split text node at index. Use Node.splitNode at offset instead');\n    var nodes = node.nodes;\n\n\n    var parent = base.getParent(node.key);\n    var isParent = base == parent;\n\n    var oneNodes = nodes.take(count);\n    var twoNodes = nodes.skip(count);\n\n    var one = node.set('nodes', oneNodes);\n    var two = node.set('nodes', twoNodes).regenerateKey();\n\n    var nodeIndex = parent.nodes.indexOf(node);\n    parent = parent.removeNode(nodeIndex);\n    parent = parent.insertNode(nodeIndex, two);\n    parent = parent.insertNode(nodeIndex, one);\n\n    base = isParent ? parent : base.updateDescendant(parent);\n    return base;\n  },\n\n\n  /**\n   * Set a new value for a child node by `key`.\n   *\n   * @param {Node} node\n   * @return {Node}\n   */\n\n  updateDescendant: function updateDescendant(node) {\n    var child = this.assertDescendant(node.key);\n    var ancestors = this.getAncestors(node.key);\n\n    ancestors.reverse().forEach(function (parent) {\n      var _parent = parent,\n          nodes = _parent.nodes;\n\n      var index = nodes.indexOf(child);\n      child = parent;\n      nodes = nodes.set(index, node);\n      parent = parent.set('nodes', nodes);\n      node = parent;\n    });\n\n    return node;\n  },\n\n\n  /**\n   * Validate the node against a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Object|Null}\n   */\n\n  validate: function validate(schema) {\n    return schema.__validate(this);\n  },\n\n\n  /**\n   * True if the node has both descendants in that order, false otherwise. The\n   * order is depth-first, post-order.\n   *\n   * @param {String} first\n   * @param {String} second\n   * @return {Boolean}\n   */\n\n  areDescendantSorted: function areDescendantSorted(first, second) {\n    (0, _warn2.default)('The Node.areDescendantSorted(first, second) method is deprecated, please use `Node.areDescendantsSorted(first, second) instead.');\n    return this.areDescendantsSorted(first, second);\n  },\n\n\n  /**\n   * Concat children `nodes` on to the end of the node.\n   *\n   * @param {List<Node>} nodes\n   * @return {Node}\n   */\n\n  concatChildren: function concatChildren(nodes) {\n    (0, _warn2.default)('The `Node.concatChildren(nodes)` method is deprecated.');\n    nodes = this.nodes.concat(nodes);\n    return this.set('nodes', nodes);\n  },\n\n\n  /**\n   * Decorate all of the text nodes with a `decorator` function.\n   *\n   * @param {Function} decorator\n   * @return {Node}\n   */\n\n  decorateTexts: function decorateTexts(decorator) {\n    (0, _warn2.default)('The `Node.decorateTexts(decorator) method is deprecated.');\n    return this.mapDescendants(function (child) {\n      return child.kind == 'text' ? child.decorateCharacters(decorator) : child;\n    });\n  },\n\n\n  /**\n   * Recursively filter all descendant nodes with `iterator`, depth-first.\n   * It is different from `filterDescendants` in regard of the order of results.\n   *\n   * @param {Function} iterator\n   * @return {List<Node>}\n   */\n\n  filterDescendantsDeep: function filterDescendantsDeep(iterator) {\n    (0, _warn2.default)('The Node.filterDescendantsDeep(iterator) method is deprecated.');\n    return this.nodes.reduce(function (matches, child, i, nodes) {\n      if (child.kind != 'text') matches = matches.concat(child.filterDescendantsDeep(iterator));\n      if (iterator(child, i, nodes)) matches = matches.push(child);\n      return matches;\n    }, new _immutable.List());\n  },\n\n\n  /**\n   * Recursively find all descendant nodes by `iterator`. Depth first.\n   *\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  findDescendantDeep: function findDescendantDeep(iterator) {\n    (0, _warn2.default)('The Node.findDescendantDeep(iterator) method is deprecated.');\n    var found = void 0;\n\n    this.forEachDescendant(function (node) {\n      if (iterator(node)) {\n        found = node;\n        return false;\n      }\n    });\n\n    return found;\n  },\n\n\n  /**\n   * Get children between two child keys.\n   *\n   * @param {String} start\n   * @param {String} end\n   * @return {Node}\n   */\n\n  getChildrenBetween: function getChildrenBetween(start, end) {\n    (0, _warn2.default)('The `Node.getChildrenBetween(start, end)` method is deprecated.');\n    start = this.assertChild(start);\n    start = this.nodes.indexOf(start);\n    end = this.assertChild(end);\n    end = this.nodes.indexOf(end);\n    return this.nodes.slice(start + 1, end);\n  },\n\n\n  /**\n   * Get children between two child keys, including the two children.\n   *\n   * @param {String} start\n   * @param {String} end\n   * @return {Node}\n   */\n\n  getChildrenBetweenIncluding: function getChildrenBetweenIncluding(start, end) {\n    (0, _warn2.default)('The `Node.getChildrenBetweenIncluding(start, end)` method is deprecated.');\n    start = this.assertChild(start);\n    start = this.nodes.indexOf(start);\n    end = this.assertChild(end);\n    end = this.nodes.indexOf(end);\n    return this.nodes.slice(start, end + 1);\n  },\n\n\n  /**\n   * Get the highest child ancestor of a node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getHighestChild: function getHighestChild(key) {\n    (0, _warn2.default)('The `Node.getHighestChild(key) method is deprecated, please use `Node.getFurthestAncestor(key) instead.');\n    return this.getFurthestAncestor(key);\n  },\n\n\n  /**\n   * Get the highest parent of a node by `key` which has an only child.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getHighestOnlyChildParent: function getHighestOnlyChildParent(key) {\n    (0, _warn2.default)('The `Node.getHighestOnlyChildParent(key)` method is deprecated, please use `Node.getFurthestOnlyChildAncestor` instead.');\n    return this.getFurthestOnlyChildAncestor(key);\n  },\n\n\n  /**\n   * Check if the inline nodes are split at a `range`.\n   *\n   * @param {Selection} range\n   * @return {Boolean}\n   */\n\n  isInlineSplitAtRange: function isInlineSplitAtRange(range) {\n    (0, _warn2.default)('The `Node.isInlineSplitAtRange(range)` method is deprecated.');\n    range = range.normalize(this);\n    if (range.isExpanded) throw new Error();\n\n    var _range4 = range,\n        startKey = _range4.startKey;\n\n    var start = this.getFurthestInline(startKey) || this.getDescendant(startKey);\n    return range.isAtStartOf(start) || range.isAtEndOf(start);\n  }\n};\n\n/**\n * Memoize read methods.\n */\n\n(0, _memoize2.default)(Node, ['areDescendantsSorted', 'getAncestors', 'getBlocks', 'getBlocksAsArray', 'getBlocksAtRange', 'getBlocksByType', 'getCharacters', 'getCharactersAtRange', 'getChild', 'getChildrenBetween', 'getChildrenBetweenIncluding', 'getClosestBlock', 'getClosestInline', 'getClosestVoid', 'getCommonAncestor', 'getComponent', 'getDecorators', 'getDepth', 'getDescendant', 'getDescendant', 'getDescendantAtPath', 'getDescendantDecorators', 'getFirstText', 'getFragmentAtRange', 'getFurthestBlock', 'getFurthestInline', 'getFurthestAncestor', 'getFurthestOnlyChildAncestor', 'getInlines', 'getInlinesAsArray', 'getInlinesAtRange', 'getInlinesByType', 'getKeys', 'getLastText', 'getMarks', 'getMarksAtRange', 'getMarksByType', 'getNextBlock', 'getNextSibling', 'getNextText', 'getNode', 'getOffset', 'getOffsetAtRange', 'getParent', 'getPath', 'getPreviousBlock', 'getPreviousSibling', 'getPreviousText', 'getText', 'getTextAtOffset', 'getTextDirection', 'getTexts', 'getTextsAsArray', 'getTextsAtRange', 'hasChild', 'hasDescendant', 'hasNode', 'hasVoidParent', 'isInlineSplitAtRange', 'isLeafBlock', 'isLeafInline', 'validate']);\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Node;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/normalize.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _block = require('../models/block');\n\nvar _block2 = _interopRequireDefault(_block);\n\nvar _document = require('../models/document');\n\nvar _document2 = _interopRequireDefault(_document);\n\nvar _inline = require('../models/inline');\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nvar _data = require('../models/data');\n\nvar _data2 = _interopRequireDefault(_data);\n\nvar _mark = require('../models/mark');\n\nvar _mark2 = _interopRequireDefault(_mark);\n\nvar _selection = require('../models/selection');\n\nvar _selection2 = _interopRequireDefault(_selection);\n\nvar _text = require('../models/text');\n\nvar _text2 = _interopRequireDefault(_text);\n\nvar _warn = require('./warn');\n\nvar _warn2 = _interopRequireDefault(_warn);\n\nvar _typeOf = require('type-of');\n\nvar _typeOf2 = _interopRequireDefault(_typeOf);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Normalize a block argument `value`.\n *\n * @param {Block|String|Object} value\n * @return {Block}\n */\n\nfunction block(value) {\n  if (value instanceof _block2.default) return value;\n\n  switch ((0, _typeOf2.default)(value)) {\n    case 'string':\n    case 'object':\n      return _block2.default.create(nodeProperties(value));\n\n    default:\n      throw new Error('Invalid `block` argument! It must be a block, an object, or a string. You passed: \"' + value + '\".');\n  }\n}\n\n/**\n * Normalize an inline argument `value`.\n *\n * @param {Inline|String|Object} value\n * @return {Inline}\n */\n\nfunction inline(value) {\n  if (value instanceof _inline2.default) return value;\n\n  switch ((0, _typeOf2.default)(value)) {\n    case 'string':\n    case 'object':\n      return _inline2.default.create(nodeProperties(value));\n\n    default:\n      throw new Error('Invalid `inline` argument! It must be an inline, an object, or a string. You passed: \"' + value + '\".');\n  }\n}\n\n/**\n * Normalize a key argument `value`.\n *\n * @param {String|Node} value\n * @return {String}\n */\n\nfunction key(value) {\n  if ((0, _typeOf2.default)(value) == 'string') return value;\n\n  (0, _warn2.default)('An object was passed to a Node method instead of a `key` string. This was previously supported, but is being deprecated because it can have a negative impact on performance. The object in question was:', value);\n  if (value instanceof _block2.default) return value.key;\n  if (value instanceof _document2.default) return value.key;\n  if (value instanceof _inline2.default) return value.key;\n  if (value instanceof _text2.default) return value.key;\n\n  throw new Error('Invalid `key` argument! It must be either a block, an inline, a text, or a string. You passed: \"' + value + '\".');\n}\n\n/**\n * Normalize a mark argument `value`.\n *\n * @param {Mark|String|Object} value\n * @return {Mark}\n */\n\nfunction mark(value) {\n  if (value instanceof _mark2.default) return value;\n\n  switch ((0, _typeOf2.default)(value)) {\n    case 'string':\n    case 'object':\n      return _mark2.default.create(markProperties(value));\n\n    default:\n      throw new Error('Invalid `mark` argument! It must be a mark, an object, or a string. You passed: \"' + value + '\".');\n  }\n}\n\n/**\n * Normalize a mark properties argument `value`.\n *\n * @param {String|Object|Mark} value\n * @return {Object}\n */\n\nfunction markProperties() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var ret = {};\n\n  switch ((0, _typeOf2.default)(value)) {\n    case 'string':\n      ret.type = value;\n      break;\n\n    case 'object':\n      for (var k in value) {\n        if (k == 'data') {\n          if (value[k] !== undefined) ret[k] = _data2.default.create(value[k]);\n        } else {\n          ret[k] = value[k];\n        }\n      }\n      break;\n\n    default:\n      throw new Error('Invalid mark `properties` argument! It must be an object, a string or a mark. You passed: \"' + value + '\".');\n  }\n\n  return ret;\n}\n\n/**\n * Normalize a node properties argument `value`.\n *\n * @param {String|Object|Node} value\n * @return {Object}\n */\n\nfunction nodeProperties() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var ret = {};\n\n  switch ((0, _typeOf2.default)(value)) {\n    case 'string':\n      ret.type = value;\n      break;\n\n    case 'object':\n      if (value.isVoid !== undefined) ret.isVoid = !!value.isVoid;\n      for (var k in value) {\n        if (k == 'data') {\n          if (value[k] !== undefined) ret[k] = _data2.default.create(value[k]);\n        } else {\n          ret[k] = value[k];\n        }\n      }\n      break;\n\n    default:\n      throw new Error('Invalid node `properties` argument! It must be an object, a string or a node. You passed: \"' + value + '\".');\n  }\n\n  return ret;\n}\n\n/**\n * Normalize a selection argument `value`.\n *\n * @param {Selection|Object} value\n * @return {Selection}\n */\n\nfunction selection(value) {\n  if (value instanceof _selection2.default) return value;\n\n  switch ((0, _typeOf2.default)(value)) {\n    case 'object':\n      return _selection2.default.create(value);\n\n    default:\n      throw new Error('Invalid `selection` argument! It must be a selection or an object. You passed: \"' + value + '\".');\n  }\n}\n\n/**\n * Normalize a selection properties argument `value`.\n *\n * @param {Object|Selection} value\n * @return {Object}\n */\n\nfunction selectionProperties() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var ret = {};\n\n  switch ((0, _typeOf2.default)(value)) {\n    case 'object':\n      if (value.anchorKey !== undefined) ret.anchorKey = value.anchorKey;\n      if (value.anchorOffset !== undefined) ret.anchorOffset = value.anchorOffset;\n      if (value.focusKey !== undefined) ret.focusKey = value.focusKey;\n      if (value.focusOffset !== undefined) ret.focusOffset = value.focusOffset;\n      if (value.isBackward !== undefined) ret.isBackward = !!value.isBackward;\n      if (value.isFocused !== undefined) ret.isFocused = !!value.isFocused;\n      if (value.marks !== undefined) ret.marks = value.marks;\n      break;\n\n    default:\n      throw new Error('Invalid selection `properties` argument! It must be an object or a selection. You passed: \"' + value + '\".');\n  }\n\n  return ret;\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = {\n  block: block,\n  inline: inline,\n  key: key,\n  mark: mark,\n  markProperties: markProperties,\n  nodeProperties: nodeProperties,\n  selection: selection,\n  selectionProperties: selectionProperties\n};","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/models/mark.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _data = require('./data');\n\nvar _data2 = _interopRequireDefault(_data);\n\nvar _memoize = require('../utils/memoize');\n\nvar _memoize2 = _interopRequireDefault(_memoize);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  data: new _immutable.Map(),\n  type: null\n};\n\n/**\n * Mark.\n *\n * @type {Mark}\n */\n\nvar Mark = function (_ref) {\n  _inherits(Mark, _ref);\n\n  function Mark() {\n    _classCallCheck(this, Mark);\n\n    return _possibleConstructorReturn(this, (Mark.__proto__ || Object.getPrototypeOf(Mark)).apply(this, arguments));\n  }\n\n  _createClass(Mark, [{\n    key: 'getComponent',\n\n\n    /**\n     * Get the component for the node from a `schema`.\n     *\n     * @param {Schema} schema\n     * @return {Component|Void}\n     */\n\n    value: function getComponent(schema) {\n      return schema.__getComponent(this);\n    }\n  }, {\n    key: 'kind',\n\n\n    /**\n     * Get the kind.\n     *\n     * @return {String}\n     */\n\n    get: function get() {\n      return 'mark';\n    }\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Create a new `Mark` with `properties`.\n     *\n     * @param {Object|Mark} properties\n     * @return {Mark}\n     */\n\n    value: function create() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (properties instanceof Mark) return properties;\n      if (!properties.type) throw new Error('You must provide a `type` for the mark.');\n      properties.data = _data2.default.create(properties.data);\n      return new Mark(properties);\n    }\n\n    /**\n     * Create a marks set from an array of marks.\n     *\n     * @param {Array<Object|Mark>} array\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'createSet',\n    value: function createSet() {\n      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (_immutable.Set.isSet(array)) return array;\n      return new _immutable.Set(array.map(Mark.create));\n    }\n  }]);\n\n  return Mark;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Memoize read methods.\n */\n\n(0, _memoize2.default)(Mark.prototype, ['getComponent']);\n\n/**\n * Export.\n *\n * @type {Mark}\n */\n\nexports.default = Mark;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/memoize.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.__enable = exports.__clear = exports.default = undefined;\n\nvar _es6Map = require('es6-map');\n\nvar _es6Map2 = _interopRequireDefault(_es6Map);\n\nvar _isDev = require('../constants/is-dev');\n\nvar _isDev2 = _interopRequireDefault(_isDev);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * GLOBAL: True if memoization should is enabled. Only effective in DEV mode.\n *\n * @type {Boolean}\n */\n\nvar ENABLED = true;\n\n/**\n * GLOBAL: Changing this cache key will clear all previous cached results.\n * Only effective in DEV mode.\n *\n * @type {Number}\n */\n\nvar CACHE_KEY = 0;\n\n/**\n * The leaf node of a cache tree. Used to support variable argument length.\n *\n * A unique object, so that native Maps will key it by reference.\n *\n * @type {Object}\n */\n\nvar LEAF = {};\n\n/**\n * A value to represent a memoized undefined value. Allows efficient\n * value retrieval using Map.get only.\n *\n * @type {Object}\n */\n\nvar UNDEFINED = {};\n\n/**\n * Default value for unset keys in native Maps\n *\n * @type {Undefined}\n */\n\nvar UNSET = undefined;\n\n/**\n * Memoize all of the `properties` on a `object`.\n *\n * @param {Object} object\n * @param {Array} properties\n * @return {Record}\n */\n\nfunction memoize(object, properties) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    var _loop = function _loop() {\n      var property = _step.value;\n\n      var original = object[property];\n\n      if (!original) {\n        throw new Error('Object does not have a property named \"' + property + '\".');\n      }\n\n      object[property] = function () {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        if (_isDev2.default) {\n          if (!ENABLED) {\n            // Memoization disabled\n            return original.apply(this, args);\n          } else if (CACHE_KEY !== this.__cache_key) {\n            // Previous caches must be cleared\n            this.__cache_key = CACHE_KEY;\n            this.__cache = new _es6Map2.default();\n          }\n        }\n\n        var keys = [property].concat(args);\n        this.__cache = this.__cache || new _es6Map2.default();\n\n        var cachedValue = getIn(this.__cache, keys);\n        if (cachedValue !== UNSET) {\n          return cachedValue === UNDEFINED ? undefined : cachedValue;\n        }\n\n        var value = original.apply(this, args);\n        this.__cache = setIn(this.__cache, keys, value);\n        return value;\n      };\n    };\n\n    for (var _iterator = properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      _loop();\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n\n/**\n * Set a value at a key path in a tree of Map, creating Maps on the go.\n *\n * @param {Map} map\n * @param {Array} keys\n * @param {Any} value\n * @return {Map}\n */\n\nfunction setIn(map, keys, value) {\n  value = value === undefined ? UNDEFINED : value;\n\n  var parentMap = map;\n  var childMap = void 0;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var key = _step2.value;\n\n      childMap = parentMap.get(key);\n\n      // If the path was not created yet...\n      if (childMap === UNSET) {\n        childMap = new _es6Map2.default();\n        parentMap.set(key, childMap);\n      }\n\n      parentMap = childMap;\n    }\n\n    // The whole path has been created, so set the value to the bottom most map.\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  childMap.set(LEAF, value);\n\n  return map;\n}\n\n/**\n * Get a value at a key path in a tree of Map.\n *\n * If not set, returns UNSET.\n * If the set value is undefined, returns UNDEFINED.\n *\n * @param {Map} map\n * @param {Array} keys\n * @return {Any|UNSET|UNDEFINED}\n */\n\nfunction getIn(map, keys) {\n  var childMap = void 0;\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = keys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var key = _step3.value;\n\n      childMap = map.get(key);\n\n      if (childMap === UNSET) {\n        return UNSET;\n      }\n\n      map = childMap;\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  return childMap.get(LEAF);\n}\n\n/**\n * In DEV mode, clears the previously memoized values, globally.\n *\n * @return {Void}\n */\n\nfunction __clear() {\n  CACHE_KEY++;\n  if (CACHE_KEY >= Number.MAX_SAFE_INTEGER) {\n    CACHE_KEY = 0;\n  }\n}\n\n/**\n * In DEV mode, enable or disable the use of memoize values, globally.\n *\n * @param {Boolean} enabled\n * @return {Void}\n */\n\nfunction __enable(enabled) {\n  ENABLED = enabled;\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = memoize;\nexports.__clear = __clear;\nexports.__enable = __enable;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/constants/is-dev.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Is in development?\n *\n * @type {Boolean}\n */\n\nvar IS_DEV = typeof process !== 'undefined' && process.env && process.env.NODE_ENV !== 'production';\n\n/**\n * Export.\n *\n * @type {Boolean}\n */\n\nexports.default = IS_DEV;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/models/selection.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _warn = require('../utils/warn');\n\nvar _warn2 = _interopRequireDefault(_warn);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  anchorKey: null,\n  anchorOffset: 0,\n  focusKey: null,\n  focusOffset: 0,\n  isBackward: null,\n  isFocused: false,\n  marks: null\n};\n\n/**\n * Selection.\n *\n * @type {Selection}\n */\n\nvar Selection = function (_ref) {\n  _inherits(Selection, _ref);\n\n  function Selection() {\n    _classCallCheck(this, Selection);\n\n    return _possibleConstructorReturn(this, (Selection.__proto__ || Object.getPrototypeOf(Selection)).apply(this, arguments));\n  }\n\n  _createClass(Selection, [{\n    key: 'hasAnchorAtStartOf',\n\n\n    /**\n     * Check whether anchor point of the selection is at the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n    value: function hasAnchorAtStartOf(node) {\n      // PERF: Do a check for a `0` offset first since it's quickest.\n      if (this.anchorOffset != 0) return false;\n      var first = getFirst(node);\n      return this.anchorKey == first.key;\n    }\n\n    /**\n     * Check whether anchor point of the selection is at the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasAnchorAtEndOf',\n    value: function hasAnchorAtEndOf(node) {\n      var last = getLast(node);\n      return this.anchorKey == last.key && this.anchorOffset == last.length;\n    }\n\n    /**\n     * Check whether the anchor edge of a selection is in a `node` and at an\n     * offset between `start` and `end`.\n     *\n     * @param {Node} node\n     * @param {Number} start\n     * @param {Number} end\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasAnchorBetween',\n    value: function hasAnchorBetween(node, start, end) {\n      return this.anchorOffset <= end && start <= this.anchorOffset && this.hasAnchorIn(node);\n    }\n\n    /**\n     * Check whether the anchor edge of a selection is in a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasAnchorIn',\n    value: function hasAnchorIn(node) {\n      return node.kind == 'text' ? node.key == this.anchorKey : node.hasDescendant(this.anchorKey);\n    }\n\n    /**\n     * Check whether focus point of the selection is at the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasFocusAtEndOf',\n    value: function hasFocusAtEndOf(node) {\n      var last = getLast(node);\n      return this.focusKey == last.key && this.focusOffset == last.length;\n    }\n\n    /**\n     * Check whether focus point of the selection is at the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasFocusAtStartOf',\n    value: function hasFocusAtStartOf(node) {\n      if (this.focusOffset != 0) return false;\n      var first = getFirst(node);\n      return this.focusKey == first.key;\n    }\n\n    /**\n     * Check whether the focus edge of a selection is in a `node` and at an\n     * offset between `start` and `end`.\n     *\n     * @param {Node} node\n     * @param {Number} start\n     * @param {Number} end\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasFocusBetween',\n    value: function hasFocusBetween(node, start, end) {\n      return start <= this.focusOffset && this.focusOffset <= end && this.hasFocusIn(node);\n    }\n\n    /**\n     * Check whether the focus edge of a selection is in a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasFocusIn',\n    value: function hasFocusIn(node) {\n      return node.kind == 'text' ? node.key == this.focusKey : node.hasDescendant(this.focusKey);\n    }\n\n    /**\n     * Check whether the selection is at the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAtStartOf',\n    value: function isAtStartOf(node) {\n      return this.isCollapsed && this.hasAnchorAtStartOf(node);\n    }\n\n    /**\n     * Check whether the selection is at the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAtEndOf',\n    value: function isAtEndOf(node) {\n      return this.isCollapsed && this.hasAnchorAtEndOf(node);\n    }\n\n    /**\n     * Focus the selection.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'focus',\n    value: function focus() {\n      return this.merge({\n        isFocused: true\n      });\n    }\n\n    /**\n     * Blur the selection.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'blur',\n    value: function blur() {\n      return this.merge({\n        isFocused: false\n      });\n    }\n\n    /**\n     * Unset the selection.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'deselect',\n    value: function deselect() {\n      return this.merge({\n        anchorKey: null,\n        anchorOffset: 0,\n        focusKey: null,\n        focusOffset: 0,\n        isFocused: false,\n        isBackward: false\n      });\n    }\n\n    /**\n     * Flip the selection.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'flip',\n    value: function flip() {\n      return this.merge({\n        anchorKey: this.focusKey,\n        anchorOffset: this.focusOffset,\n        focusKey: this.anchorKey,\n        focusOffset: this.anchorOffset,\n        isBackward: this.isBackward == null ? null : !this.isBackward\n      });\n    }\n\n    /**\n     * Move the anchor offset `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveAnchor',\n    value: function moveAnchor() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var anchorKey = this.anchorKey,\n          focusKey = this.focusKey,\n          focusOffset = this.focusOffset,\n          isBackward = this.isBackward;\n\n      var anchorOffset = this.anchorOffset + n;\n      return this.merge({\n        anchorOffset: anchorOffset,\n        isBackward: anchorKey == focusKey ? anchorOffset > focusOffset : isBackward\n      });\n    }\n\n    /**\n     * Move the anchor offset `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveFocus',\n    value: function moveFocus() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var anchorKey = this.anchorKey,\n          anchorOffset = this.anchorOffset,\n          focusKey = this.focusKey,\n          isBackward = this.isBackward;\n\n      var focusOffset = this.focusOffset + n;\n      return this.merge({\n        focusOffset: focusOffset,\n        isBackward: focusKey == anchorKey ? anchorOffset > focusOffset : isBackward\n      });\n    }\n\n    /**\n     * Move the selection's anchor point to a `key` and `offset`.\n     *\n     * @param {String} key\n     * @param {Number} offset\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveAnchorTo',\n    value: function moveAnchorTo(key, offset) {\n      var anchorKey = this.anchorKey,\n          focusKey = this.focusKey,\n          focusOffset = this.focusOffset,\n          isBackward = this.isBackward;\n\n      return this.merge({\n        anchorKey: key,\n        anchorOffset: offset,\n        isBackward: key == focusKey ? offset > focusOffset : key == anchorKey ? isBackward : null\n      });\n    }\n\n    /**\n     * Move the selection's focus point to a `key` and `offset`.\n     *\n     * @param {String} key\n     * @param {Number} offset\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveFocusTo',\n    value: function moveFocusTo(key, offset) {\n      var focusKey = this.focusKey,\n          anchorKey = this.anchorKey,\n          anchorOffset = this.anchorOffset,\n          isBackward = this.isBackward;\n\n      return this.merge({\n        focusKey: key,\n        focusOffset: offset,\n        isBackward: key == anchorKey ? anchorOffset > offset : key == focusKey ? isBackward : null\n      });\n    }\n\n    /**\n     * Move the selection to `anchorOffset`.\n     *\n     * @param {Number} anchorOffset\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveAnchorOffsetTo',\n    value: function moveAnchorOffsetTo(anchorOffset) {\n      return this.merge({\n        anchorOffset: anchorOffset,\n        isBackward: this.anchorKey == this.focusKey ? anchorOffset > this.focusOffset : this.isBackward\n      });\n    }\n\n    /**\n     * Move the selection to `focusOffset`.\n     *\n     * @param {Number} focusOffset\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveFocusOffsetTo',\n    value: function moveFocusOffsetTo(focusOffset) {\n      return this.merge({\n        focusOffset: focusOffset,\n        isBackward: this.anchorKey == this.focusKey ? this.anchorOffset > focusOffset : this.isBackward\n      });\n    }\n\n    /**\n     * Move the selection to `anchorOffset` and `focusOffset`.\n     *\n     * @param {Number} anchorOffset\n     * @param {Number} focusOffset (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveOffsetsTo',\n    value: function moveOffsetsTo(anchorOffset) {\n      var focusOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : anchorOffset;\n\n      return this.moveAnchorOffsetTo(anchorOffset).moveFocusOffsetTo(focusOffset);\n    }\n\n    /**\n     * Move the focus point to the anchor point.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveToAnchor',\n    value: function moveToAnchor() {\n      return this.moveFocusTo(this.anchorKey, this.anchorOffset);\n    }\n\n    /**\n     * Move the anchor point to the focus point.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveToFocus',\n    value: function moveToFocus() {\n      return this.moveAnchorTo(this.focusKey, this.focusOffset);\n    }\n\n    /**\n     * Move the selection's anchor point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveAnchorToStartOf',\n    value: function moveAnchorToStartOf(node) {\n      node = getFirst(node);\n      return this.moveAnchorTo(node.key, 0);\n    }\n\n    /**\n     * Move the selection's anchor point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveAnchorToEndOf',\n    value: function moveAnchorToEndOf(node) {\n      node = getLast(node);\n      return this.moveAnchorTo(node.key, node.length);\n    }\n\n    /**\n     * Move the selection's focus point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveFocusToStartOf',\n    value: function moveFocusToStartOf(node) {\n      node = getFirst(node);\n      return this.moveFocusTo(node.key, 0);\n    }\n\n    /**\n     * Move the selection's focus point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveFocusToEndOf',\n    value: function moveFocusToEndOf(node) {\n      node = getLast(node);\n      return this.moveFocusTo(node.key, node.length);\n    }\n\n    /**\n     * Move to the entire range of `start` and `end` nodes.\n     *\n     * @param {Node} start\n     * @param {Node} end (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveToRangeOf',\n    value: function moveToRangeOf(start) {\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : start;\n\n      return this.moveAnchorToStartOf(start).moveFocusToEndOf(end);\n    }\n\n    /**\n     * Normalize the selection, relative to a `node`, ensuring that the anchor\n     * and focus nodes of the selection always refer to leaf text nodes.\n     *\n     * @param {Node} node\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(node) {\n      var selection = this;\n      var anchorKey = selection.anchorKey,\n          anchorOffset = selection.anchorOffset,\n          focusKey = selection.focusKey,\n          focusOffset = selection.focusOffset,\n          isBackward = selection.isBackward;\n\n      // If the selection isn't formed yet or is malformed, ensure that it is\n      // properly zeroed out.\n\n      if (anchorKey == null || focusKey == null || !node.hasDescendant(anchorKey) || !node.hasDescendant(focusKey)) {\n        return selection.merge({\n          anchorKey: null,\n          anchorOffset: 0,\n          focusKey: null,\n          focusOffset: 0,\n          isBackward: false\n        });\n      }\n\n      // Get the anchor and focus nodes.\n      var anchorNode = node.getDescendant(anchorKey);\n      var focusNode = node.getDescendant(focusKey);\n\n      // If the anchor node isn't a text node, match it to one.\n      if (anchorNode.kind != 'text') {\n        (0, _warn2.default)('The selection anchor was set to a Node that is not a Text node. This should not happen and can degrade performance. The node in question was:', anchorNode);\n        var anchorText = anchorNode.getTextAtOffset(anchorOffset);\n        var offset = anchorNode.getOffset(anchorText.key);\n        anchorOffset = anchorOffset - offset;\n        anchorNode = anchorText;\n      }\n\n      // If the focus node isn't a text node, match it to one.\n      if (focusNode.kind != 'text') {\n        (0, _warn2.default)('The selection focus was set to a Node that is not a Text node. This should not happen and can degrade performance. The node in question was:', focusNode);\n        var focusText = focusNode.getTextAtOffset(focusOffset);\n        var _offset = focusNode.getOffset(focusText.key);\n        focusOffset = focusOffset - _offset;\n        focusNode = focusText;\n      }\n\n      // If `isBackward` is not set, derive it.\n      if (isBackward == null) {\n        if (anchorNode.key === focusNode.key) {\n          isBackward = anchorOffset > focusOffset;\n        } else {\n          isBackward = !node.areDescendantsSorted(anchorNode.key, focusNode.key);\n        }\n      }\n\n      // Merge in any updated properties.\n      return selection.merge({\n        anchorKey: anchorNode.key,\n        anchorOffset: anchorOffset,\n        focusKey: focusNode.key,\n        focusOffset: focusOffset,\n        isBackward: isBackward\n      });\n    }\n\n    /**\n     * Unset the selection.\n     *\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'unset',\n    value: function unset() {\n      (0, _warn2.default)('The `Selection.unset` method is deprecated, please switch to using `Selection.deselect` instead.');\n      return this.deselect();\n    }\n\n    /**\n     * Move the selection forward `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveForward',\n    value: function moveForward() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      (0, _warn2.default)('The `Selection.moveForward(n)` method is deprecated, please switch to using `Selection.move(n)` instead.');\n      return this.move(n);\n    }\n\n    /**\n     * Move the selection backward `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveBackward',\n    value: function moveBackward() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      (0, _warn2.default)('The `Selection.moveBackward(n)` method is deprecated, please switch to using `Selection.move(-n)` (with a negative number) instead.');\n      return this.move(0 - n);\n    }\n\n    /**\n     * Move the anchor offset `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveAnchorOffset',\n    value: function moveAnchorOffset() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      (0, _warn2.default)('The `Selection.moveAnchorOffset(n)` method is deprecated, please switch to using `Selection.moveAnchor(n)` instead.');\n      return this.moveAnchor(n);\n    }\n\n    /**\n     * Move the focus offset `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveFocusOffset',\n    value: function moveFocusOffset() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      (0, _warn2.default)('The `Selection.moveFocusOffset(n)` method is deprecated, please switch to using `Selection.moveFocus(n)` instead.');\n      return this.moveFocus(n);\n    }\n\n    /**\n     * Move the start offset `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveStartOffset',\n    value: function moveStartOffset() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      (0, _warn2.default)('The `Selection.moveStartOffset(n)` method is deprecated, please switch to using `Selection.moveStart(n)` instead.');\n      return this.moveStart(n);\n    }\n\n    /**\n     * Move the focus offset `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveEndOffset',\n    value: function moveEndOffset() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      (0, _warn2.default)('The `Selection.moveEndOffset(n)` method is deprecated, please switch to using `Selection.moveEnd(n)` instead.');\n      return this.moveEnd(n);\n    }\n\n    /**\n     * Extend the focus point forward `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'extendForward',\n    value: function extendForward() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      (0, _warn2.default)('The `Selection.extendForward(n)` method is deprecated, please switch to using `Selection.extend(n)` instead.');\n      return this.extend(n);\n    }\n\n    /**\n     * Extend the focus point backward `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'extendBackward',\n    value: function extendBackward() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      (0, _warn2.default)('The `Selection.extendBackward(n)` method is deprecated, please switch to using `Selection.extend(-n)` (with a negative number) instead.');\n      return this.extend(0 - n);\n    }\n\n    /**\n     * Move the selection to `anchorOffset` and `focusOffset`.\n     *\n     * @param {Number} anchorOffset\n     * @param {Number} focusOffset (optional)\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'moveToOffsets',\n    value: function moveToOffsets(anchorOffset) {\n      var focusOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : anchorOffset;\n\n      (0, _warn2.default)('The `Selection.moveToOffsets` method is deprecated, please switch to using `Selection.moveOffsetsTo` instead.');\n      return this.moveOffsetsTo(anchorOffset, focusOffset);\n    }\n  }, {\n    key: 'kind',\n\n\n    /**\n     * Get the kind.\n     *\n     * @return {String}\n     */\n\n    get: function get() {\n      return 'selection';\n    }\n\n    /**\n     * Check whether the selection is blurred.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBlurred',\n    get: function get() {\n      return !this.isFocused;\n    }\n\n    /**\n     * Check whether the selection is collapsed.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isCollapsed',\n    get: function get() {\n      return this.anchorKey == this.focusKey && this.anchorOffset == this.focusOffset;\n    }\n\n    /**\n     * Check whether the selection is expanded.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isExpanded',\n    get: function get() {\n      return !this.isCollapsed;\n    }\n\n    /**\n     * Check whether the selection is forward.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isForward',\n    get: function get() {\n      return this.isBackward == null ? null : !this.isBackward;\n    }\n\n    /**\n     * Check whether the selection's keys are set.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isSet',\n    get: function get() {\n      return this.anchorKey != null && this.focusKey != null;\n    }\n\n    /**\n     * Check whether the selection's keys are not set.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isUnset',\n    get: function get() {\n      return !this.isSet;\n    }\n\n    /**\n     * Get the start key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'startKey',\n    get: function get() {\n      return this.isBackward ? this.focusKey : this.anchorKey;\n    }\n\n    /**\n     * Get the start offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'startOffset',\n    get: function get() {\n      return this.isBackward ? this.focusOffset : this.anchorOffset;\n    }\n\n    /**\n     * Get the end key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'endKey',\n    get: function get() {\n      return this.isBackward ? this.anchorKey : this.focusKey;\n    }\n\n    /**\n     * Get the end offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'endOffset',\n    get: function get() {\n      return this.isBackward ? this.anchorOffset : this.focusOffset;\n    }\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Create a new `Selection` with `properties`.\n     *\n     * @param {Object|Selection} properties\n     * @return {Selection}\n     */\n\n    value: function create() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (properties instanceof Selection) return properties;\n      return new Selection(properties);\n    }\n  }]);\n\n  return Selection;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Mix in some \"move\" convenience methods.\n */\n\nvar MOVE_METHODS = [['move', ''], ['move', 'To'], ['move', 'ToStartOf'], ['move', 'ToEndOf']];\n\nMOVE_METHODS.forEach(function (_ref2) {\n  var _ref3 = _slicedToArray(_ref2, 2),\n      p = _ref3[0],\n      s = _ref3[1];\n\n  Selection.prototype['' + p + s] = function () {\n    var _ref4;\n\n    return (_ref4 = this[p + 'Anchor' + s].apply(this, arguments))[p + 'Focus' + s].apply(_ref4, arguments);\n  };\n});\n\n/**\n * Mix in the \"start\", \"end\" and \"edge\" convenience methods.\n */\n\nvar EDGE_METHODS = [['has', 'AtStartOf', true], ['has', 'AtEndOf', true], ['has', 'Between', true], ['has', 'In', true], ['collapseTo', ''], ['move', ''], ['moveTo', ''], ['move', 'To'], ['move', 'OffsetTo']];\n\nEDGE_METHODS.forEach(function (_ref5) {\n  var _ref6 = _slicedToArray(_ref5, 3),\n      p = _ref6[0],\n      s = _ref6[1],\n      hasEdge = _ref6[2];\n\n  var anchor = p + 'Anchor' + s;\n  var focus = p + 'Focus' + s;\n\n  Selection.prototype[p + 'Start' + s] = function () {\n    return this.isBackward ? this[focus].apply(this, arguments) : this[anchor].apply(this, arguments);\n  };\n\n  Selection.prototype[p + 'End' + s] = function () {\n    return this.isBackward ? this[anchor].apply(this, arguments) : this[focus].apply(this, arguments);\n  };\n\n  if (hasEdge) {\n    Selection.prototype[p + 'Edge' + s] = function () {\n      return this[anchor].apply(this, arguments) || this[focus].apply(this, arguments);\n    };\n  }\n});\n\n/**\n * Mix in some aliases for convenience / parallelism with the browser APIs.\n */\n\nvar ALIAS_METHODS = [['collapseTo', 'moveTo'], ['collapseToAnchor', 'moveToAnchor'], ['collapseToFocus', 'moveToFocus'], ['collapseToStart', 'moveToStart'], ['collapseToEnd', 'moveToEnd'], ['collapseToStartOf', 'moveToStartOf'], ['collapseToEndOf', 'moveToEndOf'], ['extend', 'moveFocus'], ['extendTo', 'moveFocusTo'], ['extendToStartOf', 'moveFocusToStartOf'], ['extendToEndOf', 'moveFocusToEndOf']];\n\nALIAS_METHODS.forEach(function (_ref7) {\n  var _ref8 = _slicedToArray(_ref7, 2),\n      alias = _ref8[0],\n      method = _ref8[1];\n\n  Selection.prototype[alias] = function () {\n    return this[method].apply(this, arguments);\n  };\n});\n\n/**\n * Get the first text of a `node`.\n *\n * @param {Node} node\n * @return {Text}\n */\n\nfunction getFirst(node) {\n  return node.kind == 'text' ? node : node.getFirstText();\n}\n\n/**\n * Get the last text of a `node`.\n *\n * @param {Node} node\n * @return {Text}\n */\n\nfunction getLast(node) {\n  return node.kind == 'text' ? node : node.getLastText();\n}\n\n/**\n * Export.\n *\n * @type {Selection}\n */\n\nexports.default = Selection;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/warn.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _isDev = require('../constants/is-dev');\n\nvar _isDev2 = _interopRequireDefault(_isDev);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Log a development warning.\n *\n * @param {String} message\n * @param {Any} ...args\n */\n\nfunction warn(message) {\n  if (!_isDev2.default) {\n    return;\n  }\n\n  if (typeof console !== 'undefined') {\n    var _console;\n\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    (_console = console).warn.apply(_console, ['Warning: ' + message].concat(args)); // eslint-disable-line no-console\n  }\n\n  try {\n    // --- Welcome to debugging Slate! ---\n    // This error was thrown as a convenience so that you can use this stack\n    // to find the callsite that caused this warning to fire.\n    throw new Error(message);\n  } catch (x) {\n    // This error is only for debugging.\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = warn;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/models/text.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _character = require('./character');\n\nvar _character2 = _interopRequireDefault(_character);\n\nvar _mark = require('./mark');\n\nvar _mark2 = _interopRequireDefault(_mark);\n\nvar _range = require('./range');\n\nvar _range2 = _interopRequireDefault(_range);\n\nvar _memoize = require('../utils/memoize');\n\nvar _memoize2 = _interopRequireDefault(_memoize);\n\nvar _generateKey = require('../utils/generate-key');\n\nvar _generateKey2 = _interopRequireDefault(_generateKey);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  characters: new _immutable.List(),\n  key: null\n};\n\n/**\n * Text.\n *\n * @type {Text}\n */\n\nvar Text = function (_ref) {\n  _inherits(Text, _ref);\n\n  function Text() {\n    _classCallCheck(this, Text);\n\n    return _possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).apply(this, arguments));\n  }\n\n  _createClass(Text, [{\n    key: 'addMark',\n\n\n    /**\n     * Add a `mark` at `index` and `length`.\n     *\n     * @param {Number} index\n     * @param {Number} length\n     * @param {Mark} mark\n     * @return {Text}\n     */\n\n    value: function addMark(index, length, mark) {\n      var characters = this.characters.map(function (char, i) {\n        if (i < index) return char;\n        if (i >= index + length) return char;\n        var _char = char,\n            marks = _char.marks;\n\n        marks = marks.add(mark);\n        char = char.set('marks', marks);\n        return char;\n      });\n\n      return this.set('characters', characters);\n    }\n\n    /**\n     * Derive a set of decorated characters with `decorators`.\n     *\n     * @param {Array} decorators\n     * @return {List<Character>}\n     */\n\n  }, {\n    key: 'getDecorations',\n    value: function getDecorations(decorators) {\n      var node = this;\n      var characters = node.characters;\n\n      if (characters.size == 0) return characters;\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = decorators[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var decorator = _step.value;\n\n          var decorateds = decorator(node);\n          characters = characters.merge(decorateds);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return characters;\n    }\n\n    /**\n     * Get the decorations for the node from a `schema`.\n     *\n     * @param {Schema} schema\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getDecorators',\n    value: function getDecorators(schema) {\n      return schema.__getDecorators(this);\n    }\n\n    /**\n     * Get all of the marks on the text.\n     *\n     * @return {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getMarks',\n    value: function getMarks() {\n      return this.characters.reduce(function (marks, char) {\n        return marks.union(char.marks);\n      }, new _immutable.OrderedSet());\n    }\n\n    /**\n     * Get the marks on the text at `index`.\n     *\n     * @param {Number} index\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getMarksAtIndex',\n    value: function getMarksAtIndex(index) {\n      if (index == 0) return _mark2.default.createSet();\n      var characters = this.characters;\n\n      var char = characters.get(index - 1);\n      if (!char) return _mark2.default.createSet();\n      return char.marks;\n    }\n\n    /**\n     * Get a node by `key`, to parallel other nodes.\n     *\n     * @param {String} key\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNode',\n    value: function getNode(key) {\n      return this.key == key ? this : null;\n    }\n\n    /**\n     * Derive the ranges for a list of `characters`.\n     *\n     * @param {Array|Void} decorators (optional)\n     * @return {List<Range>}\n     */\n\n  }, {\n    key: 'getRanges',\n    value: function getRanges() {\n      var decorators = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      var characters = this.getDecorations(decorators);\n      var ranges = [];\n\n      // PERF: cache previous values for faster lookup.\n      var prevChar = void 0;\n      var prevRange = void 0;\n\n      // If there are no characters, return one empty range.\n      if (characters.size == 0) {\n        ranges.push({});\n      }\n\n      // Otherwise, loop the characters and build the ranges...\n      else {\n          characters.forEach(function (char, i) {\n            var marks = char.marks,\n                text = char.text;\n\n            // The first one can always just be created.\n\n            if (i == 0) {\n              prevChar = char;\n              prevRange = { text: text, marks: marks };\n              ranges.push(prevRange);\n              return;\n            }\n\n            // Otherwise, compare the current and previous marks.\n            var prevMarks = prevChar.marks;\n            var isSame = (0, _immutable.is)(marks, prevMarks);\n\n            // If the marks are the same, add the text to the previous range.\n            if (isSame) {\n              prevChar = char;\n              prevRange.text += text;\n              return;\n            }\n\n            // Otherwise, create a new range.\n            prevChar = char;\n            prevRange = { text: text, marks: marks };\n            ranges.push(prevRange);\n          }, []);\n        }\n\n      // PERF: convert the ranges to immutable objects after iterating.\n      ranges = new _immutable.List(ranges.map(function (object) {\n        return new _range2.default(object);\n      }));\n\n      // Return the ranges.\n      return ranges;\n    }\n\n    /**\n     * Check if the node has a node by `key`, to parallel other nodes.\n     *\n     * @param {String} key\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasNode',\n    value: function hasNode(key) {\n      return !!this.getNode(key);\n    }\n\n    /**\n     * Insert `text` at `index`.\n     *\n     * @param {Numbder} index\n     * @param {String} text\n     * @param {String} marks (optional)\n     * @return {Text}\n     */\n\n  }, {\n    key: 'insertText',\n    value: function insertText(index, text, marks) {\n      marks = marks || this.getMarksAtIndex(index);\n      var characters = this.characters;\n\n      var chars = _character2.default.createListFromText(text, marks);\n\n      characters = characters.slice(0, index).concat(chars).concat(characters.slice(index));\n\n      return this.set('characters', characters);\n    }\n\n    /**\n     * Regenerate the node's key.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'regenerateKey',\n    value: function regenerateKey() {\n      var key = (0, _generateKey2.default)();\n      return this.set('key', key);\n    }\n\n    /**\n     * Remove a `mark` at `index` and `length`.\n     *\n     * @param {Number} index\n     * @param {Number} length\n     * @param {Mark} mark\n     * @return {Text}\n     */\n\n  }, {\n    key: 'removeMark',\n    value: function removeMark(index, length, mark) {\n      var characters = this.characters.map(function (char, i) {\n        if (i < index) return char;\n        if (i >= index + length) return char;\n        var _char2 = char,\n            marks = _char2.marks;\n\n        marks = marks.remove(mark);\n        char = char.set('marks', marks);\n        return char;\n      });\n\n      return this.set('characters', characters);\n    }\n\n    /**\n     * Remove text from the text node at `index` for `length`.\n     *\n     * @param {Number} index\n     * @param {Number} length\n     * @return {Text}\n     */\n\n  }, {\n    key: 'removeText',\n    value: function removeText(index, length) {\n      var characters = this.characters;\n\n      var start = index;\n      var end = index + length;\n      characters = characters.filterNot(function (char, i) {\n        return start <= i && i < end;\n      });\n      return this.set('characters', characters);\n    }\n\n    /**\n     * Update a `mark` at `index` and `length` with `properties`.\n     *\n     * @param {Number} index\n     * @param {Number} length\n     * @param {Mark} mark\n     * @param {Mark} newMark\n     * @return {Text}\n     */\n\n  }, {\n    key: 'updateMark',\n    value: function updateMark(index, length, mark, newMark) {\n      var characters = this.characters.map(function (char, i) {\n        if (i < index) return char;\n        if (i >= index + length) return char;\n        var _char3 = char,\n            marks = _char3.marks;\n\n        if (!marks.has(mark)) return char;\n        marks = marks.remove(mark);\n        marks = marks.add(newMark);\n        char = char.set('marks', marks);\n        return char;\n      });\n\n      return this.set('characters', characters);\n    }\n\n    /**\n     * Validate the text node against a `schema`.\n     *\n     * @param {Schema} schema\n     * @return {Object|Void}\n     */\n\n  }, {\n    key: 'validate',\n    value: function validate(schema) {\n      return schema.__validate(this);\n    }\n  }, {\n    key: 'kind',\n\n\n    /**\n     * Get the node's kind.\n     *\n     * @return {String}\n     */\n\n    get: function get() {\n      return 'text';\n    }\n\n    /**\n     * Is the node empty?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get() {\n      return this.text == '';\n    }\n\n    /**\n     * Get the length of the concatenated text of the node.\n     *\n     * @return {Number}\n     */\n\n  }, {\n    key: 'length',\n    get: function get() {\n      return this.text.length;\n    }\n\n    /**\n     * Get the concatenated text of the node.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'text',\n    get: function get() {\n      return this.characters.reduce(function (string, char) {\n        return string + char.text;\n      }, '');\n    }\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Create a new `Text` with `properties`.\n     *\n     * @param {Object|Text} properties\n     * @return {Text}\n     */\n\n    value: function create() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (properties instanceof Text) return properties;\n      properties.key = properties.key || (0, _generateKey2.default)();\n      properties.characters = _character2.default.createList(properties.characters);\n      return new Text(properties);\n    }\n\n    /**\n     * Create a new `Text` from a string\n     *\n     * @param {String} text\n     * @param {Set<Mark>} marks (optional)\n     * @return {Text}\n     */\n\n  }, {\n    key: 'createFromString',\n    value: function createFromString(text) {\n      var marks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, _immutable.Set)();\n\n      return Text.createFromRanges([_range2.default.create({ text: text, marks: marks })]);\n    }\n\n    /**\n     * Create a new `Text` from a list of ranges\n     *\n     * @param {List<Range>|Array<Range>} ranges\n     * @return {Text}\n     */\n\n  }, {\n    key: 'createFromRanges',\n    value: function createFromRanges(ranges) {\n      return Text.create({\n        characters: ranges.reduce(function (characters, range) {\n          range = _range2.default.create(range);\n          return characters.concat(range.getCharacters());\n        }, _character2.default.createList())\n      });\n    }\n\n    /**\n     * Create a list of `Texts` from an array.\n     *\n     * @param {Array} elements\n     * @return {List<Text>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (_immutable.List.isList(elements)) return elements;\n      return new _immutable.List(elements.map(Text.create));\n    }\n  }]);\n\n  return Text;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Memoize read methods.\n */\n\n(0, _memoize2.default)(Text.prototype, ['getDecorations', 'getDecorators', 'getMarksAtIndex', 'getRanges', 'validate']);\n\n/**\n * Export.\n *\n * @type {Text}\n */\n\nexports.default = Text;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/models/character.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mark = require('./mark');\n\nvar _mark2 = _interopRequireDefault(_mark);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  marks: new _immutable.Set(),\n  text: ''\n};\n\n/**\n * Character.\n *\n * @type {Character}\n */\n\nvar Character = function (_ref) {\n  _inherits(Character, _ref);\n\n  function Character() {\n    _classCallCheck(this, Character);\n\n    return _possibleConstructorReturn(this, (Character.__proto__ || Object.getPrototypeOf(Character)).apply(this, arguments));\n  }\n\n  _createClass(Character, [{\n    key: 'kind',\n\n\n    /**\n     * Get the kind.\n     *\n     * @return {String}\n     */\n\n    get: function get() {\n      return 'character';\n    }\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Create a character record with `properties`.\n     *\n     * @param {Object|Character} properties\n     * @return {Character}\n     */\n\n    value: function create() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (properties instanceof Character) return properties;\n      properties.marks = _mark2.default.createSet(properties.marks);\n      return new Character(properties);\n    }\n\n    /**\n     * Create a characters list from an array of characters.\n     *\n     * @param {Array<Object|Character>} array\n     * @return {List<Character>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (_immutable.List.isList(array)) return array;\n      return new _immutable.List(array.map(Character.create));\n    }\n\n    /**\n     * Create a characters list from a `string` and optional `marks`.\n     *\n     * @param {String} string\n     * @param {Set<Mark>} marks (optional)\n     * @return {List<Character>}\n     */\n\n  }, {\n    key: 'createListFromText',\n    value: function createListFromText(string, marks) {\n      var chars = string.split('').map(function (text) {\n        return { text: text, marks: marks };\n      });\n      var list = Character.createList(chars);\n      return list;\n    }\n  }]);\n\n  return Character;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Export.\n *\n * @type {Character}\n */\n\nexports.default = Character;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/models/range.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _character = require('./character');\n\nvar _character2 = _interopRequireDefault(_character);\n\nvar _mark = require('./mark');\n\nvar _mark2 = _interopRequireDefault(_mark);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  marks: new _immutable.Set(),\n  text: ''\n};\n\n/**\n * Range.\n *\n * @type {Range}\n */\n\nvar Range = function (_ref) {\n  _inherits(Range, _ref);\n\n  function Range() {\n    _classCallCheck(this, Range);\n\n    return _possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).apply(this, arguments));\n  }\n\n  _createClass(Range, [{\n    key: 'getCharacters',\n\n\n    /**\n     * Return range as a list of characters\n     *\n     * @return {List<Character>}\n     */\n\n    value: function getCharacters() {\n      var marks = this.marks;\n\n\n      return _character2.default.createList(this.text.split('').map(function (char) {\n        return _character2.default.create({\n          text: char,\n          marks: marks\n        });\n      }));\n    }\n  }, {\n    key: 'kind',\n\n\n    /**\n     * Get the node's kind.\n     *\n     * @return {String}\n     */\n\n    get: function get() {\n      return 'range';\n    }\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Create a new `Range` with `properties`.\n     *\n     * @param {Object|Range} properties\n     * @return {Range}\n     */\n\n    value: function create() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (properties instanceof Range) return properties;\n      properties.text = properties.text;\n      properties.marks = _mark2.default.createSet(properties.marks);\n      return new Range(properties);\n    }\n  }]);\n\n  return Range;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Export.\n *\n * @type {Range}\n */\n\nexports.default = Range;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/generate-key.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * An auto-incrementing index for generating keys.\n *\n * @type {Number}\n */\n\nvar n = void 0;\n\n/**\n * The global key generating function.\n *\n * @type {Function}\n */\n\nvar generate = void 0;\n\n/**\n * Generate a key.\n *\n * @return {String}\n */\n\nfunction generateKey() {\n  return generate();\n}\n\n/**\n * Set a different unique ID generating `function`.\n *\n * @param {Function} func\n */\n\nfunction setKeyGenerator(func) {\n  generate = func;\n}\n\n/**\n * Reset the key generating function to its initial state.\n */\n\nfunction resetKeyGenerator() {\n  n = 0;\n  generate = function generate() {\n    return \"\" + n++;\n  };\n}\n\n/**\n * Set the initial state.\n */\n\nresetKeyGenerator();\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = generateKey;\nexports.setKeyGenerator = setKeyGenerator;\nexports.resetKeyGenerator = resetKeyGenerator;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/is-in-range.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Check if an `index` of a `text` node is in a `range`.\n *\n * @param {Number} index\n * @param {Text} text\n * @param {Selection} range\n * @return {Boolean}\n */\n\nfunction isInRange(index, text, range) {\n  var startKey = range.startKey,\n      startOffset = range.startOffset,\n      endKey = range.endKey,\n      endOffset = range.endOffset;\n\n\n  if (text.key == startKey && text.key == endKey) {\n    return startOffset <= index && index < endOffset;\n  } else if (text.key == startKey) {\n    return startOffset <= index;\n  } else if (text.key == endKey) {\n    return index < endOffset;\n  } else {\n    return true;\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = isInRange;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/models/state.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _document = require('./document');\n\nvar _document2 = _interopRequireDefault(_document);\n\nvar _core = require('../schemas/core');\n\nvar _core2 = _interopRequireDefault(_core);\n\nvar _selection = require('./selection');\n\nvar _selection2 = _interopRequireDefault(_selection);\n\nvar _transform = require('./transform');\n\nvar _transform2 = _interopRequireDefault(_transform);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * History.\n *\n * @type {History}\n */\n\nvar History = new _immutable.Record({\n  undos: new _immutable.Stack(),\n  redos: new _immutable.Stack()\n});\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  document: new _document2.default(),\n  selection: new _selection2.default(),\n  history: new History(),\n  isNative: false\n};\n\n/**\n * State.\n *\n * @type {State}\n */\n\nvar State = function (_ref) {\n  _inherits(State, _ref);\n\n  function State() {\n    _classCallCheck(this, State);\n\n    return _possibleConstructorReturn(this, (State.__proto__ || Object.getPrototypeOf(State)).apply(this, arguments));\n  }\n\n  _createClass(State, [{\n    key: 'transform',\n\n\n    /**\n     * Return a new `Transform` with the current state as a starting point.\n     *\n     * @param {Object} properties\n     * @return {Transform}\n     */\n\n    value: function transform() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var state = this;\n      return new _transform2.default(_extends({}, properties, {\n        state: state\n      }));\n    }\n  }, {\n    key: 'kind',\n\n\n    /**\n     * Get the kind.\n     *\n     * @return {String}\n     */\n\n    get: function get() {\n      return 'state';\n    }\n\n    /**\n     * Are there undoable events?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasUndos',\n    get: function get() {\n      return this.history.undos.size > 0;\n    }\n\n    /**\n     * Are there redoable events?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasRedos',\n    get: function get() {\n      return this.history.redos.size > 0;\n    }\n\n    /**\n     * Is the current selection blurred?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBlurred',\n    get: function get() {\n      return this.selection.isBlurred;\n    }\n\n    /**\n     * Is the current selection focused?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isFocused',\n    get: function get() {\n      return this.selection.isFocused;\n    }\n\n    /**\n     * Is the current selection collapsed?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isCollapsed',\n    get: function get() {\n      return this.selection.isCollapsed;\n    }\n\n    /**\n     * Is the current selection expanded?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isExpanded',\n    get: function get() {\n      return this.selection.isExpanded;\n    }\n\n    /**\n     * Is the current selection backward?\n     *\n     * @return {Boolean} isBackward\n     */\n\n  }, {\n    key: 'isBackward',\n    get: function get() {\n      return this.selection.isBackward;\n    }\n\n    /**\n     * Is the current selection forward?\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isForward',\n    get: function get() {\n      return this.selection.isForward;\n    }\n\n    /**\n     * Get the current start key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'startKey',\n    get: function get() {\n      return this.selection.startKey;\n    }\n\n    /**\n     * Get the current end key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'endKey',\n    get: function get() {\n      return this.selection.endKey;\n    }\n\n    /**\n     * Get the current start offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'startOffset',\n    get: function get() {\n      return this.selection.startOffset;\n    }\n\n    /**\n     * Get the current end offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'endOffset',\n    get: function get() {\n      return this.selection.endOffset;\n    }\n\n    /**\n     * Get the current anchor key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'anchorKey',\n    get: function get() {\n      return this.selection.anchorKey;\n    }\n\n    /**\n     * Get the current focus key.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'focusKey',\n    get: function get() {\n      return this.selection.focusKey;\n    }\n\n    /**\n     * Get the current anchor offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'anchorOffset',\n    get: function get() {\n      return this.selection.anchorOffset;\n    }\n\n    /**\n     * Get the current focus offset.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'focusOffset',\n    get: function get() {\n      return this.selection.focusOffset;\n    }\n\n    /**\n     * Get the current start text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'startBlock',\n    get: function get() {\n      return this.document.getClosestBlock(this.selection.startKey);\n    }\n\n    /**\n     * Get the current end text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'endBlock',\n    get: function get() {\n      return this.document.getClosestBlock(this.selection.endKey);\n    }\n\n    /**\n     * Get the current anchor text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'anchorBlock',\n    get: function get() {\n      return this.document.getClosestBlock(this.selection.anchorKey);\n    }\n\n    /**\n     * Get the current focus text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'focusBlock',\n    get: function get() {\n      return this.document.getClosestBlock(this.selection.focusKey);\n    }\n\n    /**\n     * Get the current start text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'startInline',\n    get: function get() {\n      return this.document.getClosestInline(this.selection.startKey);\n    }\n\n    /**\n     * Get the current end text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'endInline',\n    get: function get() {\n      return this.document.getClosestInline(this.selection.endKey);\n    }\n\n    /**\n     * Get the current anchor text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'anchorInline',\n    get: function get() {\n      return this.document.getClosestInline(this.selection.anchorKey);\n    }\n\n    /**\n     * Get the current focus text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'focusInline',\n    get: function get() {\n      return this.document.getClosestInline(this.selection.focusKey);\n    }\n\n    /**\n     * Get the current start text node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'startText',\n    get: function get() {\n      return this.document.getDescendant(this.selection.startKey);\n    }\n\n    /**\n     * Get the current end node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'endText',\n    get: function get() {\n      return this.document.getDescendant(this.selection.endKey);\n    }\n\n    /**\n     * Get the current anchor node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'anchorText',\n    get: function get() {\n      return this.document.getDescendant(this.selection.anchorKey);\n    }\n\n    /**\n     * Get the current focus node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'focusText',\n    get: function get() {\n      return this.document.getDescendant(this.selection.focusKey);\n    }\n\n    /**\n     * Get the characters in the current selection.\n     *\n     * @return {List<Character>}\n     */\n\n  }, {\n    key: 'characters',\n    get: function get() {\n      return this.document.getCharactersAtRange(this.selection);\n    }\n\n    /**\n     * Get the marks of the current selection.\n     *\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'marks',\n    get: function get() {\n      return this.selection.isUnset ? new _immutable.Set() : this.selection.marks || this.document.getMarksAtRange(this.selection);\n    }\n\n    /**\n     * Get the block nodes in the current selection.\n     *\n     * @return {List<Block>}\n     */\n\n  }, {\n    key: 'blocks',\n    get: function get() {\n      return this.selection.isUnset ? new _immutable.List() : this.document.getBlocksAtRange(this.selection);\n    }\n\n    /**\n     * Get the fragment of the current selection.\n     *\n     * @return {Document}\n     */\n\n  }, {\n    key: 'fragment',\n    get: function get() {\n      return this.selection.isUnset ? _document2.default.create() : this.document.getFragmentAtRange(this.selection);\n    }\n\n    /**\n     * Get the inline nodes in the current selection.\n     *\n     * @return {List<Inline>}\n     */\n\n  }, {\n    key: 'inlines',\n    get: function get() {\n      return this.selection.isUnset ? new _immutable.List() : this.document.getInlinesAtRange(this.selection);\n    }\n\n    /**\n     * Get the text nodes in the current selection.\n     *\n     * @return {List<Text>}\n     */\n\n  }, {\n    key: 'texts',\n    get: function get() {\n      return this.selection.isUnset ? new _immutable.List() : this.document.getTextsAtRange(this.selection);\n    }\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Create a new `State` with `properties`.\n     *\n     * @param {Object|State} properties\n     * @param {Object} options\n     *   @property {Boolean} normalize\n     * @return {State}\n     */\n\n    value: function create() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (properties instanceof State) return properties;\n\n      var document = _document2.default.create(properties.document);\n      var selection = _selection2.default.create(properties.selection);\n\n      if (selection.isUnset) {\n        var text = document.getFirstText();\n        selection = selection.collapseToStartOf(text);\n      }\n\n      var state = new State({ document: document, selection: selection });\n\n      return options.normalize === false ? state : state.transform().normalize(_core2.default).apply({ save: false });\n    }\n  }]);\n\n  return State;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Export.\n */\n\nexports.default = State;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/schemas/core.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _schema = require('../models/schema');\n\nvar _schema2 = _interopRequireDefault(_schema);\n\nvar _text = require('../models/text');\n\nvar _text2 = _interopRequireDefault(_text);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Options object with normalize set to `false`.\n *\n * @type {Object}\n */\n\nvar OPTS = { normalize: false };\n\n/**\n * Define the core schema rules, order-sensitive.\n *\n * @type {Array}\n */\n\nvar rules = [\n\n/**\n * Only allow block nodes in documents.\n *\n * @type {Object}\n */\n\n{\n  match: function match(node) {\n    return node.kind == 'document';\n  },\n  validate: function validate(document) {\n    var invalids = document.nodes.filter(function (n) {\n      return n.kind != 'block';\n    });\n    return invalids.size ? invalids : null;\n  },\n  normalize: function normalize(transform, document, invalids) {\n    invalids.forEach(function (node) {\n      transform.removeNodeByKey(node.key, OPTS);\n    });\n  }\n},\n\n/**\n * Only allow block, inline and text nodes in blocks.\n *\n * @type {Object}\n */\n\n{\n  match: function match(node) {\n    return node.kind == 'block';\n  },\n  validate: function validate(block) {\n    var invalids = block.nodes.filter(function (n) {\n      return n.kind != 'block' && n.kind != 'inline' && n.kind != 'text';\n    });\n\n    return invalids.size ? invalids : null;\n  },\n  normalize: function normalize(transform, block, invalids) {\n    invalids.forEach(function (node) {\n      transform.removeNodeByKey(node.key, OPTS);\n    });\n  }\n},\n\n/**\n * Only allow inline and text nodes in inlines.\n *\n * @type {Object}\n */\n\n{\n  match: function match(object) {\n    return object.kind == 'inline';\n  },\n  validate: function validate(inline) {\n    var invalids = inline.nodes.filter(function (n) {\n      return n.kind != 'inline' && n.kind != 'text';\n    });\n    return invalids.size ? invalids : null;\n  },\n  normalize: function normalize(transform, inline, invalids) {\n    invalids.forEach(function (node) {\n      transform.removeNodeByKey(node.key, OPTS);\n    });\n  }\n},\n\n/**\n * Ensure that block and inline nodes have at least one text child.\n *\n * @type {Object}\n */\n\n{\n  match: function match(object) {\n    return object.kind == 'block' || object.kind == 'inline';\n  },\n  validate: function validate(node) {\n    return node.nodes.size == 0;\n  },\n  normalize: function normalize(transform, node) {\n    var text = _text2.default.create();\n    transform.insertNodeByKey(node.key, 0, text, OPTS);\n  }\n},\n\n/**\n * Ensure that void nodes contain a text node with a single space of text.\n *\n * @type {Object}\n */\n\n{\n  match: function match(object) {\n    return (object.kind == 'inline' || object.kind == 'block') && object.isVoid;\n  },\n  validate: function validate(node) {\n    return node.text !== ' ' || node.nodes.size !== 1;\n  },\n  normalize: function normalize(transform, node, result) {\n    var text = _text2.default.createFromString(' ');\n    var index = node.nodes.size;\n\n    transform.insertNodeByKey(node.key, index, text, OPTS);\n\n    node.nodes.forEach(function (child) {\n      transform.removeNodeByKey(child.key, OPTS);\n    });\n  }\n},\n\n/**\n * Ensure that inline nodes are never empty.\n *\n * This rule is applied to all blocks, because when they contain an empty\n * inline, we need to remove the inline from that parent block. If `validate`\n * was to be memoized, it should be against the parent node, not the inline\n * themselves.\n *\n * @type {Object}\n */\n\n{\n  match: function match(object) {\n    return object.kind == 'block';\n  },\n  validate: function validate(block) {\n    var invalids = block.nodes.filter(function (n) {\n      return n.kind == 'inline' && n.text == '';\n    });\n    return invalids.size ? invalids : null;\n  },\n  normalize: function normalize(transform, block, invalids) {\n    // If all of the block's nodes are invalid, insert an empty text node so\n    // that the selection will be preserved when they are all removed.\n    if (block.nodes.size == invalids.size) {\n      var text = _text2.default.create();\n      transform.insertNodeByKey(block.key, 1, text, OPTS);\n    }\n\n    invalids.forEach(function (node) {\n      transform.removeNodeByKey(node.key, OPTS);\n    });\n  }\n},\n\n/**\n * Ensure that inline void nodes are surrounded by text nodes, by adding extra\n * blank text nodes if necessary.\n *\n * @type {Object}\n */\n\n{\n  match: function match(object) {\n    return object.kind == 'block' || object.kind == 'inline';\n  },\n  validate: function validate(node) {\n    var invalids = node.nodes.reduce(function (list, child, index) {\n      if (child.kind !== 'inline') return list;\n\n      var prev = index > 0 ? node.nodes.get(index - 1) : null;\n      var next = node.nodes.get(index + 1);\n      // We don't test if \"prev\" is inline, since it has already been processed in the loop\n      var insertBefore = !prev;\n      var insertAfter = !next || next.kind == 'inline';\n\n      if (insertAfter || insertBefore) {\n        list = list.push({ insertAfter: insertAfter, insertBefore: insertBefore, index: index });\n      }\n\n      return list;\n    }, new _immutable.List());\n\n    return invalids.size ? invalids : null;\n  },\n  normalize: function normalize(transform, block, invalids) {\n    // Shift for every text node inserted previously.\n    var shift = 0;\n\n    invalids.forEach(function (_ref) {\n      var index = _ref.index,\n          insertAfter = _ref.insertAfter,\n          insertBefore = _ref.insertBefore;\n\n      if (insertBefore) {\n        transform.insertNodeByKey(block.key, shift + index, _text2.default.create(), OPTS);\n        shift++;\n      }\n\n      if (insertAfter) {\n        transform.insertNodeByKey(block.key, shift + index + 1, _text2.default.create(), OPTS);\n        shift++;\n      }\n    });\n  }\n},\n\n/**\n * Join adjacent text nodes.\n *\n * @type {Object}\n */\n\n{\n  match: function match(object) {\n    return object.kind == 'block' || object.kind == 'inline';\n  },\n  validate: function validate(node) {\n    var invalids = node.nodes.map(function (child, i) {\n      var next = node.nodes.get(i + 1);\n      if (child.kind != 'text') return;\n      if (!next || next.kind != 'text') return;\n      return [child, next];\n    }).filter(Boolean);\n\n    return invalids.size ? invalids : null;\n  },\n  normalize: function normalize(transform, node, pairs) {\n    // We reverse the list to handle consecutive joins, since the earlier nodes\n    // will always exist after each join.\n    pairs.reverse().forEach(function (pair) {\n      var _pair = _slicedToArray(pair, 2),\n          first = _pair[0],\n          second = _pair[1];\n\n      return transform.joinNodeByKey(second.key, first.key, OPTS);\n    });\n  }\n},\n\n/**\n * Prevent extra empty text nodes, except when adjacent to inline void nodes.\n *\n * @type {Object}\n */\n\n{\n  match: function match(object) {\n    return object.kind == 'block' || object.kind == 'inline';\n  },\n  validate: function validate(node) {\n    var nodes = node.nodes;\n\n    if (nodes.size <= 1) return;\n\n    var invalids = nodes.filter(function (desc, i) {\n      if (desc.kind != 'text') return;\n      if (desc.length > 0) return;\n\n      var prev = i > 0 ? nodes.get(i - 1) : null;\n      var next = nodes.get(i + 1);\n\n      // If it's the first node, and the next is a void, preserve it.\n      if (!prev && next.kind == 'inline') return;\n\n      // It it's the last node, and the previous is an inline, preserve it.\n      if (!next && prev.kind == 'inline') return;\n\n      // If it's surrounded by inlines, preserve it.\n      if (next && prev && next.kind == 'inline' && prev.kind == 'inline') return;\n\n      // Otherwise, remove it.\n      return true;\n    });\n\n    return invalids.size ? invalids : null;\n  },\n  normalize: function normalize(transform, node, invalids) {\n    invalids.forEach(function (text) {\n      transform.removeNodeByKey(text.key, OPTS);\n    });\n  }\n}];\n\n/**\n * Create the core schema.\n *\n * @type {Schema}\n */\n\nvar SCHEMA = _schema2.default.create({ rules: rules });\n\n/**\n * Export.\n *\n * @type {Schema}\n */\n\nexports.default = SCHEMA;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/models/schema.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _isReactComponent = require('../utils/is-react-component');\n\nvar _isReactComponent2 = _interopRequireDefault(_isReactComponent);\n\nvar _typeOf = require('type-of');\n\nvar _typeOf2 = _interopRequireDefault(_typeOf);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  rules: []\n};\n\n/**\n * Schema.\n *\n * @type {Schema}\n */\n\nvar Schema = function (_ref) {\n  _inherits(Schema, _ref);\n\n  function Schema() {\n    _classCallCheck(this, Schema);\n\n    return _possibleConstructorReturn(this, (Schema.__proto__ || Object.getPrototypeOf(Schema)).apply(this, arguments));\n  }\n\n  _createClass(Schema, [{\n    key: '__getComponent',\n\n\n    /**\n     * Return the renderer for an `object`.\n     *\n     * This method is private, because it should always be called on one of the\n     * often-changing immutable objects instead, since it will be memoized for\n     * much better performance.\n     *\n     * @param {Mixed} object\n     * @return {Component|Void}\n     */\n\n    value: function __getComponent(object) {\n      var match = this.rules.find(function (rule) {\n        return rule.render && rule.match(object);\n      });\n      if (!match) return;\n      return match.render;\n    }\n\n    /**\n     * Return the decorators for an `object`.\n     *\n     * This method is private, because it should always be called on one of the\n     * often-changing immutable objects instead, since it will be memoized for\n     * much better performance.\n     *\n     * @param {Mixed} object\n     * @return {Array}\n     */\n\n  }, {\n    key: '__getDecorators',\n    value: function __getDecorators(object) {\n      return this.rules.filter(function (rule) {\n        return rule.decorate && rule.match(object);\n      }).map(function (rule) {\n        return function (text) {\n          return rule.decorate(text, object);\n        };\n      });\n    }\n\n    /**\n     * Validate an `object` against the schema, returning the failing rule and\n     * value if the object is invalid, or void if it's valid.\n     *\n     * This method is private, because it should always be called on one of the\n     * often-changing immutable objects instead, since it will be memoized for\n     * much better performance.\n     *\n     * @param {Mixed} object\n     * @return {Object|Void}\n     */\n\n  }, {\n    key: '__validate',\n    value: function __validate(object) {\n      var value = void 0;\n\n      var match = this.rules.find(function (rule) {\n        if (!rule.validate) return;\n        if (!rule.match(object)) return;\n\n        value = rule.validate(object);\n        return value;\n      });\n\n      if (!value) return;\n\n      return {\n        rule: match,\n        value: value\n      };\n    }\n  }, {\n    key: 'kind',\n\n\n    /**\n     * Get the kind.\n     *\n     * @return {String}\n     */\n\n    get: function get() {\n      return 'schema';\n    }\n\n    /**\n     * Return true if one rule can normalize the document\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasValidators',\n    get: function get() {\n      var rules = this.rules;\n\n      return rules.some(function (rule) {\n        return rule.validate;\n      });\n    }\n\n    /**\n     * Return true if one rule can decorate text nodes\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasDecorators',\n    get: function get() {\n      var rules = this.rules;\n\n      return rules.some(function (rule) {\n        return rule.decorate;\n      });\n    }\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Create a new `Schema` with `properties`.\n     *\n     * @param {Object|Schema} properties\n     * @return {Schema}\n     */\n\n    value: function create() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (properties instanceof Schema) return properties;\n      return new Schema(normalizeProperties(properties));\n    }\n  }]);\n\n  return Schema;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Normalize the `properties` of a schema.\n *\n * @param {Object} properties\n * @return {Object}\n */\n\nfunction normalizeProperties(properties) {\n  var _properties$rules = properties.rules,\n      rules = _properties$rules === undefined ? [] : _properties$rules,\n      nodes = properties.nodes,\n      marks = properties.marks;\n\n\n  if (nodes) {\n    var array = normalizeNodes(nodes);\n    rules = rules.concat(array);\n  }\n\n  if (marks) {\n    var _array = normalizeMarks(marks);\n    rules = rules.concat(_array);\n  }\n\n  return { rules: rules };\n}\n\n/**\n * Normalize a `nodes` shorthand argument.\n *\n * @param {Object} nodes\n * @return {Array}\n */\n\nfunction normalizeNodes(nodes) {\n  var rules = [];\n\n  var _loop = function _loop(key) {\n    var rule = nodes[key];\n\n    if ((0, _typeOf2.default)(rule) == 'function' || (0, _isReactComponent2.default)(rule)) {\n      rule = { render: rule };\n    }\n\n    rule.match = function (object) {\n      return (object.kind == 'block' || object.kind == 'inline') && object.type == key;\n    };\n\n    rules.push(rule);\n  };\n\n  for (var key in nodes) {\n    _loop(key);\n  }\n\n  return rules;\n}\n\n/**\n * Normalize a `marks` shorthand argument.\n *\n * @param {Object} marks\n * @return {Array}\n */\n\nfunction normalizeMarks(marks) {\n  var rules = [];\n\n  var _loop2 = function _loop2(key) {\n    var rule = marks[key];\n\n    if (!rule.render && !rule.decorator && !rule.validate) {\n      rule = { render: rule };\n    }\n\n    rule.render = normalizeMarkComponent(rule.render);\n    rule.match = function (object) {\n      return object.kind == 'mark' && object.type == key;\n    };\n    rules.push(rule);\n  };\n\n  for (var key in marks) {\n    _loop2(key);\n  }\n\n  return rules;\n}\n\n/**\n * Normalize a mark `render` property.\n *\n * @param {Component|Function|Object|String} render\n * @return {Component}\n */\n\nfunction normalizeMarkComponent(render) {\n  if ((0, _isReactComponent2.default)(render)) return render;\n\n  switch ((0, _typeOf2.default)(render)) {\n    case 'function':\n      return render;\n    case 'object':\n      return function (props) {\n        return _react2.default.createElement(\n          'span',\n          { style: render },\n          props.children\n        );\n      };\n    case 'string':\n      return function (props) {\n        return _react2.default.createElement(\n          'span',\n          { className: render },\n          props.children\n        );\n      };\n  }\n}\n\n/**\n * Export.\n *\n * @type {Schema}\n */\n\nexports.default = Schema;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/is-react-component.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Check if an `object` is a React component.\n *\n * @param {Object} object\n * @return {Boolean}\n */\n\nfunction isReactComponent(object) {\n  return object && object.prototype && object.prototype.isReactComponent;\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = isReactComponent;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/models/transform.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _transforms = require('../transforms');\n\nvar _transforms2 = _interopRequireDefault(_transforms);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = (0, _debug2.default)('slate:transform');\n\n/**\n * Transform.\n *\n * @type {Transform}\n */\n\nvar Transform = function () {\n\n  /**\n   * Constructor.\n   *\n   * @param {Object} properties\n   *   @property {State} state\n   */\n\n  function Transform(properties) {\n    _classCallCheck(this, Transform);\n\n    var state = properties.state;\n\n    this.state = state;\n    this.operations = [];\n  }\n\n  /**\n   * Get the kind.\n   *\n   * @return {String}\n   */\n\n  _createClass(Transform, [{\n    key: 'apply',\n\n\n    /**\n     * Apply the transform and return the new state.\n     *\n     * @param {Object} options\n     *   @property {Boolean} isNative\n     *   @property {Boolean} merge\n     *   @property {Boolean} save\n     * @return {State}\n     */\n\n    value: function apply() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var transform = this;\n      var merge = options.merge,\n          save = options.save,\n          _options$isNative = options.isNative,\n          isNative = _options$isNative === undefined ? false : _options$isNative;\n\n      // Ensure that the selection is normalized.\n\n      transform.normalizeSelection();\n\n      var state = transform.state,\n          operations = transform.operations;\n      var history = state.history;\n      var undos = history.undos;\n\n      var previous = undos.peek();\n\n      // If there are no operations, abort early.\n      if (!operations.length) return state;\n\n      // If there's a previous save point, determine if the new operations should\n      // be merged into the previous ones.\n      if (previous && merge == null) {\n        merge = isOnlySelections(operations) || isContiguousInserts(operations, previous) || isContiguousRemoves(operations, previous);\n      }\n\n      // If the save flag isn't set, determine whether we should save.\n      if (save == null) {\n        save = !isOnlySelections(operations);\n      }\n\n      // Save the new operations.\n      if (save) this.save({ merge: merge });\n\n      // Return the new state with the `isNative` flag set.\n      return this.state.set('isNative', !!isNative);\n    }\n  }, {\n    key: 'kind',\n    get: function get() {\n      return 'transform';\n    }\n  }]);\n\n  return Transform;\n}();\n\n/**\n * Add a transform method for each of the transforms.\n */\n\nObject.keys(_transforms2.default).forEach(function (type) {\n  Transform.prototype[type] = function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    debug(type, { args: args });\n    _transforms2.default[type].apply(_transforms2.default, [this].concat(args));\n    return this;\n  };\n});\n\n/**\n * Check whether a list of `operations` only contains selection operations.\n *\n * @param {Array} operations\n * @return {Boolean}\n */\n\nfunction isOnlySelections(operations) {\n  return operations.every(function (op) {\n    return op.type == 'set_selection';\n  });\n}\n\n/**\n * Check whether a list of `operations` and a list of `previous` operations are\n * contiguous text insertions.\n *\n * @param {Array} operations\n * @param {Array} previous\n */\n\nfunction isContiguousInserts(operations, previous) {\n  var edits = operations.filter(function (op) {\n    return op.type != 'set_selection';\n  });\n  var prevEdits = previous.filter(function (op) {\n    return op.type != 'set_selection';\n  });\n  if (!edits.length || !prevEdits.length) return false;\n\n  var onlyInserts = edits.every(function (op) {\n    return op.type == 'insert_text';\n  });\n  var prevOnlyInserts = prevEdits.every(function (op) {\n    return op.type == 'insert_text';\n  });\n  if (!onlyInserts || !prevOnlyInserts) return false;\n\n  var first = edits[0];\n  var last = prevEdits[prevEdits.length - 1];\n  if (first.key != last.key) return false;\n  if (first.offset != last.offset + last.text.length) return false;\n\n  return true;\n}\n\n/**\n * Check whether a list of `operations` and a list of `previous` operations are\n * contiguous text removals.\n *\n * @param {Array} operations\n * @param {Array} previous\n */\n\nfunction isContiguousRemoves(operations, previous) {\n  var edits = operations.filter(function (op) {\n    return op.type != 'set_selection';\n  });\n  var prevEdits = previous.filter(function (op) {\n    return op.type != 'set_selection';\n  });\n  if (!edits.length || !prevEdits.length) return false;\n\n  var onlyRemoves = edits.every(function (op) {\n    return op.type == 'remove_text';\n  });\n  var prevOnlyRemoves = prevEdits.every(function (op) {\n    return op.type == 'remove_text';\n  });\n  if (!onlyRemoves || !prevOnlyRemoves) return false;\n\n  var first = edits[0];\n  var last = prevEdits[prevEdits.length - 1];\n  if (first.key != last.key) return false;\n  if (first.offset + first.length != last.offset) return false;\n\n  return true;\n}\n\n/**\n * Export.\n *\n * @type {Transform}\n */\n\nexports.default = Transform;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/transforms/index.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _applyOperation = require('./apply-operation');\n\nvar _applyOperation2 = _interopRequireDefault(_applyOperation);\n\nvar _atCurrentRange = require('./at-current-range');\n\nvar _atCurrentRange2 = _interopRequireDefault(_atCurrentRange);\n\nvar _atRange = require('./at-range');\n\nvar _atRange2 = _interopRequireDefault(_atRange);\n\nvar _byKey = require('./by-key');\n\nvar _byKey2 = _interopRequireDefault(_byKey);\n\nvar _call = require('./call');\n\nvar _call2 = _interopRequireDefault(_call);\n\nvar _normalize = require('./normalize');\n\nvar _normalize2 = _interopRequireDefault(_normalize);\n\nvar _onHistory = require('./on-history');\n\nvar _onHistory2 = _interopRequireDefault(_onHistory);\n\nvar _onSelection = require('./on-selection');\n\nvar _onSelection2 = _interopRequireDefault(_onSelection);\n\nvar _operations = require('./operations');\n\nvar _operations2 = _interopRequireDefault(_operations);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = _extends({}, _applyOperation2.default, _atCurrentRange2.default, _atRange2.default, _byKey2.default, _call2.default, _normalize2.default, _onHistory2.default, _onSelection2.default, _operations2.default);","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/transforms/apply-operation.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _warn = require('../utils/warn');\n\nvar _warn2 = _interopRequireDefault(_warn);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = (0, _debug2.default)('slate:operation');\n\n/**\n * Transforms.\n *\n * @type {Object}\n */\n\nvar Transforms = {};\n\n/**\n * Operations.\n *\n * @type {Object}\n */\n\nvar OPERATIONS = {\n  // Text operations.\n  insert_text: insertText,\n  remove_text: removeText,\n  // Mark operations.\n  add_mark: addMark,\n  remove_mark: removeMark,\n  set_mark: setMark,\n  // Node operations.\n  insert_node: insertNode,\n  join_node: joinNode,\n  move_node: moveNode,\n  remove_node: removeNode,\n  set_node: setNode,\n  split_node: splitNode,\n  // Selection operations.\n  set_selection: setSelection\n};\n\n/**\n * Apply an `operation` to the current state.\n *\n * @param {Transform} transform\n * @param {Object} operation\n */\n\nTransforms.applyOperation = function (transform, operation) {\n  var state = transform.state,\n      operations = transform.operations;\n  var type = operation.type;\n\n  var fn = OPERATIONS[type];\n\n  if (!fn) {\n    throw new Error('Unknown operation type: \"' + type + '\".');\n  }\n\n  debug(type, operation);\n  transform.state = fn(state, operation);\n  transform.operations = operations.concat([operation]);\n};\n\n/**\n * Add mark to text at `offset` and `length` in node by `path`.\n *\n * @param {State} state\n * @param {Object} operation\n * @return {State}\n */\n\nfunction addMark(state, operation) {\n  var path = operation.path,\n      offset = operation.offset,\n      length = operation.length,\n      mark = operation.mark;\n  var _state = state,\n      document = _state.document;\n\n  var node = document.assertPath(path);\n  node = node.addMark(offset, length, mark);\n  document = document.updateDescendant(node);\n  state = state.set('document', document);\n  return state;\n}\n\n/**\n * Insert a `node` at `index` in a node by `path`.\n *\n * @param {State} state\n * @param {Object} operation\n * @return {State}\n */\n\nfunction insertNode(state, operation) {\n  var path = operation.path,\n      index = operation.index,\n      node = operation.node;\n  var _state2 = state,\n      document = _state2.document;\n\n  var parent = document.assertPath(path);\n  var isParent = document == parent;\n  parent = parent.insertNode(index, node);\n  document = isParent ? parent : document.updateDescendant(parent);\n  state = state.set('document', document);\n  return state;\n}\n\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {State} state\n * @param {Object} operation\n * @return {State}\n */\n\nfunction insertText(state, operation) {\n  var path = operation.path,\n      offset = operation.offset,\n      text = operation.text,\n      marks = operation.marks;\n  var _state3 = state,\n      document = _state3.document,\n      selection = _state3.selection;\n  var _selection = selection,\n      anchorKey = _selection.anchorKey,\n      focusKey = _selection.focusKey,\n      anchorOffset = _selection.anchorOffset,\n      focusOffset = _selection.focusOffset;\n\n  var node = document.assertPath(path);\n\n  // Update the document\n  node = node.insertText(offset, text, marks);\n  document = document.updateDescendant(node);\n\n  // Update the selection\n  if (anchorKey == node.key && anchorOffset >= offset) {\n    selection = selection.moveAnchor(text.length);\n  }\n  if (focusKey == node.key && focusOffset >= offset) {\n    selection = selection.moveFocus(text.length);\n  }\n\n  state = state.set('document', document).set('selection', selection);\n  return state;\n}\n\n/**\n * Join a node by `path` with a node `withPath`.\n *\n * @param {State} state\n * @param {Object} operation\n *   @param {Boolean} operation.deep (optional) Join recursively the\n *   respective last node and first node of the nodes' children. Like a zipper :)\n * @return {State}\n */\n\nfunction joinNode(state, operation) {\n  var path = operation.path,\n      withPath = operation.withPath,\n      _operation$deep = operation.deep,\n      deep = _operation$deep === undefined ? false : _operation$deep;\n  var _state4 = state,\n      document = _state4.document,\n      selection = _state4.selection;\n\n  var first = document.assertPath(withPath);\n  var second = document.assertPath(path);\n\n  document = document.joinNode(first, second, { deep: deep });\n\n  // If the operation is deep, or the nodes are text nodes, it means we will be\n  // merging two text nodes together, so we need to update the selection.\n  if (deep || second.kind == 'text') {\n    var _selection2 = selection,\n        anchorKey = _selection2.anchorKey,\n        anchorOffset = _selection2.anchorOffset,\n        focusKey = _selection2.focusKey,\n        focusOffset = _selection2.focusOffset;\n\n    var firstText = first.kind == 'text' ? first : first.getLastText();\n    var secondText = second.kind == 'text' ? second : second.getFirstText();\n\n    if (anchorKey == secondText.key) {\n      selection = selection.merge({\n        anchorKey: firstText.key,\n        anchorOffset: anchorOffset + firstText.characters.size\n      });\n    }\n\n    if (focusKey == secondText.key) {\n      selection = selection.merge({\n        focusKey: firstText.key,\n        focusOffset: focusOffset + firstText.characters.size\n      });\n    }\n  }\n\n  state = state.set('document', document).set('selection', selection);\n  return state;\n}\n\n/**\n * Move a node by `path` to a new parent by `path` and `index`.\n *\n * @param {State} state\n * @param {Object} operation\n * @return {State}\n */\n\nfunction moveNode(state, operation) {\n  var path = operation.path,\n      newPath = operation.newPath,\n      newIndex = operation.newIndex;\n  var _state5 = state,\n      document = _state5.document;\n\n  var node = document.assertPath(path);\n\n  // Remove the node from its current parent\n  var parent = document.getParent(node.key);\n  var isParent = document == parent;\n  var index = parent.nodes.indexOf(node);\n  parent = parent.removeNode(index);\n  document = isParent ? parent : document.updateDescendant(parent);\n\n  // Insert the new node to its new parent\n  var target = document.assertPath(newPath);\n  var isTarget = document == target;\n  target = target.insertNode(newIndex, node);\n  document = isTarget ? target : document.updateDescendant(target);\n\n  state = state.set('document', document);\n  return state;\n}\n\n/**\n * Remove mark from text at `offset` and `length` in node by `path`.\n *\n * @param {State} state\n * @param {Object} operation\n * @return {State}\n */\n\nfunction removeMark(state, operation) {\n  var path = operation.path,\n      offset = operation.offset,\n      length = operation.length,\n      mark = operation.mark;\n  var _state6 = state,\n      document = _state6.document;\n\n  var node = document.assertPath(path);\n  node = node.removeMark(offset, length, mark);\n  document = document.updateDescendant(node);\n  state = state.set('document', document);\n  return state;\n}\n\n/**\n * Remove a node by `path`.\n *\n * @param {State} state\n * @param {Object} operation\n * @return {State}\n */\n\nfunction removeNode(state, operation) {\n  var path = operation.path;\n  var _state7 = state,\n      document = _state7.document,\n      selection = _state7.selection;\n  var _selection3 = selection,\n      startKey = _selection3.startKey,\n      endKey = _selection3.endKey;\n\n  var node = document.assertPath(path);\n\n  // If the selection is set, check to see if it needs to be updated.\n  if (selection.isSet) {\n    var hasStartNode = node.hasNode(startKey);\n    var hasEndNode = node.hasNode(endKey);\n\n    // If one of the selection's nodes is being removed, we need to update it.\n    if (hasStartNode) {\n      var prev = document.getPreviousText(startKey);\n      var next = document.getNextText(startKey);\n\n      if (prev) {\n        selection = selection.moveStartTo(prev.key, prev.length);\n      } else if (next) {\n        selection = selection.moveStartTo(next.key, 0);\n      } else {\n        selection = selection.deselect();\n      }\n    }\n\n    if (hasEndNode) {\n      var _prev = document.getPreviousText(endKey);\n      var _next = document.getNextText(endKey);\n\n      if (_prev) {\n        selection = selection.moveEndTo(_prev.key, _prev.length);\n      } else if (_next) {\n        selection = selection.moveEndTo(_next.key, 0);\n      } else {\n        selection = selection.deselect();\n      }\n    }\n  }\n\n  // Remove the node from the document.\n  var parent = document.getParent(node.key);\n  var index = parent.nodes.indexOf(node);\n  var isParent = document == parent;\n  parent = parent.removeNode(index);\n  document = isParent ? parent : document.updateDescendant(parent);\n\n  // Update the document and selection.\n  state = state.set('document', document).set('selection', selection);\n  return state;\n}\n\n/**\n * Remove text at `offset` and `length` in node by `path`.\n *\n * @param {State} state\n * @param {Object} operation\n * @return {State}\n */\n\nfunction removeText(state, operation) {\n  var path = operation.path,\n      offset = operation.offset,\n      length = operation.length;\n\n  var rangeOffset = offset + length;\n  var _state8 = state,\n      document = _state8.document,\n      selection = _state8.selection;\n  var _selection4 = selection,\n      anchorKey = _selection4.anchorKey,\n      focusKey = _selection4.focusKey,\n      anchorOffset = _selection4.anchorOffset,\n      focusOffset = _selection4.focusOffset;\n\n  var node = document.assertPath(path);\n\n  // Update the selection\n  if (anchorKey == node.key && anchorOffset >= rangeOffset) {\n    selection = selection.moveAnchor(-length);\n  }\n  if (focusKey == node.key && focusOffset >= rangeOffset) {\n    selection = selection.moveFocus(-length);\n  }\n\n  node = node.removeText(offset, length);\n  document = document.updateDescendant(node);\n  state = state.set('document', document).set('selection', selection);\n  return state;\n}\n\n/**\n * Set `properties` on mark on text at `offset` and `length` in node by `path`.\n *\n * @param {State} state\n * @param {Object} operation\n * @return {State}\n */\n\nfunction setMark(state, operation) {\n  var path = operation.path,\n      offset = operation.offset,\n      length = operation.length,\n      mark = operation.mark,\n      newMark = operation.newMark;\n  var _state9 = state,\n      document = _state9.document;\n\n  var node = document.assertPath(path);\n  node = node.updateMark(offset, length, mark, newMark);\n  document = document.updateDescendant(node);\n  state = state.set('document', document);\n  return state;\n}\n\n/**\n * Set `properties` on a node by `path`.\n *\n * @param {State} state\n * @param {Object} operation\n * @return {State}\n */\n\nfunction setNode(state, operation) {\n  var path = operation.path,\n      properties = operation.properties;\n  var _state10 = state,\n      document = _state10.document;\n\n  var node = document.assertPath(path);\n\n  // Deprecate the ability to overwite a node's children.\n  if (properties.nodes && properties.nodes != node.nodes) {\n    (0, _warn2.default)('Updating a Node\\'s `nodes` property via `setNode()` is not allowed. Use the appropriate insertion and removal operations instead. The opeartion in question was:', operation);\n    delete properties.nodes;\n  }\n\n  // Deprecate the ability to change a node's key.\n  if (properties.key && properties.key != node.key) {\n    (0, _warn2.default)('Updating a Node\\'s `key` property via `setNode()` is not allowed. There should be no reason to do this. The opeartion in question was:', operation);\n    delete properties.key;\n  }\n\n  node = node.merge(properties);\n  document = node.kind === 'document' ? node : document.updateDescendant(node);\n  state = state.set('document', document);\n  return state;\n}\n\n/**\n * Set `properties` on the selection.\n *\n * @param {State} state\n * @param {Object} operation\n * @return {State}\n */\n\nfunction setSelection(state, operation) {\n  var properties = _extends({}, operation.properties);\n  var _state11 = state,\n      document = _state11.document,\n      selection = _state11.selection;\n\n\n  if (properties.anchorPath !== undefined) {\n    properties.anchorKey = properties.anchorPath === null ? null : document.assertPath(properties.anchorPath).key;\n    delete properties.anchorPath;\n  }\n\n  if (properties.focusPath !== undefined) {\n    properties.focusKey = properties.focusPath === null ? null : document.assertPath(properties.focusPath).key;\n    delete properties.focusPath;\n  }\n\n  selection = selection.merge(properties);\n  selection = selection.normalize(document);\n  state = state.set('selection', selection);\n  return state;\n}\n\n/**\n * Split a node by `path` at `offset`.\n *\n * @param {State} state\n * @param {Object} operation\n *   @param {Array} operation.path The path of the node to split\n *   @param {Number} operation.offset (optional) Split using a relative offset\n *   @param {Number} operation.count (optional) Split after `count`\n *   children. Cannot be used in combination with offset.\n * @return {State}\n */\n\nfunction splitNode(state, operation) {\n  var path = operation.path,\n      offset = operation.offset,\n      count = operation.count;\n  var _state12 = state,\n      document = _state12.document,\n      selection = _state12.selection;\n\n  // If there's no offset, it's using the `count` instead.\n\n  if (offset == null) {\n    document = document.splitNodeAfter(path, count);\n    state = state.set('document', document);\n    return state;\n  }\n\n  // Otherwise, split using the `offset`, but calculate a few things first.\n  var node = document.assertPath(path);\n  var text = node.kind == 'text' ? node : node.getTextAtOffset(offset);\n  var textOffset = node.kind == 'text' ? offset : offset - node.getOffset(text.key);\n  var _selection5 = selection,\n      anchorKey = _selection5.anchorKey,\n      anchorOffset = _selection5.anchorOffset,\n      focusKey = _selection5.focusKey,\n      focusOffset = _selection5.focusOffset;\n\n\n  document = document.splitNode(path, offset);\n\n  // Determine whether we need to update the selection.\n  var splitAnchor = text.key == anchorKey && textOffset <= anchorOffset;\n  var splitFocus = text.key == focusKey && textOffset <= focusOffset;\n\n  // If either the anchor of focus was after the split, we need to update them.\n  if (splitFocus || splitAnchor) {\n    var nextText = document.getNextText(text.key);\n\n    if (splitAnchor) {\n      selection = selection.merge({\n        anchorKey: nextText.key,\n        anchorOffset: anchorOffset - textOffset\n      });\n    }\n\n    if (splitFocus) {\n      selection = selection.merge({\n        focusKey: nextText.key,\n        focusOffset: focusOffset - textOffset\n      });\n    }\n  }\n\n  state = state.set('document', document).set('selection', selection);\n  return state;\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Transforms;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/transforms/at-current-range.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _normalize = require('../utils/normalize');\n\nvar _normalize2 = _interopRequireDefault(_normalize);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Transforms.\n *\n * @type {Object}\n */\n\nvar Transforms = {};\n\n/**\n * Add a `mark` to the characters in the current selection.\n *\n * @param {Transform} transform\n * @param {Mark} mark\n */\n\nTransforms.addMark = function (transform, mark) {\n  mark = _normalize2.default.mark(mark);\n  var state = transform.state;\n  var document = state.document,\n      selection = state.selection;\n\n\n  if (selection.isExpanded) {\n    transform.addMarkAtRange(selection, mark);\n    return;\n  }\n\n  if (selection.marks) {\n    var _marks = selection.marks.add(mark);\n    var _sel = selection.set('marks', _marks);\n    transform.select(_sel);\n    return;\n  }\n\n  var marks = document.getMarksAtRange(selection).add(mark);\n  var sel = selection.set('marks', marks);\n  transform.select(sel);\n};\n\n/**\n * Delete at the current selection.\n *\n * @param {Transform} transform\n */\n\nTransforms.delete = function (transform) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  if (selection.isCollapsed) return;\n\n  transform.snapshotSelection().deleteAtRange(selection)\n  // Ensure that the selection is collapsed to the start, because in certain\n  // cases when deleting across inline nodes this isn't guaranteed.\n  .collapseToStart().snapshotSelection();\n};\n\n/**\n * Delete backward `n` characters at the current selection.\n *\n * @param {Transform} transform\n * @param {Number} n (optional)\n */\n\nTransforms.deleteBackward = function (transform) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.deleteBackwardAtRange(selection, n);\n};\n\n/**\n * Delete backward until the character boundary at the current selection.\n *\n * @param {Transform} transform\n */\n\nTransforms.deleteCharBackward = function (transform) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.deleteCharBackwardAtRange(selection);\n};\n\n/**\n * Delete backward until the line boundary at the current selection.\n *\n * @param {Transform} transform\n */\n\nTransforms.deleteLineBackward = function (transform) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.deleteLineBackwardAtRange(selection);\n};\n\n/**\n * Delete backward until the word boundary at the current selection.\n *\n * @param {Transform} transform\n */\n\nTransforms.deleteWordBackward = function (transform) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.deleteWordBackwardAtRange(selection);\n};\n\n/**\n * Delete forward `n` characters at the current selection.\n *\n * @param {Transform} transform\n * @param {Number} n (optional)\n */\n\nTransforms.deleteForward = function (transform) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.deleteForwardAtRange(selection, n);\n};\n\n/**\n * Delete forward until the character boundary at the current selection.\n *\n * @param {Transform} transform\n */\n\nTransforms.deleteCharForward = function (transform) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.deleteCharForwardAtRange(selection);\n};\n\n/**\n * Delete forward until the line boundary at the current selection.\n *\n * @param {Transform} transform\n */\n\nTransforms.deleteLineForward = function (transform) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.deleteLineForwardAtRange(selection);\n};\n\n/**\n * Delete forward until the word boundary at the current selection.\n *\n * @param {Transform} transform\n */\n\nTransforms.deleteWordForward = function (transform) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.deleteWordForwardAtRange(selection);\n};\n\n/**\n * Insert a `block` at the current selection.\n *\n * @param {Transform} transform\n * @param {String|Object|Block} block\n */\n\nTransforms.insertBlock = function (transform, block) {\n  block = _normalize2.default.block(block);\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.insertBlockAtRange(selection, block);\n\n  // If the node was successfully inserted, update the selection.\n  var node = transform.state.document.getNode(block.key);\n  if (node) transform.collapseToEndOf(node);\n};\n\n/**\n * Insert a `fragment` at the current selection.\n *\n * @param {Transform} transform\n * @param {Document} fragment\n */\n\nTransforms.insertFragment = function (transform, fragment) {\n  var state = transform.state;\n  var _state = state,\n      document = _state.document,\n      selection = _state.selection;\n\n\n  if (!fragment.length) return;\n\n  var _state2 = state,\n      startText = _state2.startText,\n      endText = _state2.endText;\n\n  var lastText = fragment.getLastText();\n  var lastInline = fragment.getClosestInline(lastText.key);\n  var keys = document.getTexts().map(function (text) {\n    return text.key;\n  });\n  var isAppending = selection.hasEdgeAtEndOf(endText) || selection.hasEdgeAtStartOf(startText);\n\n  transform.deselect();\n  transform.insertFragmentAtRange(selection, fragment);\n  state = transform.state;\n  document = state.document;\n\n  var newTexts = document.getTexts().filter(function (n) {\n    return !keys.includes(n.key);\n  });\n  var newText = isAppending ? newTexts.last() : newTexts.takeLast(2).first();\n  var after = void 0;\n\n  if (newText && lastInline) {\n    after = selection.collapseToEndOf(newText);\n  } else if (newText) {\n    after = selection.collapseToStartOf(newText).move(lastText.length);\n  } else {\n    after = selection.collapseToStart().move(lastText.length);\n  }\n\n  transform.select(after);\n};\n\n/**\n * Insert a `inline` at the current selection.\n *\n * @param {Transform} transform\n * @param {String|Object|Block} inline\n */\n\nTransforms.insertInline = function (transform, inline) {\n  inline = _normalize2.default.inline(inline);\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.insertInlineAtRange(selection, inline);\n\n  // If the node was successfully inserted, update the selection.\n  var node = transform.state.document.getNode(inline.key);\n  if (node) transform.collapseToEndOf(node);\n};\n\n/**\n * Insert a `text` string at the current selection.\n *\n * @param {Transform} transform\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nTransforms.insertText = function (transform, text, marks) {\n  var state = transform.state;\n  var document = state.document,\n      selection = state.selection;\n\n  marks = marks || selection.marks;\n  transform.insertTextAtRange(selection, text, marks);\n\n  // If the text was successfully inserted, and the selection had marks on it,\n  // unset the selection's marks.\n  if (selection.marks && document != transform.state.document) {\n    transform.select({ marks: null });\n  }\n};\n\n/**\n * Set `properties` of the block nodes in the current selection.\n *\n * @param {Transform} transform\n * @param {Object} properties\n */\n\nTransforms.setBlock = function (transform, properties) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.setBlockAtRange(selection, properties);\n};\n\n/**\n * Set `properties` of the inline nodes in the current selection.\n *\n * @param {Transform} transform\n * @param {Object} properties\n */\n\nTransforms.setInline = function (transform, properties) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.setInlineAtRange(selection, properties);\n};\n\n/**\n * Split the block node at the current selection, to optional `depth`.\n *\n * @param {Transform} transform\n * @param {Number} depth (optional)\n */\n\nTransforms.splitBlock = function (transform) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.snapshotSelection().splitBlockAtRange(selection, depth).collapseToEnd().snapshotSelection();\n};\n\n/**\n * Split the inline nodes at the current selection, to optional `depth`.\n *\n * @param {Transform} transform\n * @param {Number} depth (optional)\n */\n\nTransforms.splitInline = function (transform) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.snapshotSelection().splitInlineAtRange(selection, depth).snapshotSelection();\n};\n\n/**\n * Remove a `mark` from the characters in the current selection.\n *\n * @param {Transform} transform\n * @param {Mark} mark\n */\n\nTransforms.removeMark = function (transform, mark) {\n  mark = _normalize2.default.mark(mark);\n  var state = transform.state;\n  var document = state.document,\n      selection = state.selection;\n\n\n  if (selection.isExpanded) {\n    transform.removeMarkAtRange(selection, mark);\n    return;\n  }\n\n  if (selection.marks) {\n    var _marks2 = selection.marks.remove(mark);\n    var _sel2 = selection.set('marks', _marks2);\n    transform.select(_sel2);\n    return;\n  }\n\n  var marks = document.getMarksAtRange(selection).remove(mark);\n  var sel = selection.set('marks', marks);\n  transform.select(sel);\n};\n\n/**\n * Add or remove a `mark` from the characters in the current selection,\n * depending on whether it's already there.\n *\n * @param {Transform} transform\n * @param {Mark} mark\n */\n\nTransforms.toggleMark = function (transform, mark) {\n  mark = _normalize2.default.mark(mark);\n  var state = transform.state;\n\n  var exists = state.marks.some(function (m) {\n    return m.equals(mark);\n  });\n\n  if (exists) {\n    transform.removeMark(mark);\n  } else {\n    transform.addMark(mark);\n  }\n};\n\n/**\n * Unwrap the current selection from a block parent with `properties`.\n *\n * @param {Transform} transform\n * @param {Object|String} properties\n */\n\nTransforms.unwrapBlock = function (transform, properties) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.unwrapBlockAtRange(selection, properties);\n};\n\n/**\n * Unwrap the current selection from an inline parent with `properties`.\n *\n * @param {Transform} transform\n * @param {Object|String} properties\n */\n\nTransforms.unwrapInline = function (transform, properties) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.unwrapInlineAtRange(selection, properties);\n};\n\n/**\n * Wrap the block nodes in the current selection with a new block node with\n * `properties`.\n *\n * @param {Transform} transform\n * @param {Object|String} properties\n */\n\nTransforms.wrapBlock = function (transform, properties) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.wrapBlockAtRange(selection, properties);\n};\n\n/**\n * Wrap the current selection in new inline nodes with `properties`.\n *\n * @param {Transform} transform\n * @param {Object|String} properties\n */\n\nTransforms.wrapInline = function (transform, properties) {\n  var state = transform.state;\n  var _state3 = state,\n      document = _state3.document,\n      selection = _state3.selection;\n\n  var after = void 0;\n\n  var startKey = selection.startKey;\n\n  var previous = document.getPreviousText(startKey);\n\n  transform.deselect();\n  transform.wrapInlineAtRange(selection, properties);\n  state = transform.state;\n  document = state.document;\n\n  // Determine what the selection should be after wrapping.\n  if (selection.isCollapsed) {\n    after = selection;\n  } else if (selection.startOffset == 0) {\n    var text = previous ? document.getNextText(previous.key) : document.getFirstText();\n    after = selection.moveToRangeOf(text);\n  } else if (selection.startKey == selection.endKey) {\n    var _text = document.getNextText(selection.startKey);\n    after = selection.moveToRangeOf(_text);\n  } else {\n    var anchor = document.getNextText(selection.anchorKey);\n    var focus = document.getDescendant(selection.focusKey);\n    after = selection.merge({\n      anchorKey: anchor.key,\n      anchorOffset: 0,\n      focusKey: focus.key,\n      focusOffset: selection.focusOffset\n    });\n  }\n\n  after = after.normalize(document);\n  transform.select(after);\n};\n\n/**\n * Wrap the current selection with prefix/suffix.\n *\n * @param {Transform} transform\n * @param {String} prefix\n * @param {String} suffix\n */\n\nTransforms.wrapText = function (transform, prefix) {\n  var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : prefix;\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.wrapTextAtRange(selection, prefix, suffix);\n\n  // If the selection was collapsed, it will have moved the start offset too.\n  if (selection.isCollapsed) {\n    transform.moveStart(0 - prefix.length);\n  }\n\n  // Adding the suffix will have pushed the end of the selection further on, so\n  // we need to move it back to account for this.\n  transform.moveEnd(0 - suffix.length);\n\n  // There's a chance that the selection points moved \"through\" each other,\n  // resulting in a now-incorrect selection direction.\n  if (selection.isForward != transform.state.selection.isForward) {\n    transform.flip();\n  }\n};\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Transforms;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/transforms/at-range.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _normalize = require('../utils/normalize');\n\nvar _normalize2 = _interopRequireDefault(_normalize);\n\nvar _string = require('../utils/string');\n\nvar _string2 = _interopRequireDefault(_string);\n\nvar _core = require('../schemas/core');\n\nvar _core2 = _interopRequireDefault(_core);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Transforms.\n *\n * @type {Object}\n */\n\n/* eslint no-console: 0 */\n\nvar Transforms = {};\n\n/**\n * An options object with normalize set to `false`.\n *\n * @type {Object}\n */\n\nvar OPTS = {\n  normalize: false\n};\n\n/**\n * Add a new `mark` to the characters at `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.addMarkAtRange = function (transform, range, mark) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (range.isCollapsed) return;\n\n  var _options$normalize = options.normalize,\n      normalize = _options$normalize === undefined ? true : _options$normalize;\n  var state = transform.state;\n  var document = state.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset,\n      endKey = range.endKey,\n      endOffset = range.endOffset;\n\n  var texts = document.getTextsAtRange(range);\n\n  texts.forEach(function (text) {\n    var key = text.key;\n\n    var index = 0;\n    var length = text.length;\n\n    if (key == startKey) index = startOffset;\n    if (key == endKey) length = endOffset;\n    if (key == startKey && key == endKey) length = endOffset - startOffset;\n\n    transform.addMarkByKey(key, index, length, mark, { normalize: normalize });\n  });\n};\n\n/**\n * Delete everything in a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.deleteAtRange = function (transform, range) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (range.isCollapsed) return;\n\n  var _options$normalize2 = options.normalize,\n      normalize = _options$normalize2 === undefined ? true : _options$normalize2;\n  var startKey = range.startKey,\n      startOffset = range.startOffset,\n      endKey = range.endKey,\n      endOffset = range.endOffset;\n\n  // If the start and end key are the same, we can just remove text.\n\n  if (startKey == endKey) {\n    var index = startOffset;\n    var length = endOffset - startOffset;\n    transform.removeTextByKey(startKey, index, length, { normalize: normalize });\n    return;\n  }\n\n  // Split at the range edges within a common ancestor, without normalizing.\n  var state = transform.state;\n  var _state = state,\n      document = _state.document;\n\n  var ancestor = document.getCommonAncestor(startKey, endKey);\n  var startChild = ancestor.getFurthestAncestor(startKey);\n  var endChild = ancestor.getFurthestAncestor(endKey);\n  var startOff = (startChild.kind == 'text' ? 0 : startChild.getOffset(startKey)) + startOffset;\n  var endOff = (endChild.kind == 'text' ? 0 : endChild.getOffset(endKey)) + endOffset;\n\n  transform.splitNodeByKey(startChild.key, startOff, OPTS);\n  transform.splitNodeByKey(endChild.key, endOff, OPTS);\n\n  // Refresh variables.\n  state = transform.state;\n  document = state.document;\n  ancestor = document.getCommonAncestor(startKey, endKey);\n  startChild = ancestor.getFurthestAncestor(startKey);\n  endChild = ancestor.getFurthestAncestor(endKey);\n  var startIndex = ancestor.nodes.indexOf(startChild);\n  var endIndex = ancestor.nodes.indexOf(endChild);\n  var middles = ancestor.nodes.slice(startIndex + 1, endIndex + 1);\n\n  // Remove all of the middle nodes, between the splits.\n  if (middles.size) {\n    middles.forEach(function (child) {\n      transform.removeNodeByKey(child.key, OPTS);\n    });\n  }\n\n  // If the start and end block are different, move all of the nodes from the\n  // end block into the start block.\n  var startBlock = document.getClosestBlock(startKey);\n  var endBlock = document.getClosestBlock(document.getNextText(endKey).key);\n\n  if (startBlock.key !== endBlock.key) {\n    endBlock.nodes.forEach(function (child, i) {\n      var newKey = startBlock.key;\n      var newIndex = startBlock.nodes.size + i;\n      transform.moveNodeByKey(child.key, newKey, newIndex, OPTS);\n    });\n\n    // Remove parents of endBlock as long as they have a single child\n    var lonely = document.getFurthestOnlyChildAncestor(endBlock.key) || endBlock;\n    transform.removeNodeByKey(lonely.key, OPTS);\n  }\n\n  if (normalize) {\n    transform.normalizeNodeByKey(ancestor.key, _core2.default);\n  }\n};\n\n/**\n * Delete backward until the character boundary at a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.deleteCharBackwardAtRange = function (transform, range, options) {\n  var state = transform.state;\n  var document = state.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  var text = startBlock.text;\n\n  var n = _string2.default.getCharOffsetBackward(text, o);\n  transform.deleteBackwardAtRange(range, n, options);\n};\n\n/**\n * Delete backward until the line boundary at a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.deleteLineBackwardAtRange = function (transform, range, options) {\n  var state = transform.state;\n  var document = state.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  transform.deleteBackwardAtRange(range, o, options);\n};\n\n/**\n * Delete backward until the word boundary at a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.deleteWordBackwardAtRange = function (transform, range, options) {\n  var state = transform.state;\n  var document = state.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  var text = startBlock.text;\n\n  var n = _string2.default.getWordOffsetBackward(text, o);\n  transform.deleteBackwardAtRange(range, n, options);\n};\n\n/**\n * Delete backward `n` characters at a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Number} n (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.deleteBackwardAtRange = function (transform, range) {\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$normalize3 = options.normalize,\n      normalize = _options$normalize3 === undefined ? true : _options$normalize3;\n  var state = transform.state;\n  var document = state.document;\n  var _range = range,\n      startKey = _range.startKey,\n      focusOffset = _range.focusOffset;\n\n  // If the range is expanded, perform a regular delete instead.\n\n  if (range.isExpanded) {\n    transform.deleteAtRange(range, { normalize: normalize });\n    return;\n  }\n\n  var block = document.getClosestBlock(startKey);\n  // If the closest block is void, delete it.\n  if (block && block.isVoid) {\n    transform.removeNodeByKey(block.key, { normalize: normalize });\n    return;\n  }\n  // If the closest is not void, but empty, remove it\n  if (block && !block.isVoid && block.isEmpty && document.nodes.size !== 1) {\n    transform.removeNodeByKey(block.key, { normalize: normalize });\n    return;\n  }\n\n  // If the closest inline is void, delete it.\n  var inline = document.getClosestInline(startKey);\n  if (inline && inline.isVoid) {\n    transform.removeNodeByKey(inline.key, { normalize: normalize });\n    return;\n  }\n\n  // If the range is at the start of the document, abort.\n  if (range.isAtStartOf(document)) {\n    return;\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  var text = document.getDescendant(startKey);\n  if (range.isAtStartOf(text)) {\n    var prev = document.getPreviousText(text.key);\n    var prevBlock = document.getClosestBlock(prev.key);\n    var prevInline = document.getClosestInline(prev.key);\n\n    // If the previous block is void, remove it.\n    if (prevBlock && prevBlock.isVoid) {\n      transform.removeNodeByKey(prevBlock.key, { normalize: normalize });\n      return;\n    }\n\n    // If the previous inline is void, remove it.\n    if (prevInline && prevInline.isVoid) {\n      transform.removeNodeByKey(prevInline.key, { normalize: normalize });\n      return;\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to join the two blocks together.\n    if (n == 1 && prevBlock != block) {\n      range = range.merge({\n        anchorKey: prev.key,\n        anchorOffset: prev.length\n      });\n\n      transform.deleteAtRange(range, { normalize: normalize });\n      return;\n    }\n  }\n\n  // If the focus offset is farther than the number of characters to delete,\n  // just remove the characters backwards inside the current node.\n  if (n < focusOffset) {\n    range = range.merge({\n      focusOffset: focusOffset - n,\n      isBackward: true\n    });\n\n    transform.deleteAtRange(range, { normalize: normalize });\n    return;\n  }\n\n  // Otherwise, we need to see how many nodes backwards to go.\n  var node = text;\n  var offset = 0;\n  var traversed = focusOffset;\n\n  while (n > traversed) {\n    node = document.getPreviousText(node.key);\n    var next = traversed + node.length;\n    if (n <= next) {\n      offset = next - n;\n      break;\n    } else {\n      traversed = next;\n    }\n  }\n\n  // If the focus node is inside a void, go up until right after it.\n  if (document.hasVoidParent(node.key)) {\n    var parent = document.getClosestVoid(node.key);\n    node = document.getNextText(parent.key);\n    offset = 0;\n  }\n\n  range = range.merge({\n    focusKey: node.key,\n    focusOffset: offset,\n    isBackward: true\n  });\n\n  transform.deleteAtRange(range, { normalize: normalize });\n};\n\n/**\n * Delete forward until the character boundary at a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.deleteCharForwardAtRange = function (transform, range, options) {\n  var state = transform.state;\n  var document = state.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  var text = startBlock.text;\n\n  var n = _string2.default.getCharOffsetForward(text, o);\n  transform.deleteForwardAtRange(range, n, options);\n};\n\n/**\n * Delete forward until the line boundary at a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.deleteLineForwardAtRange = function (transform, range, options) {\n  var state = transform.state;\n  var document = state.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  transform.deleteForwardAtRange(range, o, options);\n};\n\n/**\n * Delete forward until the word boundary at a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.deleteWordForwardAtRange = function (transform, range, options) {\n  var state = transform.state;\n  var document = state.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var startBlock = document.getClosestBlock(startKey);\n  var offset = startBlock.getOffset(startKey);\n  var o = offset + startOffset;\n  var text = startBlock.text;\n\n  var n = _string2.default.getWordOffsetForward(text, o);\n  transform.deleteForwardAtRange(range, n, options);\n};\n\n/**\n * Delete forward `n` characters at a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Number} n (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.deleteForwardAtRange = function (transform, range) {\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$normalize4 = options.normalize,\n      normalize = _options$normalize4 === undefined ? true : _options$normalize4;\n  var state = transform.state;\n  var document = state.document;\n  var _range2 = range,\n      startKey = _range2.startKey,\n      focusOffset = _range2.focusOffset;\n\n  // If the range is expanded, perform a regular delete instead.\n\n  if (range.isExpanded) {\n    transform.deleteAtRange(range, { normalize: normalize });\n    return;\n  }\n\n  var block = document.getClosestBlock(startKey);\n  // If the closest block is void, delete it.\n  if (block && block.isVoid) {\n    transform.removeNodeByKey(block.key, { normalize: normalize });\n    return;\n  }\n  // If the closest is not void, but empty, remove it\n  if (block && !block.isVoid && block.isEmpty && document.nodes.size !== 1) {\n    transform.removeNodeByKey(block.key, { normalize: normalize });\n    return;\n  }\n\n  // If the closest inline is void, delete it.\n  var inline = document.getClosestInline(startKey);\n  if (inline && inline.isVoid) {\n    transform.removeNodeByKey(inline.key, { normalize: normalize });\n    return;\n  }\n\n  // If the range is at the start of the document, abort.\n  if (range.isAtEndOf(document)) {\n    return;\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  var text = document.getDescendant(startKey);\n  if (range.isAtEndOf(text)) {\n    var next = document.getNextText(text.key);\n    var nextBlock = document.getClosestBlock(next.key);\n    var nextInline = document.getClosestInline(next.key);\n\n    // If the previous block is void, remove it.\n    if (nextBlock && nextBlock.isVoid) {\n      transform.removeNodeByKey(nextBlock.key, { normalize: normalize });\n      return;\n    }\n\n    // If the previous inline is void, remove it.\n    if (nextInline && nextInline.isVoid) {\n      transform.removeNodeByKey(nextInline.key, { normalize: normalize });\n      return;\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to join the two blocks together.\n    if (n == 1 && nextBlock != block) {\n      range = range.merge({\n        focusKey: next.key,\n        focusOffset: 0\n      });\n\n      transform.deleteAtRange(range, { normalize: normalize });\n      return;\n    }\n  }\n\n  // If the remaining characters to the end of the node is greater than or equal\n  // to the number of characters to delete, just remove the characters forwards\n  // inside the current node.\n  if (n <= text.length - focusOffset) {\n    range = range.merge({\n      focusOffset: focusOffset + n\n    });\n\n    transform.deleteAtRange(range, { normalize: normalize });\n    return;\n  }\n\n  // Otherwise, we need to see how many nodes forwards to go.\n  var node = text;\n  var offset = focusOffset;\n  var traversed = text.length - focusOffset;\n\n  while (n > traversed) {\n    node = document.getNextText(node.key);\n    var _next = traversed + node.length;\n    if (n <= _next) {\n      offset = n - traversed;\n      break;\n    } else {\n      traversed = _next;\n    }\n  }\n\n  // If the focus node is inside a void, go up until right before it.\n  if (document.hasVoidParent(node.key)) {\n    var parent = document.getClosestVoid(node.key);\n    node = document.getPreviousText(parent.key);\n    offset = node.length;\n  }\n\n  range = range.merge({\n    focusKey: node.key,\n    focusOffset: offset\n  });\n\n  transform.deleteAtRange(range, { normalize: normalize });\n};\n\n/**\n * Insert a `block` node at `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Block|String|Object} block\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.insertBlockAtRange = function (transform, range, block) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  block = _normalize2.default.block(block);\n  var _options$normalize5 = options.normalize,\n      normalize = _options$normalize5 === undefined ? true : _options$normalize5;\n\n\n  if (range.isExpanded) {\n    transform.deleteAtRange(range);\n    range = range.collapseToStart();\n  }\n\n  var state = transform.state;\n  var document = state.document;\n  var _range3 = range,\n      startKey = _range3.startKey,\n      startOffset = _range3.startOffset;\n\n  var startText = document.assertDescendant(startKey);\n  var startBlock = document.getClosestBlock(startKey);\n  var parent = document.getParent(startBlock.key);\n  var index = parent.nodes.indexOf(startBlock);\n\n  if (startBlock.isVoid) {\n    transform.insertNodeByKey(parent.key, index + 1, block, { normalize: normalize });\n  } else if (startBlock.isEmpty) {\n    transform.removeNodeByKey(startBlock.key);\n    transform.insertNodeByKey(parent.key, index, block, { normalize: normalize });\n  } else if (range.isAtStartOf(startBlock)) {\n    transform.insertNodeByKey(parent.key, index, block, { normalize: normalize });\n  } else if (range.isAtEndOf(startBlock)) {\n    transform.insertNodeByKey(parent.key, index + 1, block, { normalize: normalize });\n  } else {\n    var offset = startBlock.getOffset(startText.key) + startOffset;\n    transform.splitNodeByKey(startBlock.key, offset, { normalize: normalize });\n    transform.insertNodeByKey(parent.key, index + 1, block, { normalize: normalize });\n  }\n\n  if (normalize) {\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Insert a `fragment` at a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Document} fragment\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.insertFragmentAtRange = function (transform, range, fragment) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$normalize6 = options.normalize,\n      normalize = _options$normalize6 === undefined ? true : _options$normalize6;\n\n  // If the range is expanded, delete it first.\n\n  if (range.isExpanded) {\n    transform.deleteAtRange(range, OPTS);\n    range = range.collapseToStart();\n  }\n\n  // If the fragment is empty, there's nothing to do after deleting.\n  if (!fragment.length) return;\n\n  // Regenerate the keys for all of the fragments nodes, so that they're\n  // guaranteed not to collide with the existing keys in the document. Otherwise\n  // they will be rengerated automatically and we won't have an easy way to\n  // reference them.\n  fragment = fragment.mapDescendants(function (child) {\n    return child.regenerateKey();\n  });\n\n  // Calculate a few things...\n  var _range4 = range,\n      startKey = _range4.startKey,\n      startOffset = _range4.startOffset;\n  var state = transform.state;\n  var _state2 = state,\n      document = _state2.document;\n\n  var startText = document.getDescendant(startKey);\n  var startBlock = document.getClosestBlock(startText.key);\n  var startChild = startBlock.getFurthestAncestor(startText.key);\n  var isAtStart = range.isAtStartOf(startBlock);\n  var parent = document.getParent(startBlock.key);\n  var index = parent.nodes.indexOf(startBlock);\n  var offset = startChild == startText ? startOffset : startChild.getOffset(startText.key) + startOffset;\n\n  var blocks = fragment.getBlocks();\n  var firstBlock = blocks.first();\n  var lastBlock = blocks.last();\n\n  // If the first and last block aren't the same, we need to insert all of the\n  // nodes after the fragment's first block at the index.\n  if (firstBlock != lastBlock) {\n    var lonelyParent = fragment.getFurthest(firstBlock.key, function (p) {\n      return p.nodes.size == 1;\n    });\n    var lonelyChild = lonelyParent || firstBlock;\n    var startIndex = parent.nodes.indexOf(startBlock);\n    fragment = fragment.removeDescendant(lonelyChild.key);\n\n    fragment.nodes.forEach(function (node, i) {\n      var newIndex = startIndex + i + 1;\n      transform.insertNodeByKey(parent.key, newIndex, node, OPTS);\n    });\n  }\n\n  // Check if we need to split the node.\n  if (startOffset != 0) {\n    transform.splitNodeByKey(startChild.key, offset, OPTS);\n  }\n\n  // Update our variables with the new state.\n  state = transform.state;\n  document = state.document;\n  startText = document.getDescendant(startKey);\n  startBlock = document.getClosestBlock(startKey);\n  startChild = startBlock.getFurthestAncestor(startText.key);\n\n  // If the first and last block aren't the same, we need to move any of the\n  // starting block's children after the split into the last block of the\n  // fragment, which has already been inserted.\n  if (firstBlock != lastBlock) {\n    var nextChild = isAtStart ? startChild : startBlock.getNextSibling(startChild.key);\n    var nextNodes = nextChild ? startBlock.nodes.skipUntil(function (n) {\n      return n.key == nextChild.key;\n    }) : (0, _immutable.List)();\n    var lastIndex = lastBlock.nodes.size;\n\n    nextNodes.forEach(function (node, i) {\n      var newIndex = lastIndex + i;\n      transform.moveNodeByKey(node.key, lastBlock.key, newIndex, OPTS);\n    });\n  }\n\n  // If the starting block is empty, we replace it entirely with the first block\n  // of the fragment, since this leads to a more expected behavior for the user.\n  if (startBlock.isEmpty) {\n    transform.removeNodeByKey(startBlock.key, OPTS);\n    transform.insertNodeByKey(parent.key, index, firstBlock, OPTS);\n  }\n\n  // Otherwise, we maintain the starting block, and insert all of the first\n  // block's inline nodes into it at the split point.\n  else {\n      var inlineChild = startBlock.getFurthestAncestor(startText.key);\n      var inlineIndex = startBlock.nodes.indexOf(inlineChild);\n\n      firstBlock.nodes.forEach(function (inline, i) {\n        var o = startOffset == 0 ? 0 : 1;\n        var newIndex = inlineIndex + i + o;\n        transform.insertNodeByKey(startBlock.key, newIndex, inline, OPTS);\n      });\n    }\n\n  // Normalize if requested.\n  if (normalize) {\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Insert an `inline` node at `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Inline|String|Object} inline\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.insertInlineAtRange = function (transform, range, inline) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$normalize7 = options.normalize,\n      normalize = _options$normalize7 === undefined ? true : _options$normalize7;\n\n  inline = _normalize2.default.inline(inline);\n\n  if (range.isExpanded) {\n    transform.deleteAtRange(range, OPTS);\n    range = range.collapseToStart();\n  }\n\n  var state = transform.state;\n  var document = state.document;\n  var _range5 = range,\n      startKey = _range5.startKey,\n      startOffset = _range5.startOffset;\n\n  var parent = document.getParent(startKey);\n  var startText = document.assertDescendant(startKey);\n  var index = parent.nodes.indexOf(startText);\n\n  if (parent.isVoid) return;\n\n  transform.splitNodeByKey(startKey, startOffset, OPTS);\n  transform.insertNodeByKey(parent.key, index + 1, inline, OPTS);\n\n  if (normalize) {\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Insert `text` at a `range`, with optional `marks`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.insertTextAtRange = function (transform, range, text, marks) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var normalize = options.normalize;\n  var state = transform.state;\n  var document = state.document;\n  var startKey = range.startKey,\n      startOffset = range.startOffset;\n\n  var parent = document.getParent(startKey);\n\n  if (parent.isVoid) return;\n\n  if (range.isExpanded) {\n    transform.deleteAtRange(range, OPTS);\n  }\n\n  // PERF: Unless specified, don't normalize if only inserting text.\n  if (normalize !== undefined) {\n    normalize = range.isExpanded;\n  }\n\n  transform.insertTextByKey(startKey, startOffset, text, marks, { normalize: normalize });\n};\n\n/**\n * Remove an existing `mark` to the characters at `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Mark|String} mark (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.removeMarkAtRange = function (transform, range, mark) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (range.isCollapsed) return;\n\n  var _options$normalize8 = options.normalize,\n      normalize = _options$normalize8 === undefined ? true : _options$normalize8;\n  var state = transform.state;\n  var document = state.document;\n\n  var texts = document.getTextsAtRange(range);\n  var startKey = range.startKey,\n      startOffset = range.startOffset,\n      endKey = range.endKey,\n      endOffset = range.endOffset;\n\n\n  texts.forEach(function (text) {\n    var key = text.key;\n\n    var index = 0;\n    var length = text.length;\n\n    if (key == startKey) index = startOffset;\n    if (key == endKey) length = endOffset;\n    if (key == startKey && key == endKey) length = endOffset - startOffset;\n\n    transform.removeMarkByKey(key, index, length, mark, { normalize: normalize });\n  });\n};\n\n/**\n * Set the `properties` of block nodes in a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.setBlockAtRange = function (transform, range, properties) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$normalize9 = options.normalize,\n      normalize = _options$normalize9 === undefined ? true : _options$normalize9;\n  var state = transform.state;\n  var document = state.document;\n\n  var blocks = document.getBlocksAtRange(range);\n\n  blocks.forEach(function (block) {\n    transform.setNodeByKey(block.key, properties, { normalize: normalize });\n  });\n};\n\n/**\n * Set the `properties` of inline nodes in a `range`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.setInlineAtRange = function (transform, range, properties) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$normalize10 = options.normalize,\n      normalize = _options$normalize10 === undefined ? true : _options$normalize10;\n  var state = transform.state;\n  var document = state.document;\n\n  var inlines = document.getInlinesAtRange(range);\n\n  inlines.forEach(function (inline) {\n    transform.setNodeByKey(inline.key, properties, { normalize: normalize });\n  });\n};\n\n/**\n * Split the block nodes at a `range`, to optional `height`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Number} height (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.splitBlockAtRange = function (transform, range) {\n  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$normalize11 = options.normalize,\n      normalize = _options$normalize11 === undefined ? true : _options$normalize11;\n\n\n  if (range.isExpanded) {\n    transform.deleteAtRange(range, { normalize: normalize });\n    range = range.collapseToStart();\n  }\n\n  var _range6 = range,\n      startKey = _range6.startKey,\n      startOffset = _range6.startOffset;\n  var state = transform.state;\n  var document = state.document;\n\n  var node = document.assertDescendant(startKey);\n  var parent = document.getClosestBlock(node.key);\n  var offset = startOffset;\n  var h = 0;\n\n  while (parent && parent.kind == 'block' && h < height) {\n    offset += parent.getOffset(node.key);\n    node = parent;\n    parent = document.getClosestBlock(parent.key);\n    h++;\n  }\n\n  transform.splitNodeByKey(node.key, offset, { normalize: normalize });\n};\n\n/**\n * Split the inline nodes at a `range`, to optional `height`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Number} height (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.splitInlineAtRange = function (transform, range) {\n  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$normalize12 = options.normalize,\n      normalize = _options$normalize12 === undefined ? true : _options$normalize12;\n\n\n  if (range.isExpanded) {\n    transform.deleteAtRange(range, { normalize: normalize });\n    range = range.collapseToStart();\n  }\n\n  var _range7 = range,\n      startKey = _range7.startKey,\n      startOffset = _range7.startOffset;\n  var state = transform.state;\n  var document = state.document;\n\n  var node = document.assertDescendant(startKey);\n  var parent = document.getClosestInline(node.key);\n  var offset = startOffset;\n  var h = 0;\n\n  while (parent && parent.kind == 'inline' && h < height) {\n    offset += parent.getOffset(node.key);\n    node = parent;\n    parent = document.getClosestInline(parent.key);\n    h++;\n  }\n\n  transform.splitNodeByKey(node.key, offset, { normalize: normalize });\n};\n\n/**\n * Add or remove a `mark` from the characters at `range`, depending on whether\n * it's already there.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.toggleMarkAtRange = function (transform, range, mark) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (range.isCollapsed) return;\n\n  mark = _normalize2.default.mark(mark);\n\n  var _options$normalize13 = options.normalize,\n      normalize = _options$normalize13 === undefined ? true : _options$normalize13;\n  var state = transform.state;\n  var document = state.document;\n\n  var marks = document.getMarksAtRange(range);\n  var exists = marks.some(function (m) {\n    return m.equals(mark);\n  });\n\n  if (exists) {\n    transform.removeMarkAtRange(range, mark, { normalize: normalize });\n  } else {\n    transform.addMarkAtRange(range, mark, { normalize: normalize });\n  }\n};\n\n/**\n * Unwrap all of the block nodes in a `range` from a block with `properties`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {String|Object} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.unwrapBlockAtRange = function (transform, range, properties) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  properties = _normalize2.default.nodeProperties(properties);\n\n  var _options$normalize14 = options.normalize,\n      normalize = _options$normalize14 === undefined ? true : _options$normalize14;\n  var state = transform.state;\n  var _state3 = state,\n      document = _state3.document;\n\n  var blocks = document.getBlocksAtRange(range);\n  var wrappers = blocks.map(function (block) {\n    return document.getClosest(block.key, function (parent) {\n      if (parent.kind != 'block') return false;\n      if (properties.type != null && parent.type != properties.type) return false;\n      if (properties.isVoid != null && parent.isVoid != properties.isVoid) return false;\n      if (properties.data != null && !parent.data.isSuperset(properties.data)) return false;\n      return true;\n    });\n  }).filter(function (exists) {\n    return exists;\n  }).toOrderedSet().toList();\n\n  wrappers.forEach(function (block) {\n    var first = block.nodes.first();\n    var last = block.nodes.last();\n    var parent = document.getParent(block.key);\n    var index = parent.nodes.indexOf(block);\n\n    var children = block.nodes.filter(function (child) {\n      return blocks.some(function (b) {\n        return child == b || child.hasDescendant(b.key);\n      });\n    });\n\n    var firstMatch = children.first();\n    var lastMatch = children.last();\n\n    if (first == firstMatch && last == lastMatch) {\n      block.nodes.forEach(function (child, i) {\n        transform.moveNodeByKey(child.key, parent.key, index + i, OPTS);\n      });\n\n      transform.removeNodeByKey(block.key, OPTS);\n    } else if (last == lastMatch) {\n      block.nodes.skipUntil(function (n) {\n        return n == firstMatch;\n      }).forEach(function (child, i) {\n        transform.moveNodeByKey(child.key, parent.key, index + 1 + i, OPTS);\n      });\n    } else if (first == firstMatch) {\n      block.nodes.takeUntil(function (n) {\n        return n == lastMatch;\n      }).push(lastMatch).forEach(function (child, i) {\n        transform.moveNodeByKey(child.key, parent.key, index + i, OPTS);\n      });\n    } else {\n      var offset = block.getOffset(firstMatch.key);\n\n      transform.splitNodeByKey(block.key, offset, OPTS);\n      state = transform.state;\n      document = state.document;\n\n      children.forEach(function (child, i) {\n        if (i == 0) {\n          var extra = child;\n          child = document.getNextBlock(child.key);\n          transform.removeNodeByKey(extra.key, OPTS);\n        }\n\n        transform.moveNodeByKey(child.key, parent.key, index + 1 + i, OPTS);\n      });\n    }\n  });\n\n  // TODO: optmize to only normalize the right block\n  if (normalize) {\n    transform.normalizeDocument(_core2.default);\n  }\n};\n\n/**\n * Unwrap the inline nodes in a `range` from an inline with `properties`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {String|Object} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.unwrapInlineAtRange = function (transform, range, properties) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  properties = _normalize2.default.nodeProperties(properties);\n\n  var _options$normalize15 = options.normalize,\n      normalize = _options$normalize15 === undefined ? true : _options$normalize15;\n  var state = transform.state;\n  var document = state.document;\n\n  var texts = document.getTextsAtRange(range);\n  var inlines = texts.map(function (text) {\n    return document.getClosest(text.key, function (parent) {\n      if (parent.kind != 'inline') return false;\n      if (properties.type != null && parent.type != properties.type) return false;\n      if (properties.isVoid != null && parent.isVoid != properties.isVoid) return false;\n      if (properties.data != null && !parent.data.isSuperset(properties.data)) return false;\n      return true;\n    });\n  }).filter(function (exists) {\n    return exists;\n  }).toOrderedSet().toList();\n\n  inlines.forEach(function (inline) {\n    var parent = transform.state.document.getParent(inline.key);\n    var index = parent.nodes.indexOf(inline);\n\n    inline.nodes.forEach(function (child, i) {\n      transform.moveNodeByKey(child.key, parent.key, index + i, OPTS);\n    });\n  });\n\n  // TODO: optmize to only normalize the right block\n  if (normalize) {\n    transform.normalizeDocument(_core2.default);\n  }\n};\n\n/**\n * Wrap all of the blocks in a `range` in a new `block`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Block|Object|String} block\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.wrapBlockAtRange = function (transform, range, block) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  block = _normalize2.default.block(block);\n  block = block.set('nodes', block.nodes.clear());\n\n  var _options$normalize16 = options.normalize,\n      normalize = _options$normalize16 === undefined ? true : _options$normalize16;\n  var state = transform.state;\n  var document = state.document;\n\n\n  var blocks = document.getBlocksAtRange(range);\n  var firstblock = blocks.first();\n  var lastblock = blocks.last();\n  var parent = void 0,\n      siblings = void 0,\n      index = void 0;\n\n  // If there is only one block in the selection then we know the parent and\n  // siblings.\n  if (blocks.length === 1) {\n    parent = document.getParent(firstblock.key);\n    siblings = blocks;\n  }\n\n  // Determine closest shared parent to all blocks in selection.\n  else {\n      parent = document.getClosest(firstblock.key, function (p1) {\n        return !!document.getClosest(lastblock.key, function (p2) {\n          return p1 == p2;\n        });\n      });\n    }\n\n  // If no shared parent could be found then the parent is the document.\n  if (parent == null) parent = document;\n\n  // Create a list of direct children siblings of parent that fall in the\n  // selection.\n  if (siblings == null) {\n    var indexes = parent.nodes.reduce(function (ind, node, i) {\n      if (node == firstblock || node.hasDescendant(firstblock.key)) ind[0] = i;\n      if (node == lastblock || node.hasDescendant(lastblock.key)) ind[1] = i;\n      return ind;\n    }, []);\n\n    index = indexes[0];\n    siblings = parent.nodes.slice(indexes[0], indexes[1] + 1);\n  }\n\n  // Get the index to place the new wrapped node at.\n  if (index == null) {\n    index = parent.nodes.indexOf(siblings.first());\n  }\n\n  // Inject the new block node into the parent.\n  transform.insertNodeByKey(parent.key, index, block, OPTS);\n\n  // Move the sibling nodes into the new block node.\n  siblings.forEach(function (node, i) {\n    transform.moveNodeByKey(node.key, block.key, i, OPTS);\n  });\n\n  if (normalize) {\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Wrap the text and inlines in a `range` in a new `inline`.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {Inline|Object|String} inline\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.wrapInlineAtRange = function (transform, range, inline) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var state = transform.state;\n  var _state4 = state,\n      document = _state4.document;\n  var _options$normalize17 = options.normalize,\n      normalize = _options$normalize17 === undefined ? true : _options$normalize17;\n  var startKey = range.startKey,\n      startOffset = range.startOffset,\n      endKey = range.endKey,\n      endOffset = range.endOffset;\n\n\n  if (range.isCollapsed) {\n    // Wrapping an inline void\n    var inlineParent = document.getClosestInline(startKey);\n    if (!inlineParent.isVoid) {\n      return;\n    }\n\n    return transform.wrapInlineByKey(inlineParent.key, inline, options);\n  }\n\n  inline = _normalize2.default.inline(inline);\n  inline = inline.set('nodes', inline.nodes.clear());\n\n  var blocks = document.getBlocksAtRange(range);\n  var startBlock = document.getClosestBlock(startKey);\n  var endBlock = document.getClosestBlock(endKey);\n  var startChild = startBlock.getFurthestAncestor(startKey);\n  var endChild = endBlock.getFurthestAncestor(endKey);\n  var startIndex = startBlock.nodes.indexOf(startChild);\n  var endIndex = endBlock.nodes.indexOf(endChild);\n\n  var startOff = startChild.key == startKey ? startOffset : startChild.getOffset(startKey) + startOffset;\n\n  var endOff = endChild.key == endKey ? endOffset : endChild.getOffset(endKey) + endOffset;\n\n  if (startBlock == endBlock) {\n    if (endOff != endChild.length) {\n      transform.splitNodeByKey(endChild.key, endOff, OPTS);\n    }\n\n    if (startOff != 0) {\n      transform.splitNodeByKey(startChild.key, startOff, OPTS);\n    }\n\n    state = transform.state;\n    document = state.document;\n    startBlock = document.getClosestBlock(startKey);\n    startChild = startBlock.getFurthestAncestor(startKey);\n\n    var startInner = startOff == 0 ? startChild : document.getNextSibling(startChild.key);\n\n    var startInnerIndex = startBlock.nodes.indexOf(startInner);\n\n    var endInner = startKey == endKey ? startInner : startBlock.getFurthestAncestor(endKey);\n    var inlines = startBlock.nodes.skipUntil(function (n) {\n      return n == startInner;\n    }).takeUntil(function (n) {\n      return n == endInner;\n    }).push(endInner);\n\n    var node = inline.regenerateKey();\n\n    transform.insertNodeByKey(startBlock.key, startInnerIndex, node, OPTS);\n\n    inlines.forEach(function (child, i) {\n      transform.moveNodeByKey(child.key, node.key, i, OPTS);\n    });\n\n    if (normalize) {\n      transform.normalizeNodeByKey(startBlock.key, _core2.default);\n    }\n  } else {\n    transform.splitNodeByKey(startChild.key, startOff, OPTS);\n    transform.splitNodeByKey(endChild.key, endOff, OPTS);\n\n    state = transform.state;\n    document = state.document;\n    startBlock = document.getDescendant(startBlock.key);\n    endBlock = document.getDescendant(endBlock.key);\n\n    var startInlines = startBlock.nodes.slice(startIndex + 1);\n    var endInlines = endBlock.nodes.slice(0, endIndex + 1);\n    var startNode = inline.regenerateKey();\n    var endNode = inline.regenerateKey();\n\n    transform.insertNodeByKey(startBlock.key, startIndex - 1, startNode, OPTS);\n    transform.insertNodeByKey(endBlock.key, endIndex, endNode, OPTS);\n\n    startInlines.forEach(function (child, i) {\n      transform.moveNodeByKey(child.key, startNode.key, i, OPTS);\n    });\n\n    endInlines.forEach(function (child, i) {\n      transform.moveNodeByKey(child.key, endNode.key, i, OPTS);\n    });\n\n    if (normalize) {\n      transform.normalizeNodeByKey(startBlock.key, _core2.default).normalizeNodeByKey(endBlock.key, _core2.default);\n    }\n\n    blocks.slice(1, -1).forEach(function (block) {\n      var node = inline.regenerateKey();\n      transform.insertNodeByKey(block.key, 0, node, OPTS);\n\n      block.nodes.forEach(function (child, i) {\n        transform.moveNodeByKey(child.key, node.key, i, OPTS);\n      });\n\n      if (normalize) {\n        transform.normalizeNodeByKey(block.key, _core2.default);\n      }\n    });\n  }\n};\n\n/**\n * Wrap the text in a `range` in a prefix/suffix.\n *\n * @param {Transform} transform\n * @param {Selection} range\n * @param {String} prefix\n * @param {String} suffix (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.wrapTextAtRange = function (transform, range, prefix) {\n  var suffix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : prefix;\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var _options$normalize18 = options.normalize,\n      normalize = _options$normalize18 === undefined ? true : _options$normalize18;\n  var startKey = range.startKey,\n      endKey = range.endKey;\n\n  var start = range.collapseToStart();\n  var end = range.collapseToEnd();\n\n  if (startKey == endKey) {\n    end = end.move(prefix.length);\n  }\n\n  transform.insertTextAtRange(start, prefix, [], { normalize: normalize });\n  transform.insertTextAtRange(end, suffix, [], { normalize: normalize });\n};\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Transforms;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/string.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _esrever = require('esrever');\n\n/**\n * Surrogate pair start and end points.\n *\n * @type {Number}\n */\n\nvar SURROGATE_START = 0xD800;\nvar SURROGATE_END = 0xDFFF;\n\n/**\n * A regex to match space characters.\n *\n * @type {RegExp}\n */\n\nvar SPACE = /\\s/;\n\n/**\n * A regex to match chameleon characters, that count as word characters as long\n * as they are inside of a word.\n *\n * @type {RegExp}\n */\n\nvar CHAMELEON = /['\\u2018\\u2019]/;\n\n/**\n * A regex that matches punctuation.\n *\n * @type {RegExp}\n */\n\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\n\n/**\n * Is a character `code` in a surrogate character.\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\nfunction isSurrogate(code) {\n  return SURROGATE_START <= code && code <= SURROGATE_END;\n}\n\n/**\n * Is a character a word character? Needs the `remaining` characters too.\n *\n * @param {String} char\n * @param {String|Void} remaining\n * @return {Boolean}\n */\n\nfunction isWord(char, remaining) {\n  if (SPACE.test(char)) return false;\n\n  // If it's a chameleon character, recurse to see if the next one is or not.\n  if (CHAMELEON.test(char)) {\n    var next = remaining.charAt(0);\n    var length = getCharLength(next);\n    next = remaining.slice(0, length);\n    var rest = remaining.slice(length);\n    if (isWord(next, rest)) return true;\n  }\n\n  if (PUNCTUATION.test(char)) return false;\n  return true;\n}\n\n/**\n * Get the length of a `character`.\n *\n * @param {String} char\n * @return {Number}\n */\n\nfunction getCharLength(char) {\n  return isSurrogate(char.charCodeAt(0)) ? 2 : 1;\n}\n\n/**\n * Get the offset to the end of the first character in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getCharOffset(text) {\n  var char = text.charAt(0);\n  return getCharLength(char);\n}\n\n/**\n * Get the offset to the end of the character before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getCharOffsetBackward(text, offset) {\n  text = text.slice(0, offset);\n  text = (0, _esrever.reverse)(text);\n  return getCharOffset(text);\n}\n\n/**\n * Get the offset to the end of the character after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getCharOffsetForward(text, offset) {\n  text = text.slice(offset);\n  return getCharOffset(text);\n}\n\n/**\n * Get the offset to the end of the first word in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getWordOffset(text) {\n  var length = 0;\n  var i = 0;\n  var started = false;\n  var char = void 0;\n\n  while (char = text.charAt(i)) {\n    var l = getCharLength(char);\n    char = text.slice(i, i + l);\n    var rest = text.slice(i + l);\n\n    if (isWord(char, rest)) {\n      started = true;\n      length += l;\n    } else if (!started) {\n      length += l;\n    } else {\n      break;\n    }\n\n    i += l;\n  }\n\n  return length;\n}\n\n/**\n * Get the offset to the end of the word before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetBackward(text, offset) {\n  text = text.slice(0, offset);\n  text = (0, _esrever.reverse)(text);\n  var o = getWordOffset(text);\n  return o;\n}\n\n/**\n * Get the offset to the end of the word after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetForward(text, offset) {\n  text = text.slice(offset);\n  var o = getWordOffset(text);\n  return o;\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = {\n  getCharOffsetForward: getCharOffsetForward,\n  getCharOffsetBackward: getCharOffsetBackward,\n  getWordOffsetBackward: getWordOffsetBackward,\n  getWordOffsetForward: getWordOffsetForward\n};","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/transforms/by-key.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _normalize = require('../utils/normalize');\n\nvar _normalize2 = _interopRequireDefault(_normalize);\n\nvar _core = require('../schemas/core');\n\nvar _core2 = _interopRequireDefault(_core);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Transforms.\n *\n * @type {Object}\n */\n\nvar Transforms = {};\n\n/**\n * Add mark to text at `offset` and `length` in node by `key`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.addMarkByKey = function (transform, key, offset, length, mark) {\n  var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n  mark = _normalize2.default.mark(mark);\n  var _options$normalize = options.normalize,\n      normalize = _options$normalize === undefined ? true : _options$normalize;\n  var state = transform.state;\n  var document = state.document;\n\n  var path = document.getPath(key);\n\n  transform.addMarkOperation(path, offset, length, mark);\n\n  if (normalize) {\n    var parent = document.getParent(key);\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Insert a `node` at `index` in a node by `key`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Number} index\n * @param {Node} node\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.insertNodeByKey = function (transform, key, index, node) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var _options$normalize2 = options.normalize,\n      normalize = _options$normalize2 === undefined ? true : _options$normalize2;\n  var state = transform.state;\n  var document = state.document;\n\n  var path = document.getPath(key);\n\n  transform.insertNodeOperation(path, index, node);\n\n  if (normalize) {\n    transform.normalizeNodeByKey(key, _core2.default);\n  }\n};\n\n/**\n * Insert `text` at `offset` in node by `key`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Number} offset\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.insertTextByKey = function (transform, key, offset, text, marks) {\n  var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n  var _options$normalize3 = options.normalize,\n      normalize = _options$normalize3 === undefined ? true : _options$normalize3;\n  var state = transform.state;\n  var document = state.document;\n\n  var path = document.getPath(key);\n\n  transform.insertTextOperation(path, offset, text, marks);\n\n  if (normalize) {\n    var parent = document.getParent(key);\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Join a node by `key` with a node `withKey`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {String} withKey\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.joinNodeByKey = function (transform, key, withKey) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$normalize4 = options.normalize,\n      normalize = _options$normalize4 === undefined ? true : _options$normalize4;\n  var state = transform.state;\n  var document = state.document;\n\n  var path = document.getPath(key);\n  var withPath = document.getPath(withKey);\n\n  transform.joinNodeOperation(path, withPath);\n\n  if (normalize) {\n    var parent = document.getCommonAncestor(key, withKey);\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Move a node by `key` to a new parent by `newKey` and `index`.\n * `newKey` is the key of the container (it can be the document itself)\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {String} newKey\n * @param {Number} index\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.moveNodeByKey = function (transform, key, newKey, newIndex) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var _options$normalize5 = options.normalize,\n      normalize = _options$normalize5 === undefined ? true : _options$normalize5;\n  var state = transform.state;\n  var document = state.document;\n\n  var path = document.getPath(key);\n  var newPath = document.getPath(newKey);\n\n  transform.moveNodeOperation(path, newPath, newIndex);\n\n  if (normalize) {\n    var parent = document.getCommonAncestor(key, newKey);\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Remove mark from text at `offset` and `length` in node by `key`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.removeMarkByKey = function (transform, key, offset, length, mark) {\n  var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n  mark = _normalize2.default.mark(mark);\n  var _options$normalize6 = options.normalize,\n      normalize = _options$normalize6 === undefined ? true : _options$normalize6;\n  var state = transform.state;\n  var document = state.document;\n\n  var path = document.getPath(key);\n\n  transform.removeMarkOperation(path, offset, length, mark);\n\n  if (normalize) {\n    var parent = document.getParent(key);\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Remove a node by `key`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.removeNodeByKey = function (transform, key) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$normalize7 = options.normalize,\n      normalize = _options$normalize7 === undefined ? true : _options$normalize7;\n  var state = transform.state;\n  var document = state.document;\n\n  var path = document.getPath(key);\n\n  transform.removeNodeOperation(path);\n\n  if (normalize) {\n    var parent = document.getParent(key);\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Remove text at `offset` and `length` in node by `key`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.removeTextByKey = function (transform, key, offset, length) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var _options$normalize8 = options.normalize,\n      normalize = _options$normalize8 === undefined ? true : _options$normalize8;\n  var state = transform.state;\n  var document = state.document;\n\n  var path = document.getPath(key);\n\n  transform.removeTextOperation(path, offset, length);\n\n  if (normalize) {\n    var block = document.getClosestBlock(key);\n    transform.normalizeNodeByKey(block.key, _core2.default);\n  }\n};\n\n/**\n * Set `properties` on mark on text at `offset` and `length` in node by `key`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.setMarkByKey = function (transform, key, offset, length, mark, properties) {\n  var options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n\n  mark = _normalize2.default.mark(mark);\n  properties = _normalize2.default.markProperties(properties);\n  var _options$normalize9 = options.normalize,\n      normalize = _options$normalize9 === undefined ? true : _options$normalize9;\n\n  var newMark = mark.merge(properties);\n  var state = transform.state;\n  var document = state.document;\n\n  var path = document.getPath(key);\n\n  transform.setMarkOperation(path, offset, length, mark, newMark);\n\n  if (normalize) {\n    var parent = document.getParent(key);\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Set `properties` on a node by `key`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.setNodeByKey = function (transform, key, properties) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  properties = _normalize2.default.nodeProperties(properties);\n  var _options$normalize10 = options.normalize,\n      normalize = _options$normalize10 === undefined ? true : _options$normalize10;\n  var state = transform.state;\n  var document = state.document;\n\n  var path = document.getPath(key);\n\n  transform.setNodeOperation(path, properties);\n\n  if (normalize) {\n    var node = key === document.key ? document : document.getParent(key);\n    transform.normalizeNodeByKey(node.key, _core2.default);\n  }\n};\n\n/**\n * Split a node by `key` at `offset`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Number} offset\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.splitNodeByKey = function (transform, key, offset) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$normalize11 = options.normalize,\n      normalize = _options$normalize11 === undefined ? true : _options$normalize11;\n  var state = transform.state;\n  var document = state.document;\n\n  var path = document.getPath(key);\n\n  transform.splitNodeAtOffsetOperation(path, offset);\n\n  if (normalize) {\n    var parent = document.getParent(key);\n    transform.normalizeNodeByKey(parent.key, _core2.default);\n  }\n};\n\n/**\n * Unwrap content from an inline parent with `properties`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.unwrapInlineByKey = function (transform, key, properties, options) {\n  var state = transform.state;\n  var document = state.document,\n      selection = state.selection;\n\n  var node = document.assertDescendant(key);\n  var first = node.getFirstText();\n  var last = node.getLastText();\n  var range = selection.moveToRangeOf(first, last);\n  transform.unwrapInlineAtRange(range, properties, options);\n};\n\n/**\n * Unwrap content from a block parent with `properties`.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.unwrapBlockByKey = function (transform, key, properties, options) {\n  var state = transform.state;\n  var document = state.document,\n      selection = state.selection;\n\n  var node = document.assertDescendant(key);\n  var first = node.getFirstText();\n  var last = node.getLastText();\n  var range = selection.moveToRangeOf(first, last);\n  transform.unwrapBlockAtRange(range, properties, options);\n};\n\n/**\n * Unwrap a single node from its parent.\n *\n * If the node is surrounded with siblings, its parent will be\n * split. If the node is the only child, the parent is removed, and\n * simply replaced by the node itself.  Cannot unwrap a root node.\n *\n * @param {Transform} transform\n * @param {String} key\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.unwrapNodeByKey = function (transform, key) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$normalize12 = options.normalize,\n      normalize = _options$normalize12 === undefined ? true : _options$normalize12;\n  var state = transform.state;\n  var document = state.document;\n\n  var parent = document.getParent(key);\n  var node = parent.getChild(key);\n\n  var index = parent.nodes.indexOf(node);\n  var isFirst = index === 0;\n  var isLast = index === parent.nodes.size - 1;\n\n  var parentParent = document.getParent(parent.key);\n  var parentIndex = parentParent.nodes.indexOf(parent);\n\n  if (parent.nodes.size === 1) {\n    transform.moveNodeByKey(key, parentParent.key, parentIndex, { normalize: false });\n    transform.removeNodeByKey(parent.key, options);\n  } else if (isFirst) {\n    // Just move the node before its parent.\n    transform.moveNodeByKey(key, parentParent.key, parentIndex, options);\n  } else if (isLast) {\n    // Just move the node after its parent.\n    transform.moveNodeByKey(key, parentParent.key, parentIndex + 1, options);\n  } else {\n    var parentPath = document.getPath(parent.key);\n    // Split the parent.\n    transform.splitNodeOperation(parentPath, index);\n    // Extract the node in between the splitted parent.\n    transform.moveNodeByKey(key, parentParent.key, parentIndex + 1, { normalize: false });\n\n    if (normalize) {\n      transform.normalizeNodeByKey(parentParent.key, _core2.default);\n    }\n  }\n};\n\n/**\n * Wrap a node in an inline with `properties`.\n *\n * @param {Transform} transform\n * @param {String} key The node to wrap\n * @param {Block|Object|String} inline The wrapping inline (its children are discarded)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.wrapInlineByKey = function (transform, key, inline, options) {\n  inline = _normalize2.default.inline(inline);\n  inline = inline.set('nodes', inline.nodes.clear());\n\n  var document = transform.state.document;\n\n  var node = document.assertDescendant(key);\n  var parent = document.getParent(node.key);\n  var index = parent.nodes.indexOf(node);\n\n  transform.insertNodeByKey(parent.key, index, inline, { normalize: false });\n  transform.moveNodeByKey(node.key, inline.key, 0, options);\n};\n\n/**\n * Wrap a node in a block with `properties`.\n *\n * @param {Transform} transform\n * @param {String} key The node to wrap\n * @param {Block|Object|String} block The wrapping block (its children are discarded)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nTransforms.wrapBlockByKey = function (transform, key, block, options) {\n  block = _normalize2.default.block(block);\n  block = block.set('nodes', block.nodes.clear());\n\n  var document = transform.state.document;\n\n  var node = document.assertDescendant(key);\n  var parent = document.getParent(node.key);\n  var index = parent.nodes.indexOf(node);\n\n  transform.insertNodeByKey(parent.key, index, block, { normalize: false });\n  transform.moveNodeByKey(node.key, block.key, 0, options);\n};\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Transforms;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/transforms/call.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Transforms.\n *\n * @type {Object}\n */\n\nvar Transforms = {};\n\n/**\n * Call a `fn` as if it was a core transform. This is a convenience method to\n * make using non-core transforms easier to read and chain.\n *\n * @param {Transform} transform\n * @param {Function} fn\n * @param {Mixed} ...args\n */\n\nTransforms.call = function (transform, fn) {\n  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  fn.apply(undefined, [transform].concat(args));\n  return;\n};\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Transforms;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/transforms/normalize.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _normalize = require('../utils/normalize');\n\nvar _normalize2 = _interopRequireDefault(_normalize);\n\nvar _schema = require('../models/schema');\n\nvar _schema2 = _interopRequireDefault(_schema);\n\nvar _warn = require('../utils/warn');\n\nvar _warn2 = _interopRequireDefault(_warn);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Transforms.\n *\n * @type {Object}\n */\n\nvar Transforms = {};\n\n/**\n * Normalize the document and selection with a `schema`.\n *\n * @param {Transform} transform\n * @param {Schema} schema\n */\n\nTransforms.normalize = function (transform, schema) {\n  transform.normalizeDocument(schema);\n  transform.normalizeSelection(schema);\n};\n\n/**\n * Normalize the document with a `schema`.\n *\n * @param {Transform} transform\n * @param {Schema} schema\n */\n\nTransforms.normalizeDocument = function (transform, schema) {\n  var state = transform.state;\n  var document = state.document;\n\n  transform.normalizeNodeByKey(document.key, schema);\n};\n\n/**\n * Normalize a `node` and its children with a `schema`.\n *\n * @param {Transform} transform\n * @param {Node|String} key\n * @param {Schema} schema\n */\n\nTransforms.normalizeNodeByKey = function (transform, key, schema) {\n  assertSchema(schema);\n\n  // If the schema has no validation rules, there's nothing to normalize.\n  if (!schema.hasValidators) return;\n\n  key = _normalize2.default.key(key);\n  var state = transform.state;\n  var document = state.document;\n\n  var node = document.assertNode(key);\n\n  normalizeNodeAndChildren(transform, node, schema);\n};\n\n/**\n * Normalize the selection.\n *\n * @param {Transform} transform\n */\n\nTransforms.normalizeSelection = function (transform) {\n  var state = transform.state;\n  var _state = state,\n      document = _state.document,\n      selection = _state.selection;\n\n  // If document is empty, return\n\n  if (document.nodes.size === 0) {\n    return;\n  }\n\n  selection = selection.normalize(document);\n\n  // If the selection is unset, or the anchor or focus key in the selection are\n  // pointing to nodes that no longer exist, warn (if not unset) and reset the selection.\n  if (selection.isUnset || !document.hasDescendant(selection.anchorKey) || !document.hasDescendant(selection.focusKey)) {\n    if (!selection.isUnset) {\n      (0, _warn2.default)('The selection was invalid and was reset to start of the document. The selection in question was:', selection);\n    }\n\n    var firstText = document.getFirstText();\n    selection = selection.merge({\n      anchorKey: firstText.key,\n      anchorOffset: 0,\n      focusKey: firstText.key,\n      focusOffset: 0,\n      isBackward: false\n    });\n  }\n\n  state = state.set('selection', selection);\n  transform.state = state;\n};\n\n/**\n * Normalize a `node` and its children with a `schema`.\n *\n * @param {Transform} transform\n * @param {Node} node\n * @param {Schema} schema\n */\n\nfunction normalizeNodeAndChildren(transform, node, schema) {\n  if (node.kind == 'text') {\n    normalizeNode(transform, node, schema);\n    return;\n  }\n\n  // We can't just loop the children and normalize them, because in the process\n  // of normalizing one child, we might end up creating another. Instead, we\n  // have to normalize one at a time, and check for new children along the way.\n  // PERF: use a mutable array here instead of an immutable stack.\n  var keys = node.nodes.toArray().map(function (n) {\n    return n.key;\n  });\n\n  // While there is still a child key that hasn't been normalized yet...\n\n  var _loop = function _loop() {\n    var ops = transform.operations.length;\n    var key = void 0;\n\n    // PERF: use a mutable set here since we'll be add to it a lot.\n    var set = new _immutable.Set().asMutable();\n\n    // Unwind the stack, normalizing every child and adding it to the set.\n    while (key = keys[0]) {\n      var child = node.getChild(key);\n      normalizeNodeAndChildren(transform, child, schema);\n      set.add(key);\n      keys.shift();\n    }\n\n    // Turn the set immutable to be able to compare against it.\n    set = set.asImmutable();\n\n    // PERF: Only re-find the node and re-normalize any new children if\n    // operations occured that might have changed it.\n    if (transform.operations.length != ops) {\n      node = refindNode(transform, node);\n\n      // Add any new children back onto the stack.\n      node.nodes.forEach(function (n) {\n        if (set.has(n.key)) return;\n        keys.unshift(n.key);\n      });\n    }\n  };\n\n  while (keys.length) {\n    _loop();\n  }\n\n  // Normalize the node itself if it still exists.\n  if (node) {\n    normalizeNode(transform, node, schema);\n  }\n}\n\n/**\n * Re-find a reference to a node that may have been modified or removed\n * entirely by a transform.\n *\n * @param {Transform} transform\n * @param {Node} node\n * @return {Node}\n */\n\nfunction refindNode(transform, node) {\n  var state = transform.state;\n  var document = state.document;\n\n  return node.kind == 'document' ? document : document.getDescendant(node.key);\n}\n\n/**\n * Normalize a `node` with a `schema`, but not its children.\n *\n * @param {Transform} transform\n * @param {Node} node\n * @param {Schema} schema\n */\n\nfunction normalizeNode(transform, node, schema) {\n  var max = schema.rules.length;\n  var iterations = 0;\n\n  function iterate(t, n) {\n    var failure = n.validate(schema);\n    if (!failure) return;\n\n    // Run the `normalize` function for the rule with the invalid value.\n    var value = failure.value,\n        rule = failure.rule;\n\n    rule.normalize(t, n, value);\n\n    // Re-find the node reference, in case it was updated. If the node no longer\n    // exists, we're done for this branch.\n    n = refindNode(t, n);\n    if (!n) return;\n\n    // Increment the iterations counter, and check to make sure that we haven't\n    // exceeded the max. Without this check, it's easy for the `validate` or\n    // `normalize` function of a schema rule to be written incorrectly and for\n    // an infinite invalid loop to occur.\n    iterations++;\n\n    if (iterations > max) {\n      throw new Error('A schema rule could not be validated after sufficient iterations. This is usually due to a `rule.validate` or `rule.normalize` function of a schema being incorrectly written, causing an infinite loop.');\n    }\n\n    // Otherwise, iterate again.\n    iterate(t, n);\n  }\n\n  iterate(transform, node);\n}\n\n/**\n * Assert that a `schema` exists.\n *\n * @param {Schema} schema\n */\n\nfunction assertSchema(schema) {\n  if (schema instanceof _schema2.default) {\n    return;\n  } else if (schema == null) {\n    throw new Error('You must pass a `schema` object.');\n  } else {\n    throw new Error('You passed an invalid `schema` object: ' + schema + '.');\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Transforms;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/transforms/on-history.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Transforms.\n *\n * @type {Object}\n */\n\nvar Transforms = {};\n\n/**\n * Redo to the next state in the history.\n *\n * @param {Transform} transform\n */\n\nTransforms.redo = function (transform) {\n  var state = transform.state;\n  var _state = state,\n      history = _state.history;\n  var _history = history,\n      undos = _history.undos,\n      redos = _history.redos;\n\n  // If there's no next snapshot, abort.\n\n  var next = redos.peek();\n  if (!next) return;\n\n  // Shift the next state into the undo stack.\n  redos = redos.pop();\n  undos = undos.push(next);\n\n  // Replay the next operations.\n  next.forEach(function (op) {\n    transform.applyOperation(op);\n  });\n\n  // Update the history.\n  state = transform.state;\n  history = history.set('undos', undos).set('redos', redos);\n  state = state.set('history', history);\n\n  // Update the transform.\n  transform.state = state;\n};\n\n/**\n * Save the operations into the history.\n *\n * @param {Transform} transform\n * @param {Object} options\n */\n\nTransforms.save = function (transform) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$merge = options.merge,\n      merge = _options$merge === undefined ? false : _options$merge;\n  var state = transform.state,\n      operations = transform.operations;\n  var _state2 = state,\n      history = _state2.history;\n  var _history2 = history,\n      undos = _history2.undos,\n      redos = _history2.redos;\n\n  // If there are no operations, abort.\n\n  if (!operations.length) return;\n\n  // Create a new save point or merge the operations into the previous one.\n  if (merge) {\n    var previous = undos.peek();\n    undos = undos.pop();\n    previous = previous.concat(operations);\n    undos = undos.push(previous);\n  } else {\n    undos = undos.push(operations);\n  }\n\n  // Clear the redo stack and constrain the undos stack.\n  if (undos.size > 100) undos = undos.take(100);\n  redos = redos.clear();\n\n  // Update the state.\n  history = history.set('undos', undos).set('redos', redos);\n  state = state.set('history', history);\n\n  // Update the transform.\n  transform.state = state;\n};\n\n/**\n * Undo the previous operations in the history.\n *\n * @param {Transform} transform\n */\n\nTransforms.undo = function (transform) {\n  var state = transform.state;\n  var _state3 = state,\n      history = _state3.history;\n  var _history3 = history,\n      undos = _history3.undos,\n      redos = _history3.redos;\n\n  // If there's no previous snapshot, abort.\n\n  var previous = undos.peek();\n  if (!previous) return;\n\n  // Shift the previous operations into the redo stack.\n  undos = undos.pop();\n  redos = redos.push(previous);\n\n  // Replay the inverse of the previous operations.\n  previous.slice().reverse().forEach(function (op) {\n    op.inverse.forEach(function (inv) {\n      transform.applyOperation(inv);\n    });\n  });\n\n  // Update the history.\n  state = transform.state;\n  history = history.set('undos', undos).set('redos', redos);\n  state = state.set('history', history);\n\n  // Update the transform.\n  transform.state = state;\n};\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Transforms;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/transforms/on-selection.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _warn = require('../utils/warn');\n\nvar _warn2 = _interopRequireDefault(_warn);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Transforms.\n *\n * @type {Object}\n */\n\nvar Transforms = {};\n\n/**\n * Set `properties` on the selection.\n *\n * @param {Transform} transform\n * @param {Object} properties\n */\n\nTransforms.select = function (transform, properties) {\n  transform.setSelectionOperation(properties);\n};\n\n/**\n * Selects the whole selection.\n *\n * @param {Transform} transform\n * @param {Object} properties\n */\n\nTransforms.selectAll = function (transform) {\n  var state = transform.state;\n  var document = state.document,\n      selection = state.selection;\n\n  var next = selection.moveToRangeOf(document);\n  transform.setSelectionOperation(next);\n};\n\n/**\n * Snapshot the current selection.\n *\n * @param {Transform} transform\n */\n\nTransforms.snapshotSelection = function (transform) {\n  var state = transform.state;\n  var selection = state.selection;\n\n  transform.setSelectionOperation(selection, { snapshot: true });\n};\n\n/**\n * Set `properties` on the selection.\n *\n * @param {Mixed} ...args\n * @param {Transform} transform\n */\n\nTransforms.moveTo = function (transform, properties) {\n  (0, _warn2.default)('The `moveTo()` transform is deprecated, please use `select()` instead.');\n  transform.select(properties);\n};\n\n/**\n * Unset the selection's marks.\n *\n * @param {Transform} transform\n */\n\nTransforms.unsetMarks = function (transform) {\n  (0, _warn2.default)('The `unsetMarks()` transform is deprecated.');\n  transform.setSelectionOperation({ marks: null });\n};\n\n/**\n * Unset the selection, removing an association to a node.\n *\n * @param {Transform} transform\n */\n\nTransforms.unsetSelection = function (transform) {\n  (0, _warn2.default)('The `unsetSelection()` transform is deprecated, please use `deselect()` instead.');\n  transform.setSelectionOperation({\n    anchorKey: null,\n    anchorOffset: 0,\n    focusKey: null,\n    focusOffset: 0,\n    isFocused: false,\n    isBackward: false\n  });\n};\n\n/**\n * Mix in selection transforms that are just a proxy for the selection method.\n */\n\nvar PROXY_TRANSFORMS = ['blur', 'collapseTo', 'collapseToAnchor', 'collapseToEnd', 'collapseToEndOf', 'collapseToFocus', 'collapseToStart', 'collapseToStartOf', 'extend', 'extendTo', 'extendToEndOf', 'extendToStartOf', 'flip', 'focus', 'move', 'moveAnchor', 'moveAnchorOffsetTo', 'moveAnchorTo', 'moveAnchorToEndOf', 'moveAnchorToStartOf', 'moveEnd', 'moveEndOffsetTo', 'moveEndTo', 'moveFocus', 'moveFocusOffsetTo', 'moveFocusTo', 'moveFocusToEndOf', 'moveFocusToStartOf', 'moveOffsetsTo', 'moveStart', 'moveStartOffsetTo', 'moveStartTo',\n// 'moveTo', Commented out for now, since it conflicts with a deprecated one.\n'moveToEnd', 'moveToEndOf', 'moveToRangeOf', 'moveToStart', 'moveToStartOf', 'deselect'];\n\nPROXY_TRANSFORMS.forEach(function (method) {\n  Transforms[method] = function (transform) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var normalize = method != 'deselect';\n    var state = transform.state;\n    var document = state.document,\n        selection = state.selection;\n\n    var next = selection[method].apply(selection, args);\n    if (normalize) next = next.normalize(document);\n    transform.setSelectionOperation(next);\n  };\n});\n\n/**\n * Mix in node-related transforms.\n */\n\nvar PREFIXES = ['moveTo', 'collapseTo', 'extendTo'];\n\nvar DIRECTIONS = ['Next', 'Previous'];\n\nvar KINDS = ['Block', 'Inline', 'Text'];\n\nPREFIXES.forEach(function (prefix) {\n  var edges = ['Start', 'End'];\n\n  if (prefix == 'moveTo') {\n    edges.push('Range');\n  }\n\n  edges.forEach(function (edge) {\n    DIRECTIONS.forEach(function (direction) {\n      KINDS.forEach(function (kind) {\n        var get = 'get' + direction + kind;\n        var getAtRange = 'get' + kind + 'sAtRange';\n        var index = direction == 'Next' ? 'last' : 'first';\n        var method = '' + prefix + edge + 'Of';\n        var name = '' + method + direction + kind;\n\n        Transforms[name] = function (transform) {\n          var state = transform.state;\n          var document = state.document,\n              selection = state.selection;\n\n          var nodes = document[getAtRange](selection);\n          var node = nodes[index]();\n          var target = document[get](node.key);\n          if (!target) return;\n          var next = selection[method](target);\n          transform.setSelectionOperation(next);\n        };\n      });\n    });\n  });\n});\n\n/**\n * Mix in deprecated transforms with a warning.\n */\n\nvar DEPRECATED_TRANSFORMS = [['extendBackward', 'extend', 'The `extendBackward(n)` transform is deprecated, please use `extend(n)` instead with a negative offset.'], ['extendForward', 'extend', 'The `extendForward(n)` transform is deprecated, please use `extend(n)` instead.'], ['moveBackward', 'move', 'The `moveBackward(n)` transform is deprecated, please use `move(n)` instead with a negative offset.'], ['moveForward', 'move', 'The `moveForward(n)` transform is deprecated, please use `move(n)` instead.'], ['moveStartOffset', 'moveStart', 'The `moveStartOffset(n)` transform is deprecated, please use `moveStart(n)` instead.'], ['moveEndOffset', 'moveEnd', 'The `moveEndOffset(n)` transform is deprecated, please use `moveEnd()` instead.'], ['moveToOffsets', 'moveOffsetsTo', 'The `moveToOffsets()` transform is deprecated, please use `moveOffsetsTo()` instead.'], ['flipSelection', 'flip', 'The `flipSelection()` transform is deprecated, please use `flip()` instead.']];\n\nDEPRECATED_TRANSFORMS.forEach(function (_ref) {\n  var _ref2 = _slicedToArray(_ref, 3),\n      old = _ref2[0],\n      current = _ref2[1],\n      warning = _ref2[2];\n\n  Transforms[old] = function (transform) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    (0, _warn2.default)(warning);\n    var state = transform.state;\n    var document = state.document,\n        selection = state.selection;\n\n    var sel = selection[current].apply(selection, args).normalize(document);\n    transform.setSelectionOperation(sel);\n  };\n});\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Transforms;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/transforms/operations.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _normalize = require('../utils/normalize');\n\nvar _normalize2 = _interopRequireDefault(_normalize);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Transforms.\n *\n * @type {Object}\n */\n\nvar Transforms = {};\n\n/**\n * Add mark to text at `offset` and `length` in node by `path`.\n *\n * @param {Transform} transform\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mixed} mark\n */\n\nTransforms.addMarkOperation = function (transform, path, offset, length, mark) {\n  var inverse = [{\n    type: 'remove_mark',\n    path: path,\n    offset: offset,\n    length: length,\n    mark: mark\n  }];\n\n  var operation = {\n    type: 'add_mark',\n    path: path,\n    offset: offset,\n    length: length,\n    mark: mark,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Insert a `node` at `index` in a node by `path`.\n *\n * @param {Transform} transform\n * @param {Array} path\n * @param {Number} index\n * @param {Node} node\n */\n\nTransforms.insertNodeOperation = function (transform, path, index, node) {\n  var inversePath = path.slice().concat([index]);\n  var inverse = [{\n    type: 'remove_node',\n    path: inversePath\n  }];\n\n  var operation = {\n    type: 'insert_node',\n    path: path,\n    index: index,\n    node: node,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {Transform} transform\n * @param {Array} path\n * @param {Number} offset\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nTransforms.insertTextOperation = function (transform, path, offset, text, marks) {\n  var inverseLength = text.length;\n  var inverse = [{\n    type: 'remove_text',\n    path: path,\n    offset: offset,\n    length: inverseLength\n  }];\n\n  var operation = {\n    type: 'insert_text',\n    path: path,\n    offset: offset,\n    text: text,\n    marks: marks,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Join a node by `path` with a node `withPath`.\n *\n * @param {Transform} transform\n * @param {Array} path\n * @param {Array} withPath\n */\n\nTransforms.joinNodeOperation = function (transform, path, withPath) {\n  var state = transform.state;\n  var document = state.document;\n\n  var node = document.assertPath(withPath);\n\n  var inverse = void 0;\n  if (node.kind === 'text') {\n    var offset = node.length;\n\n    inverse = [{\n      type: 'split_node',\n      path: withPath,\n      offset: offset\n    }];\n  } else {\n    // The number of children after which we split\n    var count = node.nodes.count();\n\n    inverse = [{\n      type: 'split_node',\n      path: withPath,\n      count: count\n    }];\n  }\n\n  var operation = {\n    type: 'join_node',\n    path: path,\n    withPath: withPath,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Move a node by `path` to a `newPath` and `newIndex`.\n *\n * @param {Transform} transform\n * @param {Array} path\n * @param {Array} newPath\n * @param {Number} newIndex\n */\n\nTransforms.moveNodeOperation = function (transform, path, newPath, newIndex) {\n  var parentPath = path.slice(0, -1);\n  var parentIndex = path[path.length - 1];\n  var inversePath = newPath.slice().concat([newIndex]);\n\n  var inverse = [{\n    type: 'move_node',\n    path: inversePath,\n    newPath: parentPath,\n    newIndex: parentIndex\n  }];\n\n  var operation = {\n    type: 'move_node',\n    path: path,\n    newPath: newPath,\n    newIndex: newIndex,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Remove mark from text at `offset` and `length` in node by `path`.\n *\n * @param {Transform} transform\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n */\n\nTransforms.removeMarkOperation = function (transform, path, offset, length, mark) {\n  var inverse = [{\n    type: 'add_mark',\n    path: path,\n    offset: offset,\n    length: length,\n    mark: mark\n  }];\n\n  var operation = {\n    type: 'remove_mark',\n    path: path,\n    offset: offset,\n    length: length,\n    mark: mark,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Remove a node by `path`.\n *\n * @param {Transform} transform\n * @param {Array} path\n */\n\nTransforms.removeNodeOperation = function (transform, path) {\n  var state = transform.state;\n  var document = state.document;\n\n  var node = document.assertPath(path);\n  var inversePath = path.slice(0, -1);\n  var inverseIndex = path[path.length - 1];\n\n  var inverse = [{\n    type: 'insert_node',\n    path: inversePath,\n    index: inverseIndex,\n    node: node\n  }];\n\n  var operation = {\n    type: 'remove_node',\n    path: path,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Remove text at `offset` and `length` in node by `path`.\n *\n * @param {Transform} transform\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n */\n\nTransforms.removeTextOperation = function (transform, path, offset, length) {\n  var state = transform.state;\n  var document = state.document;\n\n  var node = document.assertPath(path);\n  var ranges = node.getRanges();\n  var inverse = [];\n\n  // Loop the ranges of text in the node, creating inverse insert operations for\n  // each of the ranges that overlap with the remove operation. This is\n  // necessary because insert's can only have a single set of marks associated\n  // with them, but removes can remove many.\n  ranges.reduce(function (start, range) {\n    var text = range.text,\n        marks = range.marks;\n\n    var end = start + text.length;\n    if (start > offset + length) return end;\n    if (end <= offset) return end;\n\n    var endOffset = Math.min(end, offset + length);\n    var string = text.slice(offset - start, endOffset - start);\n\n    inverse.push({\n      type: 'insert_text',\n      path: path,\n      offset: offset,\n      text: string,\n      marks: marks\n    });\n\n    return end;\n  }, 0);\n\n  var operation = {\n    type: 'remove_text',\n    path: path,\n    offset: offset,\n    length: length,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Set `properties` on mark on text at `offset` and `length` in node by `path`.\n *\n * @param {Transform} transform\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n * @param {Mark} newMark\n */\n\nTransforms.setMarkOperation = function (transform, path, offset, length, mark, newMark) {\n  var inverse = [{\n    type: 'set_mark',\n    path: path,\n    offset: offset,\n    length: length,\n    mark: newMark,\n    newMark: mark\n  }];\n\n  var operation = {\n    type: 'set_mark',\n    path: path,\n    offset: offset,\n    length: length,\n    mark: mark,\n    newMark: newMark,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Set `properties` on a node by `path`.\n *\n * @param {Transform} transform\n * @param {Array} path\n * @param {Object} properties\n */\n\nTransforms.setNodeOperation = function (transform, path, properties) {\n  var state = transform.state;\n  var document = state.document;\n\n  var node = document.assertPath(path);\n  var inverseProps = {};\n\n  for (var k in properties) {\n    inverseProps[k] = node[k];\n  }\n\n  var inverse = [{\n    type: 'set_node',\n    path: path,\n    properties: inverseProps\n  }];\n\n  var operation = {\n    type: 'set_node',\n    path: path,\n    properties: properties,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Set the selection to a new `selection`.\n *\n * @param {Transform} transform\n * @param {Mixed} selection\n */\n\nTransforms.setSelectionOperation = function (transform, properties) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  properties = _normalize2.default.selectionProperties(properties);\n\n  var state = transform.state;\n  var document = state.document,\n      selection = state.selection;\n\n  var prevProps = {};\n  var props = {};\n\n  // Remove any properties that are already equal to the current selection. And\n  // create a dictionary of the previous values for all of the properties that\n  // are being changed, for the inverse operation.\n  for (var k in properties) {\n    if (!options.snapshot && properties[k] == selection[k]) continue;\n    props[k] = properties[k];\n    prevProps[k] = selection[k];\n  }\n\n  // If the selection moves, clear any marks, unless the new selection\n  // does change the marks in some way\n  var moved = ['anchorKey', 'anchorOffset', 'focusKey', 'focusOffset'].some(function (p) {\n    return props.hasOwnProperty(p);\n  });\n\n  if (selection.marks && properties.marks == selection.marks && moved) {\n    props.marks = null;\n  }\n\n  // Resolve the selection keys into paths.\n  if (props.anchorKey) {\n    props.anchorPath = document.getPath(props.anchorKey);\n    delete props.anchorKey;\n  }\n\n  if (prevProps.anchorKey) {\n    prevProps.anchorPath = document.getPath(prevProps.anchorKey);\n    delete prevProps.anchorKey;\n  }\n\n  if (props.focusKey) {\n    props.focusPath = document.getPath(props.focusKey);\n    delete props.focusKey;\n  }\n\n  if (prevProps.focusKey) {\n    prevProps.focusPath = document.getPath(prevProps.focusKey);\n    delete prevProps.focusKey;\n  }\n\n  // Define an inverse of the operation for undoing.\n  var inverse = [{\n    type: 'set_selection',\n    properties: prevProps\n  }];\n\n  // Define the operation.\n  var operation = {\n    type: 'set_selection',\n    properties: props,\n    inverse: inverse\n  };\n\n  // Apply the operation.\n  transform.applyOperation(operation);\n};\n\n/**\n * Split a node by `path` at `offset`.\n *\n * @param {Transform} transform\n * @param {Array} path\n * @param {Number} offset\n */\n\nTransforms.splitNodeAtOffsetOperation = function (transform, path, offset) {\n  var inversePath = path.slice();\n  inversePath[path.length - 1] += 1;\n\n  var inverse = [{\n    type: 'join_node',\n    path: inversePath,\n    withPath: path,\n    // We will split down to the text nodes, so we must join nodes recursively.\n    deep: true\n  }];\n\n  var operation = {\n    type: 'split_node',\n    path: path,\n    offset: offset,\n    count: null,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Split a node by `path` after its 'count' child.\n *\n * @param {Transform} transform\n * @param {Array} path\n * @param {Number} count\n */\n\nTransforms.splitNodeOperation = function (transform, path, count) {\n  var inversePath = path.slice();\n  inversePath[path.length - 1] += 1;\n\n  var inverse = [{\n    type: 'join_node',\n    path: inversePath,\n    withPath: path,\n    deep: false\n  }];\n\n  var operation = {\n    type: 'split_node',\n    path: path,\n    offset: null,\n    count: count,\n    inverse: inverse\n  };\n\n  transform.applyOperation(operation);\n};\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = Transforms;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/components/content.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _base = require('../serializers/base-64');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _node = require('./node');\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _getPoint = require('../utils/get-point');\n\nvar _getPoint2 = _interopRequireDefault(_getPoint);\n\nvar _extendSelection = require('../utils/extend-selection');\n\nvar _extendSelection2 = _interopRequireDefault(_extendSelection);\n\nvar _findClosestNode = require('../utils/find-closest-node');\n\nvar _findClosestNode2 = _interopRequireDefault(_findClosestNode);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _selection = require('../models/selection');\n\nvar _selection2 = _interopRequireDefault(_selection);\n\nvar _getTransferData = require('../utils/get-transfer-data');\n\nvar _getTransferData2 = _interopRequireDefault(_getTransferData);\n\nvar _types = require('../constants/types');\n\nvar _types2 = _interopRequireDefault(_types);\n\nvar _getWindow = require('get-window');\n\nvar _getWindow2 = _interopRequireDefault(_getWindow);\n\nvar _findDeepestNode = require('../utils/find-deepest-node');\n\nvar _findDeepestNode2 = _interopRequireDefault(_findDeepestNode);\n\nvar _keycode = require('keycode');\n\nvar _keycode2 = _interopRequireDefault(_keycode);\n\nvar _environment = require('../constants/environment');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = (0, _debug2.default)('slate:content');\n\n/**\n * Content.\n *\n * @type {Component}\n */\n\nvar Content = function (_React$Component) {\n  _inherits(Content, _React$Component);\n\n  /**\n   * Constructor.\n   *\n   * @param {Object} props\n   */\n\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  function Content(props) {\n    _classCallCheck(this, Content);\n\n    var _this = _possibleConstructorReturn(this, (Content.__proto__ || Object.getPrototypeOf(Content)).call(this, props));\n\n    _initialiseProps.call(_this);\n\n    _this.tmp = {};\n    _this.tmp.compositions = 0;\n    _this.tmp.forces = 0;\n    return _this;\n  }\n\n  /**\n   * Should the component update?\n   *\n   * @param {Object} props\n   * @param {Object} state\n   * @return {Boolean}\n   */\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * On mount, update the selection, and focus the editor if `autoFocus` is set.\n   */\n\n  /**\n   * On update, update the selection.\n   */\n\n  /**\n   * Update the native DOM selection to reflect the internal model.\n   */\n\n  /**\n   * The React ref method to set the root content element locally.\n   *\n   * @param {Element} n\n   */\n\n  /**\n   * Check if an `event` is being fired from within the contenteditable element.\n   * This will return false for edits happening in non-contenteditable children,\n   * such as void nodes and other nested Slate editors.\n   *\n   * @param {Event} event\n   * @return {Boolean}\n   */\n\n  /**\n   * On before input, bubble up.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On blur, update the selection to be not focused.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On focus, update the selection to be focused.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On change, bubble up.\n   *\n   * @param {State} state\n   */\n\n  /**\n   * On composition start, set the `isComposing` flag.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On composition end, remove the `isComposing` flag on the next tick. Also\n   * increment the `forces` key, which will force the contenteditable element\n   * to completely re-render, since IME puts React in an unreconcilable state.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On copy, defer to `onCutCopy`, then bubble up.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On cut, defer to `onCutCopy`, then bubble up.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On drag end, unset the `isDragging` flag.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On drag over, set the `isDragging` flag and the `isInternalDrag` flag.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On drag start, set the `isDragging` flag and the `isInternalDrag` flag.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On input, handle spellcheck and other similar edits that don't go trigger\n   * the `onBeforeInput` and instead update the DOM directly.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On key down, prevent the default behavior of certain commands that will\n   * leave the editor in an out-of-sync state, then bubble up.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On key up, unset the `isShifting` flag.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On paste, determine the type and bubble up.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * On select, update the current state's selection.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * Render the editor content.\n   *\n   * @return {Element}\n   */\n\n  /**\n   * Render a `node`.\n   *\n   * @param {Node} node\n   * @return {Element}\n   */\n\n  return Content;\n}(_react2.default.Component);\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nContent.propTypes = {\n  autoCorrect: _react2.default.PropTypes.bool.isRequired,\n  autoFocus: _react2.default.PropTypes.bool.isRequired,\n  children: _react2.default.PropTypes.array.isRequired,\n  className: _react2.default.PropTypes.string,\n  editor: _react2.default.PropTypes.object.isRequired,\n  onBeforeInput: _react2.default.PropTypes.func.isRequired,\n  onBlur: _react2.default.PropTypes.func.isRequired,\n  onChange: _react2.default.PropTypes.func.isRequired,\n  onCopy: _react2.default.PropTypes.func.isRequired,\n  onCut: _react2.default.PropTypes.func.isRequired,\n  onDrop: _react2.default.PropTypes.func.isRequired,\n  onFocus: _react2.default.PropTypes.func.isRequired,\n  onKeyDown: _react2.default.PropTypes.func.isRequired,\n  onPaste: _react2.default.PropTypes.func.isRequired,\n  onSelect: _react2.default.PropTypes.func.isRequired,\n  readOnly: _react2.default.PropTypes.bool.isRequired,\n  role: _react2.default.PropTypes.string,\n  schema: _react2.default.PropTypes.object,\n  spellCheck: _react2.default.PropTypes.bool.isRequired,\n  state: _react2.default.PropTypes.object.isRequired,\n  style: _react2.default.PropTypes.object,\n  tabIndex: _react2.default.PropTypes.number\n};\nContent.defaultProps = {\n  style: {}\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this2 = this;\n\n  this.shouldComponentUpdate = function (props, state) {\n    // If the readOnly state has changed, we need to re-render so that\n    // the cursor will be added or removed again.\n    if (props.readOnly != _this2.props.readOnly) return true;\n\n    // If the state has been transformed natively, never re-render, or else we\n    // will end up duplicating content.\n    if (props.state.isNative) return false;\n\n    return props.className != _this2.props.className || props.schema != _this2.props.schema || props.autoCorrect != _this2.props.autoCorrect || props.spellCheck != _this2.props.spellCheck || props.state != _this2.props.state || props.style != _this2.props.style;\n  };\n\n  this.componentDidMount = function () {\n    _this2.updateSelection();\n\n    if (_this2.props.autoFocus) {\n      _this2.element.focus();\n    }\n  };\n\n  this.componentDidUpdate = function () {\n    _this2.updateSelection();\n  };\n\n  this.updateSelection = function () {\n    var _props = _this2.props,\n        editor = _props.editor,\n        state = _props.state;\n    var document = state.document,\n        selection = state.selection;\n\n    var window = (0, _getWindow2.default)(_this2.element);\n    var native = window.getSelection();\n\n    // If both selections are blurred, do nothing.\n    if (!native.rangeCount && selection.isBlurred) return;\n\n    // If the selection has been blurred, but hasn't been updated in the DOM,\n    // blur the DOM selection.\n    if (selection.isBlurred) {\n      if (!_this2.element.contains(native.anchorNode)) return;\n      native.removeAllRanges();\n      _this2.element.blur();\n      debug('updateSelection', { selection: selection, native: native });\n      return;\n    }\n\n    // Otherwise, figure out which DOM nodes should be selected...\n    var anchorText = state.anchorText,\n        focusText = state.focusText;\n    var anchorKey = selection.anchorKey,\n        anchorOffset = selection.anchorOffset,\n        focusKey = selection.focusKey,\n        focusOffset = selection.focusOffset;\n\n    var schema = editor.getSchema();\n    var anchorDecorators = document.getDescendantDecorators(anchorKey, schema);\n    var focusDecorators = document.getDescendantDecorators(focusKey, schema);\n    var anchorRanges = anchorText.getRanges(anchorDecorators);\n    var focusRanges = focusText.getRanges(focusDecorators);\n    var a = 0;\n    var f = 0;\n    var anchorIndex = void 0;\n    var focusIndex = void 0;\n    var anchorOff = void 0;\n    var focusOff = void 0;\n\n    anchorRanges.forEach(function (range, i, ranges) {\n      var length = range.text.length;\n\n      a += length;\n      if (a < anchorOffset) return;\n      anchorIndex = i;\n      anchorOff = anchorOffset - (a - length);\n      return false;\n    });\n\n    focusRanges.forEach(function (range, i, ranges) {\n      var length = range.text.length;\n\n      f += length;\n      if (f < focusOffset) return;\n      focusIndex = i;\n      focusOff = focusOffset - (f - length);\n      return false;\n    });\n\n    var anchorSpan = _this2.element.querySelector('[data-offset-key=\"' + anchorKey + '-' + anchorIndex + '\"]');\n    var focusSpan = _this2.element.querySelector('[data-offset-key=\"' + focusKey + '-' + focusIndex + '\"]');\n    var anchorEl = (0, _findDeepestNode2.default)(anchorSpan);\n    var focusEl = (0, _findDeepestNode2.default)(focusSpan);\n\n    // If they are already selected, do nothing.\n    if (anchorEl == native.anchorNode && anchorOff == native.anchorOffset && focusEl == native.focusNode && focusOff == native.focusOffset) {\n      return;\n    }\n\n    // Otherwise, set the `isSelecting` flag and update the selection.\n    _this2.tmp.isSelecting = true;\n    native.removeAllRanges();\n    var range = window.document.createRange();\n    range.setStart(anchorEl, anchorOff);\n    native.addRange(range);\n    (0, _extendSelection2.default)(native, focusEl, focusOff);\n\n    // Then unset the `isSelecting` flag after a delay.\n    setTimeout(function () {\n      // COMPAT: In Firefox, it's not enough to create a range, you also need to\n      // focus the contenteditable element too. (2016/11/16)\n      if (_environment.IS_FIREFOX) _this2.element.focus();\n      _this2.tmp.isSelecting = false;\n    });\n\n    debug('updateSelection', { selection: selection, native: native });\n  };\n\n  this.ref = function (element) {\n    _this2.element = element;\n  };\n\n  this.isInEditor = function (event) {\n    var element = _this2.element;\n    var target = event.target;\n\n    return target.isContentEditable && (target == element || (0, _findClosestNode2.default)(target, '[data-slate-editor]') == element);\n  };\n\n  this.onBeforeInput = function (event) {\n    if (_this2.props.readOnly) return;\n    if (!_this2.isInEditor(event)) return;\n\n    var data = {};\n\n    debug('onBeforeInput', { event: event, data: data });\n    _this2.props.onBeforeInput(event, data);\n  };\n\n  this.onBlur = function (event) {\n    if (_this2.props.readOnly) return;\n    if (_this2.tmp.isCopying) return;\n    if (!_this2.isInEditor(event)) return;\n\n    // If the element that is now focused is actually inside the editor, we\n    // need to ignore it. This can happen in situations where there is a nested\n    // `contenteditable=\"true\"` node that isn't another Slate editor.\n    if (_this2.element.contains(event.relatedTarget)) return;\n\n    var data = {};\n\n    debug('onBlur', { event: event, data: data });\n    _this2.props.onBlur(event, data);\n  };\n\n  this.onFocus = function (event) {\n    if (_this2.props.readOnly) return;\n    if (_this2.tmp.isCopying) return;\n    if (!_this2.isInEditor(event)) return;\n\n    // COMPAT: If the editor has nested editable elements, the focus can go to\n    // those elements. In Firefox, this must be prevented because it results in\n    // issues with keyboard navigation. (2017/03/30)\n    if (_environment.IS_FIREFOX && event.target != _this2.element) {\n      _this2.element.focus();\n      return;\n    }\n\n    var data = {};\n\n    debug('onFocus', { event: event, data: data });\n    _this2.props.onFocus(event, data);\n  };\n\n  this.onChange = function (state) {\n    debug('onChange', state);\n    _this2.props.onChange(state);\n  };\n\n  this.onCompositionStart = function (event) {\n    if (!_this2.isInEditor(event)) return;\n\n    _this2.tmp.isComposing = true;\n    _this2.tmp.compositions++;\n\n    debug('onCompositionStart', { event: event });\n  };\n\n  this.onCompositionEnd = function (event) {\n    if (!_this2.isInEditor(event)) return;\n\n    _this2.tmp.forces++;\n    var count = _this2.tmp.compositions;\n\n    // The `count` check here ensures that if another composition starts\n    // before the timeout has closed out this one, we will abort unsetting the\n    // `isComposing` flag, since a composition in still in affect.\n    setTimeout(function () {\n      if (_this2.tmp.compositions > count) return;\n      _this2.tmp.isComposing = false;\n    });\n\n    debug('onCompositionEnd', { event: event });\n  };\n\n  this.onCopy = function (event) {\n    if (!_this2.isInEditor(event)) return;\n    var window = (0, _getWindow2.default)(event.target);\n\n    _this2.tmp.isCopying = true;\n    window.requestAnimationFrame(function () {\n      _this2.tmp.isCopying = false;\n    });\n\n    var state = _this2.props.state;\n\n    var data = {};\n    data.type = 'fragment';\n    data.fragment = state.fragment;\n\n    debug('onCopy', { event: event, data: data });\n    _this2.props.onCopy(event, data);\n  };\n\n  this.onCut = function (event) {\n    if (_this2.props.readOnly) return;\n    if (!_this2.isInEditor(event)) return;\n    var window = (0, _getWindow2.default)(event.target);\n\n    _this2.tmp.isCopying = true;\n    window.requestAnimationFrame(function () {\n      _this2.tmp.isCopying = false;\n    });\n\n    var state = _this2.props.state;\n\n    var data = {};\n    data.type = 'fragment';\n    data.fragment = state.fragment;\n\n    debug('onCut', { event: event, data: data });\n    _this2.props.onCut(event, data);\n  };\n\n  this.onDragEnd = function (event) {\n    if (!_this2.isInEditor(event)) return;\n\n    _this2.tmp.isDragging = false;\n    _this2.tmp.isInternalDrag = null;\n\n    debug('onDragEnd', { event: event });\n  };\n\n  this.onDragOver = function (event) {\n    if (!_this2.isInEditor(event)) return;\n\n    var dataTransfer = event.nativeEvent.dataTransfer;\n\n    var data = (0, _getTransferData2.default)(dataTransfer);\n\n    // Prevent default when nodes are dragged to allow dropping.\n    if (data.type == 'node') {\n      event.preventDefault();\n    }\n\n    if (_this2.tmp.isDragging) return;\n    _this2.tmp.isDragging = true;\n    _this2.tmp.isInternalDrag = false;\n\n    debug('onDragOver', { event: event });\n  };\n\n  this.onDragStart = function (event) {\n    if (!_this2.isInEditor(event)) return;\n\n    _this2.tmp.isDragging = true;\n    _this2.tmp.isInternalDrag = true;\n    var dataTransfer = event.nativeEvent.dataTransfer;\n\n    var data = (0, _getTransferData2.default)(dataTransfer);\n\n    // If it's a node being dragged, the data type is already set.\n    if (data.type == 'node') return;\n\n    var state = _this2.props.state;\n    var fragment = state.fragment;\n\n    var encoded = _base2.default.serializeNode(fragment);\n    dataTransfer.setData(_types2.default.FRAGMENT, encoded);\n\n    debug('onDragStart', { event: event });\n  };\n\n  this.onDrop = function (event) {\n    if (_this2.props.readOnly) return;\n    if (!_this2.isInEditor(event)) return;\n\n    event.preventDefault();\n\n    var window = (0, _getWindow2.default)(event.target);\n    var _props2 = _this2.props,\n        state = _props2.state,\n        editor = _props2.editor;\n    var nativeEvent = event.nativeEvent;\n    var dataTransfer = nativeEvent.dataTransfer,\n        x = nativeEvent.x,\n        y = nativeEvent.y;\n\n    var data = (0, _getTransferData2.default)(dataTransfer);\n\n    // Resolve the point where the drop occured.\n    var range = void 0;\n\n    // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n    if (window.document.caretRangeFromPoint) {\n      range = window.document.caretRangeFromPoint(x, y);\n    } else {\n      range = window.document.createRange();\n      range.setStart(nativeEvent.rangeParent, nativeEvent.rangeOffset);\n    }\n\n    var _range = range,\n        startContainer = _range.startContainer,\n        startOffset = _range.startOffset;\n\n    var point = (0, _getPoint2.default)(startContainer, startOffset, state, editor);\n    if (!point) return;\n\n    var target = _selection2.default.create({\n      anchorKey: point.key,\n      anchorOffset: point.offset,\n      focusKey: point.key,\n      focusOffset: point.offset,\n      isFocused: true\n    });\n\n    // If the target is inside a void node, abort.\n    if (state.document.hasVoidParent(point.key)) return;\n\n    // Add drop-specific information to the data.\n    data.target = target;\n    data.effect = dataTransfer.dropEffect;\n\n    if (data.type == 'fragment' || data.type == 'node') {\n      data.isInternal = _this2.tmp.isInternalDrag;\n    }\n\n    debug('onDrop', { event: event, data: data });\n    _this2.props.onDrop(event, data);\n  };\n\n  this.onInput = function (event) {\n    if (_this2.tmp.isComposing) return;\n    if (_this2.props.state.isBlurred) return;\n    if (!_this2.isInEditor(event)) return;\n    debug('onInput', { event: event });\n\n    var window = (0, _getWindow2.default)(event.target);\n    var _props3 = _this2.props,\n        state = _props3.state,\n        editor = _props3.editor;\n\n    // Get the selection point.\n\n    var native = window.getSelection();\n    var anchorNode = native.anchorNode,\n        anchorOffset = native.anchorOffset;\n\n    var point = (0, _getPoint2.default)(anchorNode, anchorOffset, state, editor);\n    if (!point) return;\n\n    // Get the range in question.\n    var key = point.key,\n        index = point.index,\n        start = point.start,\n        end = point.end;\n    var document = state.document,\n        selection = state.selection;\n\n    var schema = editor.getSchema();\n    var decorators = document.getDescendantDecorators(key, schema);\n    var node = document.getDescendant(key);\n    var block = document.getClosestBlock(node.key);\n    var ranges = node.getRanges(decorators);\n    var lastText = block.getLastText();\n\n    // Get the text information.\n    var textContent = anchorNode.textContent;\n\n    var lastChar = textContent.charAt(textContent.length - 1);\n    var isLastText = node == lastText;\n    var isLastRange = index == ranges.size - 1;\n\n    // If we're dealing with the last leaf, and the DOM text ends in a new line,\n    // we will have added another new line in <Leaf>'s render method to account\n    // for browsers collapsing a single trailing new lines, so remove it.\n    if (isLastText && isLastRange && lastChar == '\\n') {\n      textContent = textContent.slice(0, -1);\n    }\n\n    // If the text is no different, abort.\n    var range = ranges.get(index);\n    var text = range.text,\n        marks = range.marks;\n\n    if (textContent == text) return;\n\n    // Determine what the selection should be after changing the text.\n    var delta = textContent.length - text.length;\n    var after = selection.collapseToEnd().move(delta);\n\n    // Create an updated state with the text replaced.\n    var next = state.transform().select({\n      anchorKey: key,\n      anchorOffset: start,\n      focusKey: key,\n      focusOffset: end\n    }).delete().insertText(textContent, marks).select(after).apply();\n\n    // Change the current state.\n    _this2.onChange(next);\n  };\n\n  this.onKeyDown = function (event) {\n    if (_this2.props.readOnly) return;\n    if (!_this2.isInEditor(event)) return;\n\n    var altKey = event.altKey,\n        ctrlKey = event.ctrlKey,\n        metaKey = event.metaKey,\n        shiftKey = event.shiftKey,\n        which = event.which;\n\n    var key = (0, _keycode2.default)(which);\n    var data = {};\n\n    // Keep track of an `isShifting` flag, because it's often used to trigger\n    // \"Paste and Match Style\" commands, but isn't available on the event in a\n    // normal paste event.\n    if (key == 'shift') {\n      _this2.tmp.isShifting = true;\n    }\n\n    // When composing, these characters commit the composition but also move the\n    // selection before we're able to handle it, so prevent their default,\n    // selection-moving behavior.\n    if (_this2.tmp.isComposing && (key == 'left' || key == 'right' || key == 'up' || key == 'down')) {\n      event.preventDefault();\n      return;\n    }\n\n    // Add helpful properties for handling hotkeys to the data object.\n    data.code = which;\n    data.key = key;\n    data.isAlt = altKey;\n    data.isCmd = _environment.IS_MAC ? metaKey && !altKey : false;\n    data.isCtrl = ctrlKey && !altKey;\n    data.isLine = _environment.IS_MAC ? metaKey : false;\n    data.isMeta = metaKey;\n    data.isMod = _environment.IS_MAC ? metaKey && !altKey : ctrlKey && !altKey;\n    data.isModAlt = _environment.IS_MAC ? metaKey && altKey : ctrlKey && altKey;\n    data.isShift = shiftKey;\n    data.isWord = _environment.IS_MAC ? altKey : ctrlKey;\n\n    // These key commands have native behavior in contenteditable elements which\n    // will cause our state to be out of sync, so prevent them.\n    if (key == 'enter' || key == 'backspace' || key == 'delete' || key == 'b' && data.isMod || key == 'i' && data.isMod || key == 'y' && data.isMod || key == 'z' && data.isMod) {\n      event.preventDefault();\n    }\n\n    debug('onKeyDown', { event: event, data: data });\n    _this2.props.onKeyDown(event, data);\n  };\n\n  this.onKeyUp = function (event) {\n    var which = event.which;\n\n    var key = (0, _keycode2.default)(which);\n\n    if (key == 'shift') {\n      _this2.tmp.isShifting = false;\n    }\n  };\n\n  this.onPaste = function (event) {\n    if (_this2.props.readOnly) return;\n    if (!_this2.isInEditor(event)) return;\n\n    event.preventDefault();\n    var data = (0, _getTransferData2.default)(event.clipboardData);\n\n    // Attach the `isShift` flag, so that people can use it to trigger \"Paste\n    // and Match Style\" logic.\n    data.isShift = !!_this2.tmp.isShifting;\n\n    debug('onPaste', { event: event, data: data });\n    _this2.props.onPaste(event, data);\n  };\n\n  this.onSelect = function (event) {\n    if (_this2.props.readOnly) return;\n    if (_this2.tmp.isCopying) return;\n    if (_this2.tmp.isComposing) return;\n    if (_this2.tmp.isSelecting) return;\n    if (!_this2.isInEditor(event)) return;\n\n    var window = (0, _getWindow2.default)(event.target);\n    var _props4 = _this2.props,\n        state = _props4.state,\n        editor = _props4.editor;\n    var document = state.document,\n        selection = state.selection;\n\n    var native = window.getSelection();\n    var data = {};\n\n    // If there are no ranges, the editor was blurred natively.\n    if (!native.rangeCount) {\n      data.selection = selection.set('isFocused', false);\n      data.isNative = true;\n    }\n\n    // Otherwise, determine the Slate selection from the native one.\n    else {\n        var anchorNode = native.anchorNode,\n            anchorOffset = native.anchorOffset,\n            focusNode = native.focusNode,\n            focusOffset = native.focusOffset;\n\n        var anchor = (0, _getPoint2.default)(anchorNode, anchorOffset, state, editor);\n        var focus = (0, _getPoint2.default)(focusNode, focusOffset, state, editor);\n        if (!anchor || !focus) return;\n\n        // There are situations where a select event will fire with a new native\n        // selection that resolves to the same internal position. In those cases\n        // we don't need to trigger any changes, since our internal model is\n        // already up to date, but we do want to update the native selection again\n        // to make sure it is in sync.\n        if (anchor.key == selection.anchorKey && anchor.offset == selection.anchorOffset && focus.key == selection.focusKey && focus.offset == selection.focusOffset && selection.isFocused) {\n          _this2.updateSelection();\n          return;\n        }\n\n        var properties = {\n          anchorKey: anchor.key,\n          anchorOffset: anchor.offset,\n          focusKey: focus.key,\n          focusOffset: focus.offset,\n          isFocused: true,\n          isBackward: null\n        };\n\n        // If the selection is at the end of a non-void inline node, and there is\n        // a node after it, put it in the node after instead.\n        var anchorText = document.getNode(anchor.key);\n        var focusText = document.getNode(focus.key);\n        var anchorInline = document.getClosestInline(anchor.key);\n        var focusInline = document.getClosestInline(focus.key);\n\n        if (anchorInline && !anchorInline.isVoid && anchor.offset == anchorText.length) {\n          var block = document.getClosestBlock(anchor.key);\n          var next = block.getNextText(anchor.key);\n          if (next) {\n            properties.anchorKey = next.key;\n            properties.anchorOffset = 0;\n          }\n        }\n\n        if (focusInline && !focusInline.isVoid && focus.offset == focusText.length) {\n          var _block = document.getClosestBlock(focus.key);\n          var _next = _block.getNextText(focus.key);\n          if (_next) {\n            properties.focusKey = _next.key;\n            properties.focusOffset = 0;\n          }\n        }\n\n        data.selection = selection.merge(properties).normalize(document);\n      }\n\n    debug('onSelect', { event: event, data: data });\n    _this2.props.onSelect(event, data);\n  };\n\n  this.render = function () {\n    var props = _this2.props;\n    var className = props.className,\n        readOnly = props.readOnly,\n        state = props.state,\n        tabIndex = props.tabIndex,\n        role = props.role;\n    var document = state.document;\n\n    var children = document.nodes.map(function (node) {\n      return _this2.renderNode(node);\n    }).toArray();\n\n    var style = _extends({\n      // Prevent the default outline styles.\n      outline: 'none',\n      // Preserve adjacent whitespace and new lines.\n      whiteSpace: 'pre-wrap',\n      // Allow words to break if they are too long.\n      wordWrap: 'break-word'\n    }, readOnly ? {} : { WebkitUserModify: 'read-write-plaintext-only' }, props.style);\n\n    // COMPAT: In Firefox, spellchecking can remove entire wrapping elements\n    // including inline ones like `<a>`, which is jarring for the user but also\n    // causes the DOM to get into an irreconcilable state. (2016/09/01)\n    var spellCheck = _environment.IS_FIREFOX ? false : props.spellCheck;\n\n    debug('render', { props: props });\n\n    return _react2.default.createElement(\n      'div',\n      {\n        'data-slate-editor': true,\n        key: _this2.tmp.forces,\n        ref: _this2.ref,\n        contentEditable: !readOnly,\n        suppressContentEditableWarning: true,\n        className: className,\n        onBeforeInput: _this2.onBeforeInput,\n        onBlur: _this2.onBlur,\n        onFocus: _this2.onFocus,\n        onCompositionEnd: _this2.onCompositionEnd,\n        onCompositionStart: _this2.onCompositionStart,\n        onCopy: _this2.onCopy,\n        onCut: _this2.onCut,\n        onDragEnd: _this2.onDragEnd,\n        onDragOver: _this2.onDragOver,\n        onDragStart: _this2.onDragStart,\n        onDrop: _this2.onDrop,\n        onInput: _this2.onInput,\n        onKeyDown: _this2.onKeyDown,\n        onKeyUp: _this2.onKeyUp,\n        onPaste: _this2.onPaste,\n        onSelect: _this2.onSelect,\n        autoCorrect: props.autoCorrect,\n        spellCheck: spellCheck,\n        style: style,\n        role: readOnly ? null : role || 'textbox',\n        tabIndex: tabIndex\n      },\n      children,\n      _this2.props.children\n    );\n  };\n\n  this.renderNode = function (node) {\n    var _props5 = _this2.props,\n        editor = _props5.editor,\n        readOnly = _props5.readOnly,\n        schema = _props5.schema,\n        state = _props5.state;\n\n\n    return _react2.default.createElement(_node2.default, {\n      key: node.key,\n      block: null,\n      node: node,\n      parent: state.document,\n      schema: schema,\n      state: state,\n      editor: editor,\n      readOnly: readOnly\n    });\n  };\n};\n\nexports.default = Content;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/components/node.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _base = require('../serializers/base-64');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _types = require('../constants/types');\n\nvar _types2 = _interopRequireDefault(_types);\n\nvar _leaf = require('./leaf');\n\nvar _leaf2 = _interopRequireDefault(_leaf);\n\nvar _void = require('./void');\n\nvar _void2 = _interopRequireDefault(_void);\n\nvar _getWindow = require('get-window');\n\nvar _getWindow2 = _interopRequireDefault(_getWindow);\n\nvar _scrollToSelection = require('../utils/scroll-to-selection');\n\nvar _scrollToSelection2 = _interopRequireDefault(_scrollToSelection);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = (0, _debug2.default)('slate:node');\n\n/**\n * Node.\n *\n * @type {Component}\n */\n\nvar Node = function (_React$Component) {\n  _inherits(Node, _React$Component);\n\n  /**\n   * Constructor.\n   *\n   * @param {Object} props\n   */\n\n  function Node(props) {\n    _classCallCheck(this, Node);\n\n    var _this = _possibleConstructorReturn(this, (Node.__proto__ || Object.getPrototypeOf(Node)).call(this, props));\n\n    _initialiseProps.call(_this);\n\n    var node = props.node,\n        schema = props.schema;\n\n    _this.state = {};\n    _this.state.Component = node.kind == 'text' ? null : node.getComponent(schema);\n    return _this;\n  }\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * On receiving new props, update the `Component` renderer.\n   *\n   * @param {Object} props\n   */\n\n  /**\n   * Should the node update?\n   *\n   * @param {Object} nextProps\n   * @param {Object} state\n   * @return {Boolean}\n   */\n\n  /**\n   * On mount, update the scroll position.\n   */\n\n  /**\n   * After update, update the scroll position if the node's content changed.\n   *\n   * @param {Object} prevProps\n   * @param {Object} prevState\n   */\n\n  /**\n   * Update the scroll position after a change as occured if this is a leaf\n   * block and it has the selection's ending edge. This ensures that scrolling\n   * matches native `contenteditable` behavior even for cases where the edit is\n   * not applied natively, like when enter is pressed.\n   */\n\n  /**\n   * On drag start, add a serialized representation of the node to the data.\n   *\n   * @param {Event} e\n   */\n\n  /**\n   * Render.\n   *\n   * @return {Element}\n   */\n\n  /**\n   * Render a `child` node.\n   *\n   * @param {Node} child\n   * @return {Element}\n   */\n\n  /**\n   * Render an element `node`.\n   *\n   * @return {Element}\n   */\n\n  /**\n   * Render a text node.\n   *\n   * @return {Element}\n   */\n\n  /**\n   * Render a single leaf node given a `range` and `offset`.\n   *\n   * @param {List<Range>} ranges\n   * @param {Range} range\n   * @param {Number} index\n   * @param {Number} offset\n   * @return {Element} leaf\n   */\n\n  return Node;\n}(_react2.default.Component);\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nNode.propTypes = {\n  block: _react2.default.PropTypes.object,\n  editor: _react2.default.PropTypes.object.isRequired,\n  node: _react2.default.PropTypes.object.isRequired,\n  parent: _react2.default.PropTypes.object.isRequired,\n  readOnly: _react2.default.PropTypes.bool.isRequired,\n  schema: _react2.default.PropTypes.object.isRequired,\n  state: _react2.default.PropTypes.object.isRequired\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this2 = this;\n\n  this.debug = function (message) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var node = _this2.props.node;\n    var key = node.key,\n        kind = node.kind,\n        type = node.type;\n\n    var id = kind == 'text' ? key + ' (' + kind + ')' : key + ' (' + type + ')';\n    debug.apply(undefined, [message, '' + id].concat(args));\n  };\n\n  this.componentWillReceiveProps = function (props) {\n    if (props.node.kind == 'text') return;\n    if (props.node == _this2.props.node) return;\n    var Component = props.node.getComponent(props.schema);\n    _this2.setState({ Component: Component });\n  };\n\n  this.shouldComponentUpdate = function (nextProps) {\n    var props = _this2.props;\n    var Component = _this2.state.Component;\n\n    // If the `Component` has enabled suppression of update checking, always\n    // return true so that it can deal with update checking itself.\n\n    if (Component && Component.suppressShouldComponentUpdate) return true;\n\n    // If the `readOnly` status has changed, re-render in case there is any\n    // user-land logic that depends on it, like nested editable contents.\n    if (nextProps.readOnly != props.readOnly) return true;\n\n    // If the node has changed, update. PERF: There are cases where it will have\n    // changed, but it's properties will be exactly the same (eg. copy-paste)\n    // which this won't catch. But that's rare and not a drag on performance, so\n    // for simplicity we just let them through.\n    if (nextProps.node != props.node) return true;\n\n    // If the node is a block or inline, which can have custom renderers, we\n    // include an extra check to re-render if the node's focus changes, to make\n    // it simple for users to show a node's \"selected\" state.\n    if (nextProps.node.kind != 'text') {\n      var hasEdgeIn = props.state.selection.hasEdgeIn(props.node);\n      var nextHasEdgeIn = nextProps.state.selection.hasEdgeIn(nextProps.node);\n      var hasFocus = props.state.isFocused || nextProps.state.isFocused;\n      var hasEdge = hasEdgeIn || nextHasEdgeIn;\n      if (hasFocus && hasEdge) return true;\n    }\n\n    // If the node is a text node, re-render if the current decorations have\n    // changed, even if the content of the text node itself hasn't.\n    if (nextProps.node.kind == 'text' && nextProps.schema.hasDecorators) {\n      var nextDecorators = nextProps.state.document.getDescendantDecorators(nextProps.node.key, nextProps.schema);\n      var decorators = props.state.document.getDescendantDecorators(props.node.key, props.schema);\n      var nextRanges = nextProps.node.getRanges(nextDecorators);\n      var ranges = props.node.getRanges(decorators);\n      if (!nextRanges.equals(ranges)) return true;\n    }\n\n    // If the node is a text node, and its parent is a block node, and it was\n    // the last child of the block, re-render to cleanup extra `<br/>` or `\\n`.\n    if (nextProps.node.kind == 'text' && nextProps.parent.kind == 'block') {\n      var last = props.parent.nodes.last();\n      var nextLast = nextProps.parent.nodes.last();\n      if (props.node == last && nextProps.node != nextLast) return true;\n    }\n\n    // Otherwise, don't update.\n    return false;\n  };\n\n  this.componentDidMount = function () {\n    _this2.updateScroll();\n  };\n\n  this.componentDidUpdate = function (prevProps, prevState) {\n    if (_this2.props.node != prevProps.node) _this2.updateScroll();\n  };\n\n  this.updateScroll = function () {\n    var _props = _this2.props,\n        node = _props.node,\n        state = _props.state;\n    var selection = state.selection;\n\n    // If this isn't a block, or it's a wrapping block, abort.\n\n    if (node.kind != 'block') return;\n    if (node.nodes.first().kind == 'block') return;\n\n    // If the selection is blurred, or this block doesn't contain it, abort.\n    if (selection.isBlurred) return;\n    if (!selection.hasEndIn(node)) return;\n\n    var el = _reactDom2.default.findDOMNode(_this2);\n    var window = (0, _getWindow2.default)(el);\n    var native = window.getSelection();\n    (0, _scrollToSelection2.default)(native);\n\n    _this2.debug('updateScroll', el);\n  };\n\n  this.onDragStart = function (e) {\n    var node = _this2.props.node;\n\n    var encoded = _base2.default.serializeNode(node, { preserveKeys: true });\n    var data = e.nativeEvent.dataTransfer;\n    data.setData(_types2.default.NODE, encoded);\n\n    _this2.debug('onDragStart', e);\n  };\n\n  this.render = function () {\n    var props = _this2.props;\n    var node = _this2.props.node;\n\n\n    _this2.debug('render', { props: props });\n\n    return node.kind == 'text' ? _this2.renderText() : _this2.renderElement();\n  };\n\n  this.renderNode = function (child) {\n    var _props2 = _this2.props,\n        block = _props2.block,\n        editor = _props2.editor,\n        node = _props2.node,\n        readOnly = _props2.readOnly,\n        schema = _props2.schema,\n        state = _props2.state;\n\n    return _react2.default.createElement(Node, {\n      key: child.key,\n      node: child,\n      block: node.kind == 'block' ? node : block,\n      parent: node,\n      editor: editor,\n      readOnly: readOnly,\n      schema: schema,\n      state: state\n    });\n  };\n\n  this.renderElement = function () {\n    var _props3 = _this2.props,\n        editor = _props3.editor,\n        node = _props3.node,\n        parent = _props3.parent,\n        readOnly = _props3.readOnly,\n        state = _props3.state;\n    var Component = _this2.state.Component;\n\n    var children = node.nodes.map(_this2.renderNode).toArray();\n\n    // Attributes that the developer must to mix into the element in their\n    // custom node renderer component.\n    var attributes = {\n      'data-key': node.key,\n      'onDragStart': _this2.onDragStart\n    };\n\n    // If it's a block node with inline children, add the proper `dir` attribute\n    // for text direction.\n    if (node.kind == 'block' && node.nodes.first().kind != 'block') {\n      var direction = node.getTextDirection();\n      if (direction == 'rtl') attributes.dir = 'rtl';\n    }\n\n    var element = _react2.default.createElement(\n      Component,\n      {\n        attributes: attributes,\n        key: node.key,\n        editor: editor,\n        parent: parent,\n        node: node,\n        readOnly: readOnly,\n        state: state\n      },\n      children\n    );\n\n    return node.isVoid ? _react2.default.createElement(\n      _void2.default,\n      _this2.props,\n      element\n    ) : element;\n  };\n\n  this.renderText = function () {\n    var _props4 = _this2.props,\n        node = _props4.node,\n        schema = _props4.schema,\n        state = _props4.state;\n    var document = state.document;\n\n    var decorators = schema.hasDecorators ? document.getDescendantDecorators(node.key, schema) : [];\n    var ranges = node.getRanges(decorators);\n    var offset = 0;\n\n    var leaves = ranges.map(function (range, i) {\n      var leaf = _this2.renderLeaf(ranges, range, i, offset);\n      offset += range.text.length;\n      return leaf;\n    });\n\n    return _react2.default.createElement(\n      'span',\n      { 'data-key': node.key },\n      leaves\n    );\n  };\n\n  this.renderLeaf = function (ranges, range, index, offset) {\n    var _props5 = _this2.props,\n        block = _props5.block,\n        node = _props5.node,\n        parent = _props5.parent,\n        schema = _props5.schema,\n        state = _props5.state,\n        editor = _props5.editor;\n    var text = range.text,\n        marks = range.marks;\n\n\n    return _react2.default.createElement(_leaf2.default, {\n      key: node.key + '-' + index,\n      block: block,\n      editor: editor,\n      index: index,\n      marks: marks,\n      node: node,\n      offset: offset,\n      parent: parent,\n      ranges: ranges,\n      schema: schema,\n      state: state,\n      text: text\n    });\n  };\n};\n\nexports.default = Node;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/constants/types.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Slate-specific data transfer types.\n *\n * @type {Object}\n */\n\nvar TYPES = {\n  FRAGMENT: 'application/x-slate-fragment',\n  NODE: 'application/x-slate-node'\n};\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = TYPES;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/components/leaf.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _offsetKey = require('../utils/offset-key');\n\nvar _offsetKey2 = _interopRequireDefault(_offsetKey);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _findDeepestNode = require('../utils/find-deepest-node');\n\nvar _findDeepestNode2 = _interopRequireDefault(_findDeepestNode);\n\nvar _environment = require('../constants/environment');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Debugger.\n *\n * @type {Function}\n */\n\nvar debug = (0, _debug2.default)('slate:leaf');\n\n/**\n * Leaf.\n *\n * @type {Component}\n */\n\nvar Leaf = function (_React$Component) {\n  _inherits(Leaf, _React$Component);\n\n  /**\n   * Constructor.\n   *\n   * @param {Object} props\n   */\n\n  function Leaf(props) {\n    _classCallCheck(this, Leaf);\n\n    var _this = _possibleConstructorReturn(this, (Leaf.__proto__ || Object.getPrototypeOf(Leaf)).call(this, props));\n\n    _this.debug = function (message) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      debug.apply(undefined, [message, _this.props.node.key + '-' + _this.props.index].concat(args));\n    };\n\n    _this.tmp = {};\n    _this.tmp.renders = 0;\n    return _this;\n  }\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  _createClass(Leaf, [{\n    key: 'shouldComponentUpdate',\n\n\n    /**\n     * Should component update?\n     *\n     * @param {Object} props\n     * @return {Boolean}\n     */\n\n    value: function shouldComponentUpdate(props) {\n      // If any of the regular properties have changed, re-render.\n      if (props.index != this.props.index || props.marks != this.props.marks || props.schema != this.props.schema || props.text != this.props.text) {\n        return true;\n      }\n\n      // If the DOM text does not equal the `text` property, re-render, this can\n      // happen because React gets out of sync when previously natively rendered.\n      var el = (0, _findDeepestNode2.default)(_reactDom2.default.findDOMNode(this));\n      var text = this.renderText(props);\n      if (el.textContent != text) return true;\n\n      // Otherwise, don't update.\n      return false;\n    }\n\n    /**\n     * Render the leaf.\n     *\n     * @return {Element}\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var props = this.props;\n      var node = props.node,\n          index = props.index;\n\n      var offsetKey = _offsetKey2.default.stringify({\n        key: node.key,\n        index: index\n      });\n\n      // Increment the renders key, which forces a re-render whenever this\n      // component is told it should update. This is required because \"native\"\n      // renders where we don't update the leaves cause React's internal state to\n      // get out of sync, causing it to not realize the DOM needs updating.\n      this.tmp.renders++;\n\n      this.debug('render', { props: props });\n\n      return _react2.default.createElement(\n        'span',\n        { key: this.tmp.renders, 'data-offset-key': offsetKey },\n        this.renderMarks(props)\n      );\n    }\n\n    /**\n     * Render the text content of the leaf, accounting for browsers.\n     *\n     * @param {Object} props\n     * @return {Element}\n     */\n\n  }, {\n    key: 'renderText',\n    value: function renderText(props) {\n      var block = props.block,\n          node = props.node,\n          parent = props.parent,\n          text = props.text,\n          index = props.index,\n          ranges = props.ranges;\n\n      // COMPAT: If the text is empty and it's the only child, we need to render a\n      // <br/> to get the block to have the proper height.\n\n      if (text == '' && parent.kind == 'block' && parent.text == '') return _react2.default.createElement('br', null);\n\n      // COMPAT: If the text is empty otherwise, it's because it's on the edge of\n      // an inline void node, so we render a zero-width space so that the\n      // selection can be inserted next to it still.\n      if (text == '') {\n        // COMPAT: In Chrome, zero-width space produces graphics glitches, so use\n        // hair space in place of it. (2017/02/12)\n        var space = _environment.IS_FIREFOX ? '\\u200B' : '\\u200A';\n        return _react2.default.createElement(\n          'span',\n          { 'data-slate-zero-width': true },\n          space\n        );\n      }\n\n      // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n      // so we need to add an extra trailing new lines to prevent that.\n      var lastText = block.getLastText();\n      var lastChar = text.charAt(text.length - 1);\n      var isLastText = node == lastText;\n      var isLastRange = index == ranges.size - 1;\n      if (isLastText && isLastRange && lastChar == '\\n') return text + '\\n';\n\n      // Otherwise, just return the text.\n      return text;\n    }\n\n    /**\n     * Render all of the leaf's mark components.\n     *\n     * @param {Object} props\n     * @return {Element}\n     */\n\n  }, {\n    key: 'renderMarks',\n    value: function renderMarks(props) {\n      var marks = props.marks,\n          schema = props.schema,\n          node = props.node,\n          offset = props.offset,\n          text = props.text,\n          state = props.state,\n          editor = props.editor;\n\n      var children = this.renderText(props);\n\n      return marks.reduce(function (memo, mark) {\n        var Component = mark.getComponent(schema);\n        if (!Component) return memo;\n        return _react2.default.createElement(\n          Component,\n          {\n            editor: editor,\n            mark: mark,\n            marks: marks,\n            node: node,\n            offset: offset,\n            schema: schema,\n            state: state,\n            text: text\n          },\n          memo\n        );\n      }, children);\n    }\n  }]);\n\n  return Leaf;\n}(_react2.default.Component);\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nLeaf.propTypes = {\n  block: _react2.default.PropTypes.object.isRequired,\n  editor: _react2.default.PropTypes.object.isRequired,\n  index: _react2.default.PropTypes.number.isRequired,\n  marks: _react2.default.PropTypes.object.isRequired,\n  node: _react2.default.PropTypes.object.isRequired,\n  offset: _react2.default.PropTypes.number.isRequired,\n  parent: _react2.default.PropTypes.object.isRequired,\n  ranges: _react2.default.PropTypes.object.isRequired,\n  schema: _react2.default.PropTypes.object.isRequired,\n  state: _react2.default.PropTypes.object.isRequired,\n  text: _react2.default.PropTypes.string.isRequired\n};\nexports.default = Leaf;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/offset-key.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _normalizeNodeAndOffset = require('./normalize-node-and-offset');\n\nvar _normalizeNodeAndOffset2 = _interopRequireDefault(_normalizeNodeAndOffset);\n\nvar _findClosestNode = require('./find-closest-node');\n\nvar _findClosestNode2 = _interopRequireDefault(_findClosestNode);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Offset key parser regex.\n *\n * @type {RegExp}\n */\n\nvar PARSER = /^(\\w+)(?:-(\\d+))?$/;\n\n/**\n * Offset key attribute name.\n *\n * @type {String}\n */\n\nvar ATTRIBUTE = 'data-offset-key';\n\n/**\n * Offset key attribute selector.\n *\n * @type {String}\n */\n\nvar SELECTOR = '[' + ATTRIBUTE + ']';\n\n/**\n * Void node selection.\n *\n * @type {String}\n */\n\nvar VOID_SELECTOR = '[data-slate-void]';\n\n/**\n * Find the start and end bounds from an `offsetKey` and `ranges`.\n *\n * @param {Number} index\n * @param {List<Range>} ranges\n * @return {Object}\n */\n\nfunction findBounds(index, ranges) {\n  var range = ranges.get(index);\n  var start = ranges.slice(0, index).reduce(function (memo, r) {\n    return memo += r.text.length;\n  }, 0);\n\n  return {\n    start: start,\n    end: start + range.text.length\n  };\n}\n\n/**\n * From a DOM node, find the closest parent's offset key.\n *\n * @param {Element} rawNode\n * @param {Number} rawOffset\n * @return {Object}\n */\n\nfunction findKey(rawNode, rawOffset) {\n  var _normalizeNodeAndOffs = (0, _normalizeNodeAndOffset2.default)(rawNode, rawOffset),\n      node = _normalizeNodeAndOffs.node,\n      offset = _normalizeNodeAndOffs.offset;\n\n  var parentNode = node.parentNode;\n\n  // Find the closest parent with an offset key attribute.\n\n  var closest = (0, _findClosestNode2.default)(parentNode, SELECTOR);\n\n  // For void nodes, the element with the offset key will be a cousin, not an\n  // ancestor, so find it by going down from the nearest void parent.\n  if (!closest) {\n    var closestVoid = (0, _findClosestNode2.default)(parentNode, VOID_SELECTOR);\n    if (!closestVoid) return null;\n    closest = closestVoid.querySelector(SELECTOR);\n    offset = closest.textContent.length;\n  }\n\n  // Get the string value of the offset key attribute.\n  var offsetKey = closest.getAttribute(ATTRIBUTE);\n\n  // If we still didn't find an offset key, abort.\n  if (!offsetKey) return null;\n\n  // Return the parsed the offset key.\n  var parsed = parse(offsetKey);\n  return {\n    key: parsed.key,\n    index: parsed.index,\n    offset: offset\n  };\n}\n\n/**\n * Find the selection point from an `offsetKey` and `ranges`.\n *\n * @param {Object} offsetKey\n * @param {List<Range>} ranges\n * @return {Object}\n */\n\nfunction findPoint(offsetKey, ranges) {\n  var key = offsetKey.key,\n      index = offsetKey.index,\n      offset = offsetKey.offset;\n\n  var _findBounds = findBounds(index, ranges),\n      start = _findBounds.start,\n      end = _findBounds.end;\n\n  // Don't let the offset be outside of the start and end bounds.\n\n\n  offset = start + offset;\n  offset = Math.max(offset, start);\n  offset = Math.min(offset, end);\n\n  return {\n    key: key,\n    index: index,\n    start: start,\n    end: end,\n    offset: offset\n  };\n}\n\n/**\n * Parse an offset key `string`.\n *\n * @param {String} string\n * @return {Object}\n */\n\nfunction parse(string) {\n  var matches = PARSER.exec(string);\n  if (!matches) throw new Error('Invalid offset key string \"' + string + '\".');\n\n  var _matches = _slicedToArray(matches, 3),\n      original = _matches[0],\n      key = _matches[1],\n      index = _matches[2]; // eslint-disable-line no-unused-vars\n\n\n  return {\n    key: key,\n    index: parseInt(index, 10)\n  };\n}\n\n/**\n * Stringify an offset key `object`.\n *\n * @param {Object} object\n *   @property {String} key\n *   @property {Number} index\n * @return {String}\n */\n\nfunction stringify(object) {\n  return object.key + '-' + object.index;\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = {\n  findBounds: findBounds,\n  findKey: findKey,\n  findPoint: findPoint,\n  parse: parse,\n  stringify: stringify\n};","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/normalize-node-and-offset.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * From a DOM selection's `node` and `offset`, normalize so that it always\n * refers to a text node.\n *\n * @param {Element} node\n * @param {Number} offset\n * @return {Object}\n */\n\nfunction normalizeNodeAndOffset(node, offset) {\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (node.nodeType == 1 && node.childNodes.length) {\n    var isLast = offset == node.childNodes.length;\n    var direction = isLast ? 'backward' : 'forward';\n    var index = isLast ? offset - 1 : offset;\n    node = getEditableChild(node, index, direction);\n\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (node.nodeType == 1 && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i, direction);\n    }\n\n    // Determine the new offset inside the text node.\n    offset = isLast ? node.textContent.length : 0;\n  }\n\n  // Return the node and offset.\n  return { node: node, offset: offset };\n}\n\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n *\n * @param {Element} parent\n * @param {Number} index\n * @param {String} direction ('forward' or 'backward')\n * @return {Element|Null}\n */\n\nfunction getEditableChild(parent, index, direction) {\n  var childNodes = parent.childNodes;\n\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false;\n\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (child.nodeType == 8 || child.nodeType == 1 && child.childNodes.length == 0 || child.nodeType == 1 && child.getAttribute('contenteditable') == 'false') {\n    if (triedForward && triedBackward) break;\n\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n\n    child = childNodes[i];\n    if (direction == 'forward') i++;\n    if (direction == 'backward') i--;\n  }\n\n  return child || null;\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = normalizeNodeAndOffset;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/find-closest-node.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Find the closest ancestor of a DOM `element` that matches a given selector.\n *\n * @param {Element} node\n * @param {String} selector\n * @return {Element}\n */\n\nfunction findClosestNode(node, selector) {\n  if (typeof node.closest === 'function') return node.closest(selector);\n\n  // See https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill\n  var matches = (node.document || node.ownerDocument).querySelectorAll(selector);\n  var i = void 0;\n  var parentNode = node;\n  do {\n    i = matches.length;\n    while (--i >= 0 && matches.item(i) !== parentNode) {}\n  } while (i < 0 && (parentNode = parentNode.parentElement));\n\n  return parentNode;\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = findClosestNode;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/find-deepest-node.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Find the deepest descendant of a DOM `element`.\n *\n * @param {Element} node\n * @return {Element}\n */\n\nfunction findDeepestNode(element) {\n  return element.firstChild ? findDeepestNode(element.firstChild) : element;\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = findDeepestNode;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/constants/environment.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IS_WINDOWS = exports.IS_MAC = exports.IS_SAFARI = exports.IS_FIREFOX = exports.IS_CHROME = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _isInBrowser = require('is-in-browser');\n\nvar _isInBrowser2 = _interopRequireDefault(_isInBrowser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Browser matching rules.\n *\n * @type {Array}\n */\n\nvar BROWSER_RULES = [['edge', /Edge\\/([0-9\\._]+)/], ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/], ['firefox', /Firefox\\/([0-9\\.]+)(?:\\s|$)/], ['opera', /Opera\\/([0-9\\.]+)(?:\\s|$)/], ['opera', /OPR\\/([0-9\\.]+)(:?\\s|$)$/], ['ie', /Trident\\/7\\.0.*rv\\:([0-9\\.]+)\\).*Gecko$/], ['ie', /MSIE\\s([0-9\\.]+);.*Trident\\/[4-7].0/], ['ie', /MSIE\\s(7\\.0)/], ['android', /Android\\s([0-9\\.]+)/], ['safari', /Version\\/([0-9\\._]+).*Safari/]];\n\n/**\n * Operating system matching rules.\n *\n * @type {Array}\n */\n\nvar OS_RULES = [['macos', /mac os x/i], ['ios', /os ([\\.\\_\\d]+) like mac os/i], ['android', /android/i], ['firefoxos', /mozilla\\/[a-z\\.\\_\\d]+ \\((?:mobile)|(?:tablet)/i], ['windows', /windows\\s*(?:nt)?\\s*([\\.\\_\\d]+)/i]];\n\n/**\n * Define variables to store the result.\n */\n\nvar BROWSER = void 0;\nvar OS = void 0;\n\n/**\n * Run the matchers when in browser.\n */\n\nif (_isInBrowser2.default) {\n  var userAgent = window.navigator.userAgent;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n\n    for (var _iterator = BROWSER_RULES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var rule = _step.value;\n\n      var _rule = _slicedToArray(rule, 2),\n          name = _rule[0],\n          regexp = _rule[1];\n\n      if (regexp.test(userAgent)) {\n        BROWSER = name;\n        break;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = OS_RULES[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _rule2 = _step2.value;\n\n      var _rule3 = _slicedToArray(_rule2, 2),\n          name = _rule3[0],\n          regexp = _rule3[1];\n\n      if (regexp.test(userAgent)) {\n        OS = name;\n        break;\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nvar IS_CHROME = exports.IS_CHROME = BROWSER === 'chrome';\nvar IS_FIREFOX = exports.IS_FIREFOX = BROWSER === 'firefox';\nvar IS_SAFARI = exports.IS_SAFARI = BROWSER === 'safari';\n\nvar IS_MAC = exports.IS_MAC = OS === 'macos';\nvar IS_WINDOWS = exports.IS_WINDOWS = OS === 'windows';","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/components/void.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _leaf = require('./leaf');\n\nvar _leaf2 = _interopRequireDefault(_leaf);\n\nvar _mark = require('../models/mark');\n\nvar _mark2 = _interopRequireDefault(_mark);\n\nvar _offsetKey = require('../utils/offset-key');\n\nvar _offsetKey2 = _interopRequireDefault(_offsetKey);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _environment = require('../constants/environment');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = (0, _debug2.default)('slate:void');\n\n/**\n * Void.\n *\n * @type {Component}\n */\n\nvar Void = function (_React$Component) {\n  _inherits(Void, _React$Component);\n\n  function Void() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Void);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Void.__proto__ || Object.getPrototypeOf(Void)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps.call(_this), _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  /**\n   * When one of the wrapper elements it clicked, select the void node.\n   *\n   * @param {Event} event\n   */\n\n  /**\n   * Render.\n   *\n   * @return {Element}\n   */\n\n  /**\n   * Render a fake spacer leaf, which will catch the cursor when it the void\n   * node is navigated to with the arrow keys. Having this spacer there means\n   * the browser continues to manage the selection natively, so it keeps track\n   * of the right offset when moving across the block.\n   *\n   * @return {Element}\n   */\n\n  /**\n   * Render a fake leaf.\n   *\n   * @return {Element}\n   */\n\n  return Void;\n}(_react2.default.Component);\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nVoid.propTypes = {\n  block: _react2.default.PropTypes.object,\n  children: _react2.default.PropTypes.any.isRequired,\n  editor: _react2.default.PropTypes.object.isRequired,\n  node: _react2.default.PropTypes.object.isRequired,\n  parent: _react2.default.PropTypes.object.isRequired,\n  schema: _react2.default.PropTypes.object.isRequired,\n  state: _react2.default.PropTypes.object.isRequired\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this2 = this;\n\n  this.debug = function (message) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    var node = _this2.props.node;\n    var key = node.key,\n        type = node.type;\n\n    var id = key + ' (' + type + ')';\n    debug.apply(undefined, [message, '' + id].concat(args));\n  };\n\n  this.onClick = function (event) {\n    _this2.debug('onClick', { event: event });\n\n    var _props = _this2.props,\n        node = _props.node,\n        editor = _props.editor;\n\n    var next = editor.getState().transform()\n    // COMPAT: In Chrome & Safari, selections that are at the zero offset of\n    // an inline node will be automatically replaced to be at the last offset\n    // of a previous inline node, which screws us up, so we always want to set\n    // it to the end of the node. (2016/11/29)\n    .collapseToEndOf(node).focus().apply();\n\n    editor.onChange(next);\n  };\n\n  this.render = function () {\n    var props = _this2.props;\n    var children = props.children,\n        node = props.node;\n\n    var Tag = void 0,\n        style = void 0;\n\n    // Make the outer wrapper relative, so the spacer can overlay it.\n    if (node.kind === 'block') {\n      Tag = 'div';\n      style = { position: 'relative' };\n    } else {\n      Tag = 'span';\n    }\n\n    _this2.debug('render', { props: props });\n\n    return _react2.default.createElement(\n      Tag,\n      { 'data-slate-void': true, style: style, onClick: _this2.onClick },\n      _this2.renderSpacer(),\n      _react2.default.createElement(\n        Tag,\n        { contentEditable: false },\n        children\n      )\n    );\n  };\n\n  this.renderSpacer = function () {\n    var node = _this2.props.node;\n\n    var style = void 0;\n\n    if (node.kind == 'block') {\n      style = _environment.IS_FIREFOX ? {\n        pointerEvents: 'none',\n        width: '0px',\n        height: '0px',\n        lineHeight: '0px',\n        visibility: 'hidden'\n      } : {\n        position: 'absolute',\n        top: '0px',\n        left: '-9999px',\n        textIndent: '-9999px'\n      };\n    } else {\n      style = {\n        color: 'transparent'\n      };\n    }\n\n    return _react2.default.createElement(\n      'span',\n      { style: style },\n      _this2.renderLeaf()\n    );\n  };\n\n  this.renderLeaf = function () {\n    var _props2 = _this2.props,\n        block = _props2.block,\n        node = _props2.node,\n        schema = _props2.schema,\n        state = _props2.state,\n        editor = _props2.editor;\n\n    var child = node.getFirstText();\n    var ranges = child.getRanges();\n    var text = '';\n    var offset = 0;\n    var marks = _mark2.default.createSet();\n    var index = 0;\n    var offsetKey = _offsetKey2.default.stringify({\n      key: child.key,\n      index: index\n    });\n\n    return _react2.default.createElement(_leaf2.default, {\n      key: offsetKey,\n      block: node.kind == 'block' ? node : block,\n      editor: editor,\n      index: index,\n      marks: marks,\n      node: child,\n      offset: offset,\n      parent: node,\n      ranges: ranges,\n      schema: schema,\n      state: state,\n      text: text\n    });\n  };\n};\n\nexports.default = Void;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/scroll-to-selection.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getWindow = require('get-window');\n\nvar _getWindow2 = _interopRequireDefault(_getWindow);\n\nvar _selectionIsBackward = require('selection-is-backward');\n\nvar _selectionIsBackward2 = _interopRequireDefault(_selectionIsBackward);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Scroll the current selection's focus point into view if needed.\n *\n * @param {Selection} selection\n */\n\nfunction scrollToSelection(selection) {\n  var window = (0, _getWindow2.default)(selection.anchorNode);\n  var backward = (0, _selectionIsBackward2.default)(selection);\n  var range = selection.getRangeAt(0);\n  var rect = range.getBoundingClientRect();\n  var innerWidth = window.innerWidth,\n      innerHeight = window.innerHeight,\n      pageYOffset = window.pageYOffset,\n      pageXOffset = window.pageXOffset;\n\n  var top = (backward ? rect.top : rect.bottom) + pageYOffset;\n  var left = (backward ? rect.left : rect.right) + pageXOffset;\n\n  var x = left < pageXOffset || innerWidth + pageXOffset < left ? left - innerWidth / 2 : pageXOffset;\n\n  var y = top < pageYOffset || innerHeight + pageYOffset < top ? top - innerHeight / 2 : pageYOffset;\n\n  window.scrollTo(x, y);\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = scrollToSelection;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/get-point.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _offsetKey = require('./offset-key');\n\nvar _offsetKey2 = _interopRequireDefault(_offsetKey);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Get a point from a native selection's DOM `element` and `offset`.\n *\n * @param {Element} element\n * @param {Number} offset\n * @param {State} state\n * @param {Editor} editor\n * @return {Object}\n */\n\nfunction getPoint(element, offset, state, editor) {\n  var document = state.document;\n\n  var schema = editor.getSchema();\n\n  // If we can't find an offset key, we can't get a point.\n  var offsetKey = _offsetKey2.default.findKey(element, offset);\n  if (!offsetKey) return null;\n\n  // COMPAT: If someone is clicking from one Slate editor into another, the\n  // select event fires two, once for the old editor's `element` first, and\n  // then afterwards for the correct `element`. (2017/03/03)\n  var key = offsetKey.key;\n\n  var node = document.getDescendant(key);\n  if (!node) return null;\n\n  var decorators = document.getDescendantDecorators(key, schema);\n  var ranges = node.getRanges(decorators);\n  var point = _offsetKey2.default.findPoint(offsetKey, ranges);\n  return point;\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = getPoint;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/extend-selection.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Extends the given selection to a given node and offset\n *\n * @param {Selection} selection Selection instance\n * @param {Element} el Node to extend to\n * @param {Number} offset Text offset to extend to\n * @returns {Selection} Mutated Selection instance\n */\n\nfunction extendSelection(selection, el, offset) {\n  // Use native method when possible\n  if (typeof selection.extend === 'function') return selection.extend(el, offset);\n\n  // See https://gist.github.com/tyler-johnson/0a3e8818de3f115b2a2dc47468ac0099\n  var range = document.createRange();\n  var anchor = document.createRange();\n  anchor.setStart(selection.anchorNode, selection.anchorOffset);\n\n  var focus = document.createRange();\n  focus.setStart(el, offset);\n\n  var v = focus.compareBoundaryPoints(Range.START_TO_START, anchor);\n  if (v >= 0) {\n    // Focus is after anchor\n    range.setStart(selection.anchorNode, selection.anchorOffset);\n    range.setEnd(el, offset);\n  } else {\n    // Anchor is after focus\n    range.setStart(el, offset);\n    range.setEnd(selection.anchorNode, selection.anchorOffset);\n  }\n\n  selection.removeAllRanges();\n  selection.addRange(range);\n\n  return selection;\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = extendSelection;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/get-transfer-data.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _base = require('../serializers/base-64');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _types = require('../constants/types');\n\nvar _types2 = _interopRequireDefault(_types);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Fragment matching regexp for HTML nodes.\n *\n * @type {RegExp}\n */\n\nvar FRAGMENT_MATCHER = /data-slate-fragment=\"([^\\s]+)\"/;\n\n/**\n * Get the data and type from a native data `transfer`.\n *\n * @param {DataTransfer} transfer\n * @return {Object}\n */\n\nfunction getTransferData(transfer) {\n  var fragment = transfer.getData(_types2.default.FRAGMENT) || null;\n  var node = transfer.getData(_types2.default.NODE) || null;\n  var html = transfer.getData('text/html') || null;\n  var rich = transfer.getData('text/rtf') || null;\n  var text = transfer.getData('text/plain') || null;\n  var files = void 0;\n\n  // If there isn't a fragment, but there is HTML, check to see if the HTML is\n  // actually an encoded fragment.\n  if (!fragment && html && ~html.indexOf('<span data-slate-fragment=\"')) {\n    var matches = FRAGMENT_MATCHER.exec(html);\n\n    var _matches = _slicedToArray(matches, 2),\n        full = _matches[0],\n        encoded = _matches[1]; // eslint-disable-line no-unused-vars\n\n\n    if (encoded) fragment = encoded;\n  }\n\n  // Decode a fragment or node if they exist.\n  if (fragment) fragment = _base2.default.deserializeNode(fragment);\n  if (node) node = _base2.default.deserializeNode(node);\n\n  // Get and normalize files if they exist.\n  if (transfer.items && transfer.items.length) {\n    files = Array.from(transfer.items).map(function (item) {\n      return item.kind == 'file' ? item.getAsFile() : null;\n    }).filter(function (exists) {\n      return exists;\n    });\n  } else if (transfer.files && transfer.files.length) {\n    files = Array.from(transfer.files);\n  }\n\n  // Determine the type of the data.\n  var data = { files: files, fragment: fragment, html: html, node: node, rich: rich, text: text };\n  data.type = getTransferType(data);\n  return data;\n}\n\n/**\n * Get the type of a transfer from its `data`.\n *\n * @param {Object} data\n * @return {String}\n */\n\nfunction getTransferType(data) {\n  if (data.fragment) return 'fragment';\n  if (data.node) return 'node';\n\n  // COMPAT: Microsoft Word adds an image of the selected text to the data.\n  // Since files are preferred over HTML or text, this would cause the type to\n  // be considered `files`. But it also adds rich text data so we can check\n  // for that and properly set the type to `html` or `text`. (2016/11/21)\n  if (data.rich && data.html) return 'html';\n  if (data.rich && data.text) return 'text';\n\n  if (data.files && data.files.length) return 'files';\n  if (data.html) return 'html';\n  if (data.text) return 'text';\n  return 'unknown';\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = getTransferData;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/components/placeholder.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Placeholder.\n *\n * @type {Component}\n */\n\nvar Placeholder = function (_React$Component) {\n  _inherits(Placeholder, _React$Component);\n\n  function Placeholder() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Placeholder);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Placeholder.__proto__ || Object.getPrototypeOf(Placeholder)).call.apply(_ref, [this].concat(args))), _this), _this.shouldComponentUpdate = function (props, state) {\n      return props.children != _this.props.children || props.className != _this.props.className || props.parent != _this.props.parent || props.node != _this.props.node || props.style != _this.props.style;\n    }, _this.isVisible = function () {\n      var _this$props = _this.props,\n          node = _this$props.node,\n          parent = _this$props.parent;\n\n      if (node.text) return false;\n      if (parent.nodes.size > 1) return false;\n      if (parent.nodes.first() === node) return true;\n      return false;\n    }, _this.render = function () {\n      var isVisible = _this.isVisible();\n      if (!isVisible) return null;\n\n      var _this$props2 = _this.props,\n          children = _this$props2.children,\n          className = _this$props2.className;\n      var style = _this.props.style;\n\n\n      if (typeof children === 'string' && style == null && className == null) {\n        style = { opacity: '0.333' };\n      } else if (style == null) {\n        style = {};\n      }\n\n      var styles = _extends({\n        position: 'absolute',\n        top: '0px',\n        right: '0px',\n        bottom: '0px',\n        left: '0px',\n        pointerEvents: 'none'\n      }, style);\n\n      return _react2.default.createElement(\n        'span',\n        { contentEditable: false, className: className, style: styles },\n        children\n      );\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Should the placeholder update?\n   *\n   * @param {Object} props\n   * @param {Object} state\n   * @return {Boolean}\n   */\n\n  /**\n   * Is the placeholder visible?\n   *\n   * @return {Boolean}\n   */\n\n  /**\n   * Render.\n   *\n   * If the placeholder is a string, and no `className` or `style` has been\n   * passed, give it a default style of lowered opacity.\n   *\n   * @return {Element}\n   */\n\n  return Placeholder;\n}(_react2.default.Component);\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nPlaceholder.propTypes = {\n  children: _react2.default.PropTypes.any.isRequired,\n  className: _react2.default.PropTypes.string,\n  node: _react2.default.PropTypes.object.isRequired,\n  parent: _react2.default.PropTypes.object.isRequired,\n  state: _react2.default.PropTypes.object.isRequired,\n  style: _react2.default.PropTypes.object\n};\nexports.default = Placeholder;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/noop.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Noop.\n *\n * @return {Void}\n */\n\nfunction noop() {}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = noop;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/serializers/html.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _raw = require('./raw');\n\nvar _raw2 = _interopRequireDefault(_raw);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _server = require('react-dom/server');\n\nvar _server2 = _interopRequireDefault(_server);\n\nvar _cheerio = require('cheerio');\n\nvar _cheerio2 = _interopRequireDefault(_cheerio);\n\nvar _typeOf = require('type-of');\n\nvar _typeOf2 = _interopRequireDefault(_typeOf);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * String.\n *\n * @type {String}\n */\n\nvar String = new _immutable.Record({\n  kind: 'string',\n  text: ''\n});\n\n/**\n * A rule to (de)serialize text nodes. This is automatically added to the HTML\n * serializer so that users don't have to worry about text-level serialization.\n *\n * @type {Object}\n */\n\nvar TEXT_RULE = {\n  deserialize: function deserialize(el) {\n    if (el.tagName == 'br') {\n      return {\n        kind: 'text',\n        text: '\\n'\n      };\n    }\n\n    if (el.type == 'text') {\n      return {\n        kind: 'text',\n        text: el.data\n      };\n    }\n  },\n  serialize: function serialize(obj, children) {\n    if (obj.kind == 'string') {\n      return children.split('\\n').reduce(function (array, text, i) {\n        if (i != 0) array.push(_react2.default.createElement('br', null));\n        array.push(text);\n        return array;\n      }, []);\n    }\n  }\n};\n\n/**\n * HTML serializer.\n *\n * @type {Html}\n */\n\nvar Html =\n\n/**\n * Create a new serializer with `rules`.\n *\n * @param {Object} options\n *   @property {Array} rules\n *   @property {String} defaultBlockType\n *   @property {String|Object} defaultBlockType\n */\n\nfunction Html() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  _classCallCheck(this, Html);\n\n  _initialiseProps.call(this);\n\n  this.rules = [].concat(_toConsumableArray(options.rules || []), [TEXT_RULE]);\n\n  this.defaultBlockType = options.defaultBlockType || 'paragraph';\n}\n\n/**\n * Deserialize pasted HTML.\n *\n * @param {String} html\n * @param {Object} options\n *   @property {Boolean} toRaw\n * @return {State}\n */\n\n/**\n * Deserialize an array of Cheerio `elements`.\n *\n * @param {Array} elements\n * @return {Array}\n */\n\n/**\n * Deserialize a Cheerio `element`.\n *\n * @param {Object} element\n * @return {Any}\n */\n\n/**\n * Deserialize a `mark` object.\n *\n * @param {Object} mark\n * @return {Array}\n */\n\n/**\n * Serialize a `state` object into an HTML string.\n *\n * @param {State} state\n * @param {Object} options\n *   @property {Boolean} render\n * @return {String|Array}\n */\n\n/**\n * Serialize a `node`.\n *\n * @param {Node} node\n * @return {String}\n */\n\n/**\n * Serialize a `range`.\n *\n * @param {Range} range\n * @return {String}\n */\n\n/**\n * Serialize a `string`.\n *\n * @param {String} string\n * @return {String}\n */\n\n;\n\n/**\n * Add a unique key to a React `element`.\n *\n * @param {Element} element\n * @return {Element}\n */\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this = this;\n\n  this.deserialize = function (html) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var $ = _cheerio2.default.load(html).root();\n    var children = $.children().toArray();\n    var nodes = _this.deserializeElements(children);\n\n    // HACK: ensure for now that all top-level inline are wrapped into a block.\n    nodes = nodes.reduce(function (memo, node, i, original) {\n      if (node.kind == 'block') {\n        memo.push(node);\n        return memo;\n      }\n\n      if (i > 0 && original[i - 1].kind != 'block') {\n        var _block = memo[memo.length - 1];\n        _block.nodes.push(node);\n        return memo;\n      }\n\n      var defaultBlockType = _this.defaultBlockType;\n\n      var defaults = typeof defaultBlockType == 'string' ? { type: defaultBlockType } : defaultBlockType;\n\n      var block = _extends({\n        kind: 'block',\n        nodes: [node]\n      }, defaults);\n\n      memo.push(block);\n      return memo;\n    }, []);\n\n    var raw = {\n      kind: 'state',\n      document: {\n        kind: 'document',\n        nodes: nodes\n      }\n    };\n\n    if (options.toRaw) {\n      return raw;\n    }\n\n    var state = _raw2.default.deserialize(raw, { terse: true });\n    return state;\n  };\n\n  this.deserializeElements = function () {\n    var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    var nodes = [];\n\n    elements.forEach(function (element) {\n      var node = _this.deserializeElement(element);\n      switch ((0, _typeOf2.default)(node)) {\n        case 'array':\n          nodes = nodes.concat(node);\n          break;\n        case 'object':\n          nodes.push(node);\n          break;\n        case 'null':\n        case 'undefined':\n          return;\n        default:\n          throw new Error('A rule returned an invalid deserialized representation: \"' + node + '\".');\n      }\n    });\n\n    return nodes;\n  };\n\n  this.deserializeElement = function (element) {\n    var node = void 0;\n\n    var next = function next(elements) {\n      switch ((0, _typeOf2.default)(elements)) {\n        case 'array':\n          return _this.deserializeElements(elements);\n        case 'object':\n          return _this.deserializeElement(elements);\n        case 'null':\n        case 'undefined':\n          return;\n        default:\n          throw new Error('The `next` argument was called with invalid children: \"' + elements + '\".');\n      }\n    };\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = _this.rules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var rule = _step.value;\n\n        if (!rule.deserialize) continue;\n        var ret = rule.deserialize(element, next);\n        if (!ret) continue;\n        node = ret.kind == 'mark' ? _this.deserializeMark(ret) : ret;\n        break;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return node || next(element.children);\n  };\n\n  this.deserializeMark = function (mark) {\n    var type = mark.type,\n        data = mark.data;\n\n\n    var applyMark = function applyMark(node) {\n      if (node.kind == 'mark') {\n        return _this.deserializeMark(node);\n      } else if (node.kind == 'text') {\n        if (!node.ranges) node.ranges = [{ text: node.text }];\n        node.ranges = node.ranges.map(function (range) {\n          range.marks = range.marks || [];\n          range.marks.push({ type: type, data: data });\n          return range;\n        });\n      } else {\n        node.nodes = node.nodes.map(applyMark);\n      }\n\n      return node;\n    };\n\n    return mark.nodes.reduce(function (nodes, node) {\n      var ret = applyMark(node);\n      if (Array.isArray(ret)) return nodes.concat(ret);\n      nodes.push(ret);\n      return nodes;\n    }, []);\n  };\n\n  this.serialize = function (state) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var document = state.document;\n\n    var elements = document.nodes.map(_this.serializeNode);\n    if (options.render === false) return elements;\n\n    var html = _server2.default.renderToStaticMarkup(_react2.default.createElement(\n      'body',\n      null,\n      elements\n    ));\n    var inner = html.slice(6, -7);\n    return inner;\n  };\n\n  this.serializeNode = function (node) {\n    if (node.kind == 'text') {\n      var ranges = node.getRanges();\n      return ranges.map(_this.serializeRange);\n    }\n\n    var children = node.nodes.map(_this.serializeNode);\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = _this.rules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var rule = _step2.value;\n\n        if (!rule.serialize) continue;\n        var ret = rule.serialize(node, children);\n        if (ret) return addKey(ret);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    throw new Error('No serializer defined for node of type \"' + node.type + '\".');\n  };\n\n  this.serializeRange = function (range) {\n    var string = new String({ text: range.text });\n    var text = _this.serializeString(string);\n\n    return range.marks.reduce(function (children, mark) {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = _this.rules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var rule = _step3.value;\n\n          if (!rule.serialize) continue;\n          var ret = rule.serialize(mark, children);\n          if (ret) return addKey(ret);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      throw new Error('No serializer defined for mark of type \"' + mark.type + '\".');\n    }, text);\n  };\n\n  this.serializeString = function (string) {\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = _this.rules[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var rule = _step4.value;\n\n        if (!rule.serialize) continue;\n        var ret = rule.serialize(string, string.text);\n        if (ret) return ret;\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n  };\n};\n\nvar key = 0;\n\nfunction addKey(element) {\n  return _react2.default.cloneElement(element, { key: key++ });\n}\n\n/**\n * Export.\n *\n * @type {Html}\n */\n\nexports.default = Html;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/serializers/plain.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _raw = require('../serializers/raw');\n\nvar _raw2 = _interopRequireDefault(_raw);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Deserialize a plain text `string` to a state.\n *\n * @param {String} string\n * @param {Object} options\n *   @property {Boolean} toRaw\n * @return {State}\n */\n\nfunction deserialize(string) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var raw = {\n    kind: 'state',\n    document: {\n      kind: 'document',\n      nodes: string.split('\\n').map(function (line) {\n        return {\n          kind: 'block',\n          type: 'line',\n          nodes: [{\n            kind: 'text',\n            ranges: [{\n              text: line,\n              marks: []\n            }]\n          }]\n        };\n      })\n    }\n  };\n\n  return options.toRaw ? raw : _raw2.default.deserialize(raw);\n}\n\n/**\n * Serialize a `state` to plain text.\n *\n * @param {State} state\n * @return {String}\n */\n\nfunction serialize(state) {\n  return state.document.nodes.map(function (block) {\n    return block.text;\n  }).join('\\n');\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = {\n  deserialize: deserialize,\n  serialize: serialize\n};","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/find-dom-node.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Find the DOM node for a `node`.\n *\n * @param {Node} node\n * @return {Element}\n */\n\nfunction findDOMNode(node) {\n  var el = window.document.querySelector(\"[data-key=\\\"\" + node.key + \"\\\"]\");\n\n  if (!el) {\n    throw new Error(\"Unable to find a DOM node for \\\"\" + node.key + \"\\\". This is\\noften because of forgetting to add `props.attributes` to a component\\nreturned from `renderNode`.\");\n  }\n\n  return el;\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = findDOMNode;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/constants/schema.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _schema = require('../models/schema');\n\nvar _schema2 = _interopRequireDefault(_schema);\n\nvar _text = require('../models/text');\n\nvar _text2 = _interopRequireDefault(_text);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Only allow block nodes in documents.\n *\n * @type {Object}\n */\n\nvar DOCUMENT_CHILDREN_RULE = {\n  match: function match(node) {\n    return node.kind == 'document';\n  },\n  validate: function validate(document) {\n    var nodes = document.nodes;\n\n    var invalids = nodes.filter(function (n) {\n      return n.kind != 'block';\n    });\n    return invalids.size ? invalids : null;\n  },\n  normalize: function normalize(transform, document, invalids) {\n    return invalids.reduce(function (t, n) {\n      return t.removeNodeByKey(n.key, { normalize: false });\n    }, transform);\n  }\n};\n\n/**\n * Only allow block, inline and text nodes in blocks.\n *\n * @type {Object}\n */\n\nvar BLOCK_CHILDREN_RULE = {\n  match: function match(node) {\n    return node.kind == 'block';\n  },\n  validate: function validate(block) {\n    var nodes = block.nodes;\n\n    var invalids = nodes.filter(function (n) {\n      return n.kind != 'block' && n.kind != 'inline' && n.kind != 'text';\n    });\n    return invalids.size ? invalids : null;\n  },\n  normalize: function normalize(transform, block, invalids) {\n    return invalids.reduce(function (t, n) {\n      return t.removeNodeByKey(n.key, { normalize: false });\n    }, transform);\n  }\n};\n\n/**\n * Ensure that block and inline nodes have at least one text child.\n *\n * @type {Object}\n */\n\nvar MIN_TEXT_RULE = {\n  match: function match(object) {\n    return object.kind == 'block' || object.kind == 'inline';\n  },\n  validate: function validate(node) {\n    var nodes = node.nodes;\n\n    return nodes.size === 0 ? true : null;\n  },\n  normalize: function normalize(transform, node) {\n    var text = _text2.default.create();\n    return transform.insertNodeByKey(node.key, 0, text, { normalize: false });\n  }\n};\n\n/**\n * Only allow inline and text nodes in inlines.\n *\n * @type {Object}\n */\n\nvar INLINE_CHILDREN_RULE = {\n  match: function match(object) {\n    return object.kind == 'inline';\n  },\n  validate: function validate(inline) {\n    var nodes = inline.nodes;\n\n    var invalids = nodes.filter(function (n) {\n      return n.kind != 'inline' && n.kind != 'text';\n    });\n    return invalids.size ? invalids : null;\n  },\n  normalize: function normalize(transform, inline, invalids) {\n    return invalids.reduce(function (t, n) {\n      return t.removeNodeByKey(n.key, { normalize: false });\n    }, transform);\n  }\n};\n\n/**\n * Ensure that inline nodes are never empty.\n *\n * This rule is applied to all blocks, because when they contain an empty\n * inline, we need to remove the inline from that parent block. If `validate`\n * was to be memoized, it should be against the parent node, not the inline\n * themselves.\n *\n * @type {Object}\n */\n\nvar INLINE_NO_EMPTY = {\n  match: function match(object) {\n    return object.kind == 'block';\n  },\n  validate: function validate(block) {\n    return block.nodes.some(function (child) {\n      return child.kind == 'inline' && child.text == '';\n    });\n  },\n  normalize: function normalize(transform, block) {\n    return block.nodes.reduce(function (tr, child, index) {\n      if (child.kind == 'inline' && child.text == '') {\n        return transform.removeNodeByKey(child.key, { normalize: false }).insertNodeByKey(block.key, index, _text2.default.createFromString(''), { normalize: false });\n      } else {\n        return tr;\n      }\n    }, transform);\n  }\n};\n\n/**\n * Ensure that void nodes contain a single space of content.\n *\n * @type {Object}\n */\n\nvar VOID_TEXT_RULE = {\n  match: function match(object) {\n    return (object.kind == 'inline' || object.kind == 'block') && object.isVoid;\n  },\n  validate: function validate(node) {\n    return node.text !== ' ' || node.nodes.size !== 1;\n  },\n  normalize: function normalize(transform, node, result) {\n    node.nodes.reduce(function (t, child) {\n      return t.removeNodeByKey(child.key, { normalize: false });\n    }, transform);\n\n    return transform.insertNodeByKey(node.key, 0, _text2.default.createFromString(' '), { normalize: false });\n  }\n};\n\n/**\n * Ensure that inline void nodes are surrounded with text nodes.\n *\n * @type {Object}\n */\n\nvar INLINE_VOID_TEXTS_AROUND_RULE = {\n  match: function match(object) {\n    return object.kind == 'block' || object.kind == 'inline';\n  },\n  validate: function validate(block) {\n    var invalids = block.nodes.reduce(function (accu, child, index) {\n      if (child.kind === 'block' || !child.isVoid) {\n        return accu;\n      }\n\n      var prevNode = index > 0 ? block.nodes.get(index - 1) : null;\n      var nextNode = block.nodes.get(index + 1);\n\n      var prev = !prevNode;\n      var next = !nextNode || isInlineVoid(nextNode);\n\n      if (next || prev) {\n        return accu.push({ next: next, prev: prev, index: index });\n      } else {\n        return accu;\n      }\n    }, new _immutable.List());\n\n    return !invalids.isEmpty() ? invalids : null;\n  },\n  normalize: function normalize(transform, block, invalids) {\n    // Shift for every text node inserted previously\n    var shift = 0;\n\n    return invalids.reduce(function (t, _ref) {\n      var index = _ref.index,\n          next = _ref.next,\n          prev = _ref.prev;\n\n      if (prev) {\n        t = t.insertNodeByKey(block.key, shift + index, _text2.default.create(), { normalize: false });\n        shift = shift + 1;\n      }\n      if (next) {\n        t = t.insertNodeByKey(block.key, shift + index + 1, _text2.default.create(), { normalize: false });\n        shift = shift + 1;\n      }\n\n      return t;\n    }, transform);\n  }\n};\n\n/**\n * Join adjacent text nodes.\n *\n * @type {Object}\n */\n\nvar NO_ADJACENT_TEXT_RULE = {\n  match: function match(object) {\n    return object.kind == 'block' || object.kind == 'inline';\n  },\n  validate: function validate(node) {\n    var nodes = node.nodes;\n\n    var invalids = nodes.map(function (child, i) {\n      var next = nodes.get(i + 1);\n      if (child.kind !== 'text' || !next || next.kind !== 'text') {\n        return;\n      }\n\n      return [child, next];\n    }).filter(Boolean);\n\n    return invalids.size ? invalids : null;\n  },\n  normalize: function normalize(transform, node, pairs) {\n    return pairs\n    // We reverse the list since we want to handle 3 consecutive text nodes.\n    .reverse().reduce(function (t, pair) {\n      var _pair = _slicedToArray(pair, 2),\n          first = _pair[0],\n          second = _pair[1];\n\n      return t.joinNodeByKey(second.key, first.key, { normalize: false });\n    }, transform);\n  }\n};\n\n/**\n * Prevent extra empty text nodes.\n *\n * @type {Object}\n */\n\nvar NO_EMPTY_TEXT_RULE = {\n  match: function match(object) {\n    return object.kind == 'block' || object.kind == 'inline';\n  },\n  validate: function validate(node) {\n    var nodes = node.nodes;\n\n\n    if (nodes.size <= 1) {\n      return;\n    }\n\n    var invalids = nodes.filter(function (desc, i) {\n      if (desc.kind != 'text' || desc.length > 0) {\n        return;\n      }\n\n      // Empty text nodes are only allowed near inline void node.\n      var next = nodes.get(i + 1);\n      var prev = i > 0 ? nodes.get(i - 1) : null;\n\n      // If last one and previous is an inline void, we need to preserve it.\n      if (!next && isInlineVoid(prev)) {\n        return;\n      }\n\n      // If first one and next one is an inline, we preserve it.\n      if (!prev && isInlineVoid(next)) {\n        return;\n      }\n\n      // If surrounded by inline void, we preserve it.\n      if (next && prev && isInlineVoid(next) && isInlineVoid(prev)) {\n        return;\n      }\n\n      // Otherwise we remove it.\n      return true;\n    });\n\n    return invalids.size ? invalids : null;\n  },\n  normalize: function normalize(transform, node, invalids) {\n    return invalids.reduce(function (t, text) {\n      return t.removeNodeByKey(text.key, { normalize: false });\n    }, transform);\n  }\n};\n\n/**\n * Test if a `node` is an inline void node.\n *\n * @param {Node} node\n * @return {Boolean}\n */\n\nfunction isInlineVoid(node) {\n  return node.kind == 'inline' && node.isVoid;\n}\n\n/**\n * The core schema.\n *\n * @type {Schema}\n */\n\nvar SCHEMA = _schema2.default.create({\n  rules: [DOCUMENT_CHILDREN_RULE, BLOCK_CHILDREN_RULE, INLINE_CHILDREN_RULE, VOID_TEXT_RULE, MIN_TEXT_RULE, INLINE_NO_EMPTY, INLINE_VOID_TEXTS_AROUND_RULE, NO_ADJACENT_TEXT_RULE, NO_EMPTY_TEXT_RULE]\n});\n\n/**\n * Export.\n *\n * @type {Schema}\n */\n\nexports.default = SCHEMA;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/models/controller.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _schema2 = require('./schema');\n\nvar _schema3 = _interopRequireDefault(_schema2);\n\nvar _state = require('./state');\n\nvar _state2 = _interopRequireDefault(_state);\n\nvar _immutable = require('immutable');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = (0, _debug2.default)('slate:stack');\n\n/**\n * Runnable methods.\n *\n * @type {Array}\n */\n\nvar RUNNABLE_METHODS = ['onBeforeChange', 'onBeforeInput', 'onBlur', 'onChange', 'onCopy', 'onCut', 'onDrop', 'onKeyDown', 'onPaste', 'onSelect'];\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  plugins: [],\n  schema: new _schema3.default()\n};\n\n/**\n * Stack.\n *\n * @type {Stack}\n */\n\nvar Stack = function (_ref) {\n  _inherits(Stack, _ref);\n\n  function Stack() {\n    _classCallCheck(this, Stack);\n\n    return _possibleConstructorReturn(this, (Stack.__proto__ || Object.getPrototypeOf(Stack)).apply(this, arguments));\n  }\n\n  _createClass(Stack, [{\n    key: 'run',\n\n\n    /**\n     * Run a `method` in the stack with `state`.\n     *\n     * @param {String} method\n     * @param {State} state\n     * @param {Mixed} ...args\n     * @return {State}\n     */\n\n    value: function run(method, state) {\n      var plugins = this.plugins;\n\n      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n\n        for (var _iterator = plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var plugin = _step.value;\n\n          if (!plugin[method]) continue;\n          var next = plugin[method].apply(plugin, [state].concat(args));\n\n          if (next == null) {\n            continue;\n          } else if (next instanceof _state2.default) {\n            state = next;\n          } else {\n            throw new Error('A plugin returned an unexpected state value: ' + next);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return state;\n    }\n  }, {\n    key: 'kind',\n\n\n    /**\n     * Get the kind.\n     *\n     * @return {String}\n     */\n\n    get: function get() {\n      return 'stack';\n    }\n  }], [{\n    key: 'create',\n\n\n    /**\n     * Constructor.\n     *\n     * @param {Array} plugins\n     */\n\n    value: function create(_ref2) {\n      var plugins = _ref2.plugins;\n\n      var schema = resolveSchema(plugins);\n      return new Stack({ plugins: plugins, schema: schema });\n    }\n  }]);\n\n  return Stack;\n}(new _immutable.Record(DEFAULTS));\n\n/**\n * Mix in the runnable methods.\n */\n\nvar _iteratorNormalCompletion2 = true;\nvar _didIteratorError2 = false;\nvar _iteratorError2 = undefined;\n\ntry {\n  var _loop = function _loop() {\n    var method = _step2.value;\n\n    Stack.prototype[method] = function () {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return undefined.run.apply(undefined, [method].concat(args));\n    };\n  };\n\n  for (var _iterator2 = RUNNABLE_METHODS[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n    _loop();\n  }\n\n  /**\n   * Resolve a schema from a set of `plugins`.\n   *\n   * @param {Array} plugins\n   * @return {Schema}\n   */\n} catch (err) {\n  _didIteratorError2 = true;\n  _iteratorError2 = err;\n} finally {\n  try {\n    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n      _iterator2.return();\n    }\n  } finally {\n    if (_didIteratorError2) {\n      throw _iteratorError2;\n    }\n  }\n}\n\nfunction resolveSchema(plugins) {\n  var rules = [];\n\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = plugins[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var plugin = _step3.value;\n\n      if (plugin.schema == null) continue;\n      var _schema = _schema3.default.create(plugin.schema);\n      rules = rules.concat(_schema.rules);\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  var schema = _schema3.default.create({ rules: rules });\n  return schema;\n}\n\n/**\n * Export.\n *\n * @type {Stack}\n */\n\nexports.default = Stack;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/closest.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Get the closest ancestor of an `element` that matches `selector`.\n *\n * @param {Element} elememt\n * @param {String} selector\n * @return {Element|Null}\n */\n\nfunction closest(element, selector) {\n  while (element && element.nodeType === 1) {\n    if (element.matches(selector)) return element;\n    element = element.parentNode;\n  }\n\n  return null;\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = closest;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/get-data.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _base = require('../serializers/base-64');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _types = require('../constants/types');\n\nvar _types2 = _interopRequireDefault(_types);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Fragment matching regexp for HTML nodes.\n *\n * @type {RegExp}\n */\n\nvar FRAGMENT_MATCHER = /data-slate-fragment=\"([^\\s]+)\"/;\n\n/**\n * Get the data and type from a `native` data transfer.\n *\n * @param {DataTransfer} native\n * @return {Object}\n */\n\nfunction getData(native) {\n  var fragment = native.getData(_types2.default.FRAGMENT) || null;\n  var node = native.getData(_types2.default.NODE) || null;\n  var html = native.getData('text/html') || null;\n  var rich = native.getData('text/rtf') || null;\n  var text = native.getData('text/plain') || null;\n  var files = void 0;\n\n  // If there isn't a fragment, but there is HTML, check to see if the HTML is\n  // actually an encoded fragment.\n  if (!fragment && html && ~html.indexOf('<span data-slate-fragment=\"')) {\n    var matches = FRAGMENT_MATCHER.exec(html);\n\n    var _matches = _slicedToArray(matches, 2),\n        full = _matches[0],\n        encoded = _matches[1]; // eslint-disable-line no-unused-vars\n\n\n    if (encoded) fragment = encoded;\n  }\n\n  // Decode a fragment or node if they exist.\n  if (fragment) fragment = _base2.default.deserializeNode(fragment);\n  if (node) node = _base2.default.deserializeNode(node);\n\n  // Get and normalize files if they exist.\n  if (native.items && native.items.length) {\n    var fileItems = Array.from(native.items).map(function (item) {\n      return item.kind == 'file' ? item.getAsFile() : null;\n    }).filter(function (exists) {\n      return exists;\n    });\n\n    if (fileItems.length) files = fileItems;\n  }\n\n  if (native.files && native.files.length) {\n    files = Array.from(files);\n  }\n\n  // Determine the type of the data.\n  var data = { files: files, fragment: fragment, html: html, node: node, rich: rich, text: text };\n  data.type = getType(data);\n  return data;\n}\n\n/**\n * Get the type of a transfer from its `data`.\n *\n * @param {Object} data\n * @return {String}\n */\n\nfunction getType(data) {\n  if (data.fragment) return 'fragment';\n  if (data.node) return 'node';\n\n  // COMPAT: Microsoft Word adds an image of the selected text to the data.\n  // Since files are preferred over HTML or text, this would cause the type to\n  // be considered `files`. But it also adds rich text data so we can check\n  // for that and properly set the type to `html` or `text`. (2016/11/21)\n  if (data.rich && data.html) return 'html';\n  if (data.rich && data.text) return 'text';\n\n  if (data.files) return 'files';\n  if (data.html) return 'html';\n  if (data.text) return 'text';\n  return 'unknown';\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = getData;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/get-leaf-text.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Get leaf text for a node\n *\n * @param {Node} node\n * @return {Text}\n */\n\nfunction getLeafText(node) {\n  if (node.kind == 'text') {\n    return node;\n  }\n\n  return node.getFirstText();\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = getLeafText;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/get-selection-rect.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getWindow = require('get-window');\n\nvar _getWindow2 = _interopRequireDefault(_getWindow);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Get the current selection's bounding rectangle for a given `window`.\n *\n * Modified from: https://github.com/bmcmahen/selection-position/blob/master/index.js\n *\n * @param {Window} window\n * @return {Object|Null}\n */\n\nfunction getSelectionRect(selection) {\n  if (!selection.rangeCount) return null;\n\n  var range = selection.getRangeAt(0);\n  if (!range.collapsed) return range.getBoundingClientRect();\n\n  var window = (0, _getWindow2.default)(selection.anchorNode);\n  var dummy = window.document.createElement('span');\n  range.insertNode(dummy);\n  var rect = dummy.getBoundingClientRect();\n  dummy.parentNode.removeChild(dummy);\n  return rect;\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = getSelectionRect;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/key.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * An auto-incrementing index for generating keys.\n *\n * @type {Number}\n */\n\nvar n = void 0;\n\n/**\n * The global key generating function.\n *\n * @type {Function}\n */\n\nvar generate = void 0;\n\n/**\n * Generate a key.\n *\n * @return {String}\n */\n\nfunction generateKey() {\n  return generate();\n}\n\n/**\n * Set a different unique ID generating `function`.\n *\n * @param {Function} func\n */\n\nfunction setKeyGenerator(func) {\n  generate = func;\n}\n\n/**\n * Reset the key generating function to its initial state.\n */\n\nfunction resetKeyGenerator() {\n  n = 0;\n  generate = function generate() {\n    return \"\" + n++;\n  };\n}\n\n/**\n * Set the initial state.\n */\n\nresetKeyGenerator();\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexports.default = generateKey;\nexports.setKeyGenerator = setKeyGenerator;\nexports.resetKeyGenerator = resetKeyGenerator;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/scroll-to.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getWindow = require('get-window');\n\nvar _getWindow2 = _interopRequireDefault(_getWindow);\n\nvar _selectionIsBackward = require('selection-is-backward');\n\nvar _selectionIsBackward2 = _interopRequireDefault(_selectionIsBackward);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Scroll the current selection's focus point into view if needed.\n *\n * @param {Selection} selection\n */\n\nfunction scrollToSelection(selection) {\n  var window = (0, _getWindow2.default)(selection.anchorNode);\n  var backward = (0, _selectionIsBackward2.default)(selection);\n  var range = selection.getRangeAt(0);\n  var rect = range.getBoundingClientRect();\n  var innerWidth = window.innerWidth,\n      innerHeight = window.innerHeight,\n      scrollY = window.scrollY,\n      scrollX = window.scrollX;\n\n  var top = (backward ? rect.top : rect.bottom) + scrollY;\n  var left = (backward ? rect.left : rect.right) + scrollX;\n\n  var x = left < scrollX || innerWidth + scrollX < left ? left - innerWidth / 2 : scrollX;\n\n  var y = top < scrollY || innerHeight + scrollY < top ? top - innerHeight / 2 : scrollY;\n\n  window.scrollTo(x, y);\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexports.default = scrollToSelection;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/transfer.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _base = require('../serializers/base-64');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _types = require('../constants/types');\n\nvar _types2 = _interopRequireDefault(_types);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Fragment matching regexp for HTML nodes.\n *\n * @type {RegExp}\n */\n\nvar FRAGMENT_MATCHER = /data-slate-fragment=\"([^\\s]+)\"/;\n\n/**\n * Data transfer helper.\n *\n * @type {Transfer}\n */\n\nvar Transfer = function () {\n\n  /**\n   * Constructor.\n   *\n   * @param {DataTransfer} data\n   */\n\n  function Transfer(data) {\n    _classCallCheck(this, Transfer);\n\n    this.data = data;\n    this.cache = {};\n  }\n\n  /**\n   * Get a data object representing the transfer's primary content type.\n   *\n   * @return {Object}\n   */\n\n  _createClass(Transfer, [{\n    key: 'getData',\n    value: function getData() {\n      var type = this.getType();\n      var data = {};\n      data.type = type;\n\n      switch (type) {\n        case 'files':\n          data.files = this.getFiles();\n          break;\n        case 'fragment':\n          data.fragment = this.getFragment();\n          break;\n        case 'html':\n          data.html = this.getHtml();\n          data.text = this.getText();\n          break;\n        case 'node':\n          data.node = this.getNode();\n          break;\n        case 'text':\n          data.text = this.getText();\n          break;\n      }\n\n      return data;\n    }\n\n    /**\n     * Get the Files content of the data transfer.\n     *\n     * @return {Array|Void}\n     */\n\n  }, {\n    key: 'getFiles',\n    value: function getFiles() {\n      if ('files' in this.cache) return this.cache.files;\n\n      var data = this.data;\n\n      var files = void 0;\n\n      if (data.items && data.items.length) {\n        var fileItems = Array.from(data.items).map(function (item) {\n          return item.kind == 'file' ? item.getAsFile() : null;\n        }).filter(function (exists) {\n          return exists;\n        });\n\n        if (fileItems.length) files = fileItems;\n      }\n\n      if (data.files && data.files.length) {\n        files = Array.from(data.files);\n      }\n\n      this.cache.files = files;\n      return files;\n    }\n\n    /**\n     * Get the Slate document fragment content of the data transfer.\n     *\n     * @return {Document || Void}\n     */\n\n  }, {\n    key: 'getFragment',\n    value: function getFragment() {\n      if ('fragment' in this.cache) return this.cache.fragment;\n\n      var html = this.getHtml();\n      var encoded = this.data.getData(_types2.default.FRAGMENT);\n      var fragment = void 0;\n\n      // If there's html content, and the html includes a `data-fragment`\n      // attribute, it's actually a Base64-serialized fragment from a cut/copy.\n      if (!encoded && html && ~html.indexOf('<span data-slate-fragment=\"')) {\n        var matches = FRAGMENT_MATCHER.exec(html);\n\n        var _matches = _slicedToArray(matches, 2),\n            full = _matches[0],\n            attribute = _matches[1]; // eslint-disable-line no-unused-vars\n\n\n        encoded = attribute;\n      }\n\n      if (encoded) {\n        fragment = _base2.default.deserializeNode(encoded);\n      }\n\n      this.cache.fragment = fragment;\n      return fragment;\n    }\n\n    /**\n     * Get the HTML content of the data transfer.\n     *\n     * @return {String|Void}\n     */\n\n  }, {\n    key: 'getHtml',\n    value: function getHtml() {\n      if ('html' in this.cache) return this.cache.html;\n\n      var html = void 0;\n      var string = this.data.getData('text/html');\n\n      if (string != '') html = string;\n\n      this.cache.html = html;\n      return html;\n    }\n\n    /**\n     * Get the Slate node content of the data transfer.\n     *\n     * @return {Node|Void}\n     */\n\n  }, {\n    key: 'getNode',\n    value: function getNode() {\n      if ('node' in this.cache) return this.cache.node;\n\n      var encoded = this.data.getData(_types2.default.NODE);\n      var node = void 0;\n\n      if (encoded) {\n        node = _base2.default.deserializeNode(encoded);\n      }\n\n      this.cache.node = node;\n      return node;\n    }\n\n    /**\n     * Get the rich text content of the data transfer.\n     *\n     * @return {String|Void}\n     */\n\n  }, {\n    key: 'getRichText',\n    value: function getRichText() {\n      if ('richtext' in this.cache) return this.cache.richtext;\n\n      var richtext = void 0;\n      var string = this.data.getData('text/rtf');\n\n      if (string != '') richtext = string;\n\n      this.cache.richtext = richtext;\n      return richtext;\n    }\n\n    /**\n     * Get the text content of the data transfer.\n     *\n     * @return {String|Void}\n     */\n\n  }, {\n    key: 'getText',\n    value: function getText() {\n      if ('text' in this.cache) return this.cache.text;\n\n      var text = void 0;\n      var string = this.data.getData('text/plain');\n\n      if (string != '') text = string;\n\n      this.cache.text = text;\n      return text;\n    }\n\n    /**\n     * Get the primary type of the data transfer.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'getType',\n    value: function getType() {\n      if (this.hasFragment()) return 'fragment';\n      if (this.hasNode()) return 'node';\n\n      // COMPAT: Microsoft Word adds an image of the selected text to the data.\n      // Since files are preferred over HTML or text, this would cause the type to\n      // be considered `files`. But it also adds rich text data so we can check\n      // for that and properly set the type to `html` or `text`. (2016/11/21)\n      if (this.hasRichText() && this.hasHtml()) return 'html';\n      if (this.hasRichText() && this.hasText()) return 'text';\n\n      if (this.hasFiles()) return 'files';\n      if (this.hasHtml()) return 'html';\n      if (this.hasText()) return 'text';\n      return 'unknown';\n    }\n\n    /**\n     * Check whether the data transfer has File content.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasFiles',\n    value: function hasFiles() {\n      return this.getFiles() != null;\n    }\n\n    /**\n     * Check whether the data transfer has HTML content.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasHtml',\n    value: function hasHtml() {\n      return this.getHtml() != null;\n    }\n\n    /**\n     * Check whether the data transfer has rich text content.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasRichText',\n    value: function hasRichText() {\n      return this.getRichText() != null;\n    }\n\n    /**\n     * Check whether the data transfer has text content.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasText',\n    value: function hasText() {\n      return this.getText() != null;\n    }\n\n    /**\n     * Check whether the data transfer has a Slate document fragment as content.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasFragment',\n    value: function hasFragment() {\n      return this.getFragment() != null;\n    }\n\n    /**\n     * Check whether the data transfer has a Slate node as content.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasNode',\n    value: function hasNode() {\n      return this.getNode() != null;\n    }\n  }]);\n\n  return Transfer;\n}();\n\n/**\n * Export.\n *\n * @type {Transfer}\n */\n\nexports.default = Transfer;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/uid.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _uid = require('uid');\n\nvar _uid2 = _interopRequireDefault(_uid);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Create a unique identifier.\n *\n * @return {String} uid\n */\n\nfunction uid() {\n  return (0, _uid2.default)(4);\n}\n\n/**\n * Export.\n */\n\nexports.default = uid;","/home/travis/build/npmtest/node-npmtest-slate/node_modules/slate/lib/utils/warning.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _isDev = require('../constants/is-dev');\n\nvar _isDev2 = _interopRequireDefault(_isDev);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Log a development warning.\n *\n * @param {String} message\n */\n\nfunction warning(message) {\n  if (!_isDev2.default) {\n    return;\n  }\n\n  if (typeof console !== 'undefined') {\n    var _console;\n\n    for (var _len = arguments.length, more = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      more[_key - 1] = arguments[_key];\n    }\n\n    (_console = console).error.apply(_console, ['Warning: ' + message].concat(more)); // eslint-disable-line no-console\n  }\n\n  try {\n    // --- Welcome to debugging Slate! ---\n    // This error was thrown as a convenience so that you can use this stack\n    // to find the callsite that caused this warning to fire.\n    throw new Error(message);\n  } catch (x) {\n    // This error is only for debugging.\n  }\n}\n\n/**\n * Export.\n */\n\nexports.default = warning;"}